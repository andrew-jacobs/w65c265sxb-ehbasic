
Portable 65xx Assembler [20.01]

                             ;
                             ; Enhanced BASIC to assemble for C02 Pocket SBC, $ver 2.22p4C
                             ; "C" is appended to define CMOS instructions/addressing modes used
                             ; Modified source code to assemble with WDC Tools package
                             ; All changes by K. E. Maier - July 2018
                             ;
                             ;       Assembler/Linker directives for WDC Tools
                             ;
                             ;               PL      66              ;Page Length
                             ;               PW      132             ;Page Width (# of char/line)
                             ;               CHIP    65816           ;Enable WDC 65816 instructions/addressing modes
                             ;               INCLIST ON
                             ;               PASS1   ON              ;Set ON when used for debug
                             ;
                             ; Code changes include:
                             ;               Use ROM based CHRGET routine with Page Zero pointer
                             ;               All Page zero usage from the bottom ($00) up ($AF is max available)
                             ;               CMOS opcodes/addressing modes are used! tested on WDC65C02 only!
                             ;               Version renamed to Ver 2.22p4C (concurrency with Klaus' patched version)
                             ;       The following functions and all associated code (all interrupt related)
                             ;        have been removed as they aren't needed with the C02 Pocket SBC:
                             ;       - IRQ
                             ; - RETIRQ
                             ;       - NMI
                             ; - RETNMI
                             ;       - OFF
                             ;
                             ; An EXIT primary command has been added
                             ;   The EXIT command performs a JMP to the C02Monitor Warm start vector
                             ;   EhBasic can be re-entered via Warm start unless page zero and page four are changed
                             ;
                             ; 2.00      new revision numbers start here
                             ; 2.01      fixed LCASE$() and UCASE$()
                             ; 2.02      new get value routine done
                             ; 2.03      changed RND() to galoise method
                             ; 2.04      fixed SPC()
                             ; 2.05      new get value routine fixed
                             ; 2.06      changed USR() code
                             ; 2.07      fixed STR$()
                             ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
                             ; 2.09      fixed RND()
                             ; 2.10      integrated missed changes from an earlier version
                             ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
                             ; 2.21      fixed IF .. THEN RETURN to not cause error
                             ; 2.22      fixed RND() breaking the get byte routine
                             ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
                             ;              (bugsnquirks.txt notes 2, 4 and 5)
                             ;              tabs converted to spaces, tabwidth=6
                             ; 2.22p2    fixed can't continue error on 1st statement after direct mode
                             ;              changed INPUT to throw "break in line ##" on empty line input
                             ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
                             ;              fix provided by github user mgcaret
                             ;              fixed string compare of equal strings in direct mode returns FALSE
                             ; 2.22p4    fixed FALSE stored to a variable after a string compare

Portable 65xx Assembler [20.01]

                             ;                 is > 0 and < 1E-16
                             ;              added additional stack floor protection for background interrupts
                             ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
                             ; 2.22p4C   Port to C02 Pocket SBC - uses 65C02 instructions/addressing modes
                             ;
         00000000          = ZPSTART         .EQU    $00             ; Start of zero page workspace
                             ;
         00000000          = LAB_WARM        .EQU    ZPSTART         ; $00=BASIC warm start entry point
         00000001          = Wrmjpl          .EQU    LAB_WARM+1      ; BASIC warm start vector jump low byte
         00000002          = Wrmjph          .EQU    LAB_WARM+2      ; BASIC warm start vector jump high byte

         00000003          = Usrjmp          .EQU    Wrmjph+1        ; USR function JMP address
         00000004          = Usrjpl          .EQU    Usrjmp+1        ; USR function JMP vector low byte
         00000005          = Usrjph          .EQU    Usrjmp+2        ; USR function JMP vector high byte

         00000006          = Nullct          .EQU    Usrjph+1        ; nulls output after each line
         00000007          = TPos            .EQU    Nullct+1        ; BASIC terminal position byte
         00000008          = TWidth          .EQU    TPos+1          ; BASIC terminal width byte
         00000009          = Iclim           .EQU    TWidth+1        ; input column limit
         0000000A          = Itempl          .EQU    Iclim+1         ; temporary integer low byte
         0000000B          = Itemph          .EQU    Itempl+1        ; temporary integer high byte

         0000000A          = nums_1          .EQU    Itempl          ; number to bin/hex string convert MSB
         0000000B          = nums_2          .EQU    nums_1+1        ; number to bin/hex string convert
         0000000C          = nums_3          .EQU    nums_1+2        ; number to bin/hex string convert LSB

         0000000D          = Srchc           .EQU    nums_3+1        ; search character
         0000000D          = Temp3           .EQU    Srchc           ; temp byte used in number routines
         0000000E          = Scnquo          .EQU    Srchc+1         ; scan-between-quotes flag
         0000000E          = Asrch           .EQU    Scnquo          ; alt search character

         0000000D          = XOAw_l          .EQU    Srchc           ; eXclusive OR, OR and AND word low byte
         0000000E          = XOAw_h          .EQU    Scnquo          ; eXclusive OR, OR and AND word high byte

         0000000F          = Ibptr           .EQU    Scnquo+1        ; input buffer pointer
         0000000F          = Dimcnt          .EQU    Ibptr           ; # of dimensions
         0000000F          = Tindx           .EQU    Ibptr           ; token index

         00000010          = Defdim          .EQU    Ibptr+1         ; default DIM flag
         00000011          = Dtypef          .EQU    Defdim+1        ; data type flag, $FF=string, $00=numeric
         00000012          = Oquote          .EQU    Dtypef+1        ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
         00000012          = Gclctd          .EQU    Oquote          ; garbage collected flag
         00000013          = Sufnxf          .EQU    Gclctd+1        ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
         00000014          = Imode           .EQU    Sufnxf+1        ; input mode flag, $00=INPUT, $80=READ

         00000015          = Cflag           .EQU    Imode+1         ; comparison evaluation flag

         00000016          = TabSiz          .EQU    Cflag+1         ; TAB step size (was input flag)

         00000017          = next_s          .EQU    TabSiz+1        ; next descriptor stack address

                             ; these two bytes form a word pointer to the item
                             ; currently on top of the descriptor stack


Portable 65xx Assembler [20.01]

         00000018          = last_sl         .EQU    next_s+1        ; last descriptor stack address low byte
         00000019          = last_sh         .EQU    last_sl+1       ; last descriptor stack address high byte (always $00)

         0000001A          = des_sk          .EQU    last_sh+1       ; descriptor stack start address (temp strings)

         00000023          = ut1_pl          .EQU    des_sk+9        ; utility pointer 1 low byte
         00000024          = ut1_ph          .EQU    ut1_pl+1        ; utility pointer 1 high byte
         00000025          = ut2_pl          .EQU    ut1_ph+1        ; utility pointer 2 low byte
         00000026          = ut2_ph          .EQU    ut2_pl+1        ; utility pointer 2 high byte

         00000023          = Temp_2          .EQU    ut1_pl          ; temp byte for block move

         00000027          = FACt_1          .EQU    ut2_ph+1        ; FAC temp mantissa1
         00000028          = FACt_2          .EQU    FACt_1+1        ; FAC temp mantissa2
         00000029          = FACt_3          .EQU    FACt_2+1        ; FAC temp mantissa3

         00000028          = dims_l          .EQU    FACt_2          ; array dimension size low byte
         00000029          = dims_h          .EQU    FACt_3          ; array dimension size high byte

         0000002A          = TempB           .EQU    FACt_1+3        ; temp page 0 byte

         0000002B          = Smeml           .EQU    TempB+1         ; start of mem low byte         (Start-of-Basic)
         0000002C          = Smemh           .EQU    Smeml+1         ; start of mem high byte        (Start-of-Basic)
         0000002D          = Svarl           .EQU    Smemh+1         ; start of vars low byte        (Start-of-Variables)
         0000002E          = Svarh           .EQU    Svarl+1         ; start of vars high byte       (Start-of-Variables)
         0000002F          = Sarryl          .EQU    Svarh+1         ; var mem end low byte          (Start-of-Arrays)
         00000030          = Sarryh          .EQU    Sarryl+1        ; var mem end high byte         (Start-of-Arrays)
         00000031          = Earryl          .EQU    Sarryh+1        ; array mem end low byte        (End-of-Arrays)
         00000032          = Earryh          .EQU    Earryl+1        ; array mem end high byte       (End-of-Arrays)
         00000033          = Sstorl          .EQU    Earryh+1        ; string storage low byte       (String storage (moving down))
         00000034          = Sstorh          .EQU    Sstorl+1        ; string storage high byte      (String storage (moving down))
         00000035          = Sutill          .EQU    Sstorh+1        ; string utility ptr low byte
         00000036          = Sutilh          .EQU    Sutill+1        ; string utility ptr high byte
         00000037          = Ememl           .EQU    Sutilh+1        ; end of mem low byte           (Limit-of-memory)
         00000038          = Ememh           .EQU    Ememl+1         ; end of mem high byte          (Limit-of-memory)
         00000039          = Clinel          .EQU    Ememh+1         ; current line low byte         (Basic line number)
         0000003A          = Clineh          .EQU    Clinel+1        ; current line high byte        (Basic line number)
         0000003B          = Blinel          .EQU    Clineh+1        ; break line low byte           (Previous Basic line number)
         0000003C          = Blineh          .EQU    Blinel+1        ; break line high byte          (Previous Basic line number)

         0000003D          = Cpntrl          .EQU    Blineh+1        ; continue pointer low byte
         0000003E          = Cpntrh          .EQU    Cpntrl+1        ; continue pointer high byte

         0000003F          = Dlinel          .EQU    Cpntrh+1        ; current DATA line low byte
         00000040          = Dlineh          .EQU    Dlinel+1        ; current DATA line high byte

         00000041          = Dptrl           .EQU    Dlineh+1        ; DATA pointer low byte
         00000042          = Dptrh           .EQU    Dptrl+1         ; DATA pointer high byte

         00000043          = Rdptrl          .EQU    Dptrh+1         ; read pointer low byte
         00000044          = Rdptrh          .EQU    Rdptrl+1        ; read pointer high byte

         00000045          = Varnm1          .EQU    Rdptrh+1        ; current var name 1st byte
         00000046          = Varnm2          .EQU    Varnm1+1        ; current var name 2nd byte

Portable 65xx Assembler [20.01]


         00000047          = Cvaral          .EQU    Varnm2+1        ; current var address low byte
         00000048          = Cvarah          .EQU    Cvaral+1        ; current var address high byte

         00000049          = Frnxtl          .EQU    Cvarah+1        ; var pointer for FOR/NEXT low byte
         0000004A          = Frnxth          .EQU    Frnxtl+1        ; var pointer for FOR/NEXT high byte

         00000049          = Tidx1           .EQU    Frnxtl          ; temp line index

         00000049          = Lvarpl          .EQU    Frnxtl          ; let var pointer low byte
         0000004A          = Lvarph          .EQU    Frnxth          ; let var pointer high byte

         0000004B          = prstk           .EQU    Frnxtl+2        ; precedence stacked flag

         0000004D          = comp_f          .EQU    prstk+2         ; compare function flag, bits 0,1 and 2 used
                                                                     ; bit 2 set if >
                                                                     ; bit 1 set if =
                                                                     ; bit 0 set if <

         0000004E          = func_l          .EQU    comp_f+1        ; function pointer low byte
         0000004F          = func_h          .EQU    func_l+1        ; function pointer high byte

         0000004E          = garb_l          .EQU    func_l          ; garbage collection working pointer low byte
         0000004F          = garb_h          .EQU    func_h          ; garbage collection working pointer high byte

         00000050          = des_2l          .EQU    func_h+1        ; string descriptor_2 pointer low byte
         00000051          = des_2h          .EQU    des_2l+1        ; string descriptor_2 pointer high byte

         00000052          = g_step          .EQU    des_2l+2        ; garbage collect step size

         00000053          = Fnxjmp          .EQU    g_step+1        ; jump vector for functions
         00000054          = Fnxjpl          .EQU    Fnxjmp+1        ; functions jump vector low byte
         00000055          = Fnxjph          .EQU    Fnxjmp+2        ; functions jump vector high byte

         00000054          = g_indx          .EQU    Fnxjpl          ; garbage collect temp index

         00000055          = FAC2_r          .EQU    Fnxjmp+2        ; FAC2 rounding byte

         00000056          = Adatal          .EQU    FAC2_r+1        ; array data pointer low byte
         00000057          = Adatah          .EQU    Adatal+1        ; array data pointer high  byte

         00000056          = Nbendl          .EQU    Adatal          ; new block end pointer low byte
         00000057          = Nbendh          .EQU    Adatah          ; new block end pointer high  byte

         00000058          = Obendl          .EQU    Adatah+1        ; old block end pointer low byte
         00000059          = Obendh          .EQU    Obendl+1        ; old block end pointer high  byte

         0000005A          = numexp          .EQU    Obendh+1        ; string to float number exponent count
         0000005B          = expcnt          .EQU    numexp+1        ; string to float exponent count

         0000005A          = numbit          .EQU    numexp          ; bit count for array element calculations

         0000005C          = numdpf          .EQU    expcnt+1        ; string to float decimal point flag
         0000005D          = expneg          .EQU    numdpf+1        ; string to float eval exponent -ve flag

Portable 65xx Assembler [20.01]


         0000005C          = Astrtl          .EQU    numdpf          ; array start pointer low byte
         0000005D          = Astrth          .EQU    expneg          ; array start pointer high  byte

         0000005C          = Histrl          .EQU    numdpf          ; highest string low byte
         0000005D          = Histrh          .EQU    expneg          ; highest string high  byte

         0000005C          = Baslnl          .EQU    numdpf          ; BASIC search line pointer low byte
         0000005D          = Baslnh          .EQU    expneg          ; BASIC search line pointer high  byte

         0000005C          = Fvar_l          .EQU    numdpf          ; find/found variable pointer low byte
         0000005D          = Fvar_h          .EQU    expneg          ; find/found variable pointer high  byte

         0000005C          = Ostrtl          .EQU    numdpf          ; old block start pointer low byte
         0000005D          = Ostrth          .EQU    expneg          ; old block start pointer high  byte

         0000005C          = Vrschl          .EQU    numdpf          ; variable search pointer low byte
         0000005D          = Vrschh          .EQU    expneg          ; variable search pointer high  byte

         0000005E          = FAC1_e          .EQU    expneg+1        ; FAC1 exponent
         0000005F          = FAC1_1          .EQU    FAC1_e+1        ; FAC1 mantissa1
         00000060          = FAC1_2          .EQU    FAC1_e+2        ; FAC1 mantissa2
         00000061          = FAC1_3          .EQU    FAC1_e+3        ; FAC1 mantissa3
         00000062          = FAC1_s          .EQU    FAC1_e+4        ; FAC1 sign (b7)

         0000005E          = str_ln          .EQU    FAC1_e          ; string length
         0000005F          = str_pl          .EQU    FAC1_1          ; string pointer low byte
         00000060          = str_ph          .EQU    FAC1_2          ; string pointer high byte

         00000060          = des_pl          .EQU    FAC1_2          ; string descriptor pointer low byte
         00000061          = des_ph          .EQU    FAC1_3          ; string descriptor pointer high byte

         00000061          = mids_l          .EQU    FAC1_3          ; MID$ string temp length byte

         00000063          = negnum          .EQU    FAC1_e+5        ; string to float eval -ve flag
         00000063          = numcon          .EQU    negnum          ; series evaluation constant count

         00000064          = FAC1_o          .EQU    negnum+1        ; FAC1 overflow byte

         00000065          = FAC2_e          .EQU    FAC1_o+1        ; FAC2 exponent
         00000066          = FAC2_1          .EQU    FAC2_e+1        ; FAC2 mantissa1
         00000067          = FAC2_2          .EQU    FAC2_e+2        ; FAC2 mantissa2
         00000068          = FAC2_3          .EQU    FAC2_e+3        ; FAC2 mantissa3
         00000069          = FAC2_s          .EQU    FAC2_e+4        ; FAC2 sign (b7)

         0000006A          = FAC_sc          .EQU    FAC2_e+5        ; FAC sign comparison, Acc#1 vs #2
         0000006B          = FAC1_r          .EQU    FAC_sc+1        ; FAC1 rounding byte

         0000006A          = ssptr_l         .EQU    FAC_sc          ; string start pointer low byte
         0000006B          = ssptr_h         .EQU    FAC1_r          ; string start pointer high byte

         0000006A          = sdescr          .EQU    FAC_sc          ; string descriptor pointer

         0000006C          = csidx           .EQU    FAC1_r+1        ; line crunch save index

Portable 65xx Assembler [20.01]

         0000006C          = Asptl           .EQU    csidx           ; array size/pointer low byte
         0000006D          = Aspth           .EQU    csidx+1         ; array size/pointer high byte

         0000006C          = Btmpl           .EQU    Asptl           ; BASIC pointer temp low byte
         0000006D          = Btmph           .EQU    Aspth           ; BASIC pointer temp low byte

         0000006C          = Cptrl           .EQU    Asptl           ; BASIC pointer temp low byte
         0000006D          = Cptrh           .EQU    Aspth           ; BASIC pointer temp low byte

         0000006C          = Sendl           .EQU    Asptl           ; BASIC pointer temp low byte
         0000006D          = Sendh           .EQU    Aspth           ; BASIC pointer temp low byte
                             ;
                             ; CHRGET routine now located in ROM
                             ; The two pointers below are accessed via ROM
                             ; Reduces Page zero usage by quite a bit with a small performance penalty
                             ;
         0000006E          = Bpntrl          .EQU    Sendh+1         ; BASIC execute (get byte) pointer low byte
         0000006F          = Bpntrh          .EQU    Bpntrl+1        ; BASIC execute (get byte) pointer high byte

         00000070          = Rbyte4          .EQU    Bpntrh+1        ; extra PRNG byte

         00000071          = Rbyte1          .EQU    Rbyte4+1        ; most significant PRNG byte
         00000072          = Rbyte2          .EQU    Rbyte4+2        ; middle PRNG byte
         00000073          = Rbyte3          .EQU    Rbyte4+3        ; least significant PRNG byte

         00000074          = Decss           .EQU    Rbyte3+1        ; number to decimal string start
         00000075          = Decssp1         .EQU    Decss+1         ; number to decimal string start
         00000085          = ZPLastByte      .EQU    Decss+17

                             ; Note: C02BIOS uses Page Zero locations from $E0 - $FF
                             ;       C02Monitor uses Page Zero locations from $B0 - $DF

                             ; token values needed for BASIC

                             ; primary command tokens (can start a statement)

         00000080          = TK_END          .EQU    $80             ; END token
         00000081          = TK_FOR          .EQU    TK_END+1        ; FOR token
         00000082          = TK_NEXT         .EQU    TK_FOR+1        ; NEXT token
         00000083          = TK_DATA         .EQU    TK_NEXT+1       ; DATA token
         00000084          = TK_INPUT        .EQU    TK_DATA+1       ; INPUT token
         00000085          = TK_DIM          .EQU    TK_INPUT+1      ; DIM token
         00000086          = TK_READ         .EQU    TK_DIM+1        ; READ token
         00000087          = TK_LET          .EQU    TK_READ+1       ; LET token
         00000088          = TK_DEC          .EQU    TK_LET+1        ; DEC token
         00000089          = TK_GOTO         .EQU    TK_DEC+1        ; GOTO token
         0000008A          = TK_RUN          .EQU    TK_GOTO+1       ; RUN token
         0000008B          = TK_IF           .EQU    TK_RUN+1        ; IF token
         0000008C          = TK_RESTORE      .EQU    TK_IF+1         ; RESTORE token
         0000008D          = TK_GOSUB        .EQU    TK_RESTORE+1    ; GOSUB token
         0000008E          = TK_RETURN       .EQU    TK_GOSUB+1      ; RETURN token
         0000008F          = TK_REM          .EQU    TK_RETURN+1     ; REM token
         00000090          = TK_STOP         .EQU    TK_REM+1        ; STOP token
         00000091          = TK_ON           .EQU    TK_STOP+1       ; ON token

Portable 65xx Assembler [20.01]

         00000092          = TK_NULL         .EQU    TK_ON+1         ; NULL token
         00000093          = TK_INC          .EQU    TK_NULL+1       ; INC token
         00000094          = TK_WAIT         .EQU    TK_INC+1        ; WAIT token
         00000095          = TK_LOAD         .EQU    TK_WAIT+1       ; LOAD token
         00000096          = TK_SAVE         .EQU    TK_LOAD+1       ; SAVE token
         00000097          = TK_DEF          .EQU    TK_SAVE+1       ; DEF token
         00000098          = TK_POKE         .EQU    TK_DEF+1        ; POKE token
         00000099          = TK_DOKE         .EQU    TK_POKE+1       ; DOKE token
         0000009A          = TK_CALL         .EQU    TK_DOKE+1       ; CALL token
         0000009B          = TK_DO           .EQU    TK_CALL+1       ; DO token
         0000009C          = TK_LOOP         .EQU    TK_DO+1         ; LOOP token
         0000009D          = TK_PRINT        .EQU    TK_LOOP+1       ; PRINT token
         0000009E          = TK_CONT         .EQU    TK_PRINT+1      ; CONT token
         0000009F          = TK_LIST         .EQU    TK_CONT+1       ; LIST token
         000000A0          = TK_CLEAR        .EQU    TK_LIST+1       ; CLEAR token
         000000A1          = TK_NEW          .EQU    TK_CLEAR+1      ; NEW token
         000000A2          = TK_WIDTH        .EQU    TK_NEW+1        ; WIDTH token
         000000A3          = TK_GET          .EQU    TK_WIDTH+1      ; GET token
         000000A4          = TK_SWAP         .EQU    TK_GET+1        ; SWAP token
         000000A5          = TK_BITSET       .EQU    TK_SWAP+1       ; BITSET token
         000000A6          = TK_BITCLR       .EQU    TK_BITSET+1     ; BITCLR token
         000000A7          = TK_EXIT         .EQU    TK_BITCLR+1     ; EXIT token

                             ; secondary command tokens, can't start a statement

         000000A8          = TK_TAB          .EQU    TK_EXIT+1       ; TAB token
         000000A9          = TK_ELSE         .EQU    TK_TAB+1        ; ELSE token
         000000AA          = TK_TO           .EQU    TK_ELSE+1       ; TO token
         000000AB          = TK_FN           .EQU    TK_TO+1         ; FN token
         000000AC          = TK_SPC          .EQU    TK_FN+1         ; SPC token
         000000AD          = TK_THEN         .EQU    TK_SPC+1        ; THEN token
         000000AE          = TK_NOT          .EQU    TK_THEN+1       ; NOT token
         000000AF          = TK_STEP         .EQU    TK_NOT+1        ; STEP token
         000000B0          = TK_UNTIL        .EQU    TK_STEP+1       ; UNTIL token
         000000B1          = TK_WHILE        .EQU    TK_UNTIL+1      ; WHILE token

                             ; operator tokens

         000000B2          = TK_PLUS         .EQU    TK_WHILE+1      ; + token
         000000B3          = TK_MINUS        .EQU    TK_PLUS+1       ; - token
         000000B4          = TK_MUL          .EQU    TK_MINUS+1      ; * token
         000000B5          = TK_DIV          .EQU    TK_MUL+1        ; / token
         000000B6          = TK_POWER        .EQU    TK_DIV+1        ; ^ token
         000000B7          = TK_AND          .EQU    TK_POWER+1      ; AND token
         000000B8          = TK_EOR          .EQU    TK_AND+1        ; EOR token
         000000B9          = TK_OR           .EQU    TK_EOR+1        ; OR token
         000000BA          = TK_RSHIFT       .EQU    TK_OR+1         ; RSHIFT token
         000000BB          = TK_LSHIFT       .EQU    TK_RSHIFT+1     ; LSHIFT token
         000000BC          = TK_GT           .EQU    TK_LSHIFT+1     ; > token
         000000BD          = TK_EQUAL        .EQU    TK_GT+1         ; = token
         000000BE          = TK_LT           .EQU    TK_EQUAL+1      ; < token

                             ; function tokens


Portable 65xx Assembler [20.01]

         000000BF          = TK_SGN          .EQU    TK_LT+1         ; SGN token
         000000C0          = TK_INT          .EQU    TK_SGN+1        ; INT token
         000000C1          = TK_ABS          .EQU    TK_INT+1        ; ABS token
         000000C2          = TK_USR          .EQU    TK_ABS+1        ; USR token
         000000C3          = TK_FRE          .EQU    TK_USR+1        ; FRE token
         000000C4          = TK_POS          .EQU    TK_FRE+1        ; POS token
         000000C5          = TK_SQR          .EQU    TK_POS+1        ; SQR token
         000000C6          = TK_RND          .EQU    TK_SQR+1        ; RND token
         000000C7          = TK_LOG          .EQU    TK_RND+1        ; LOG token
         000000C8          = TK_EXP          .EQU    TK_LOG+1        ; EXP token
         000000C9          = TK_COS          .EQU    TK_EXP+1        ; COS token
         000000CA          = TK_SIN          .EQU    TK_COS+1        ; SIN token
         000000CB          = TK_TAN          .EQU    TK_SIN+1        ; TAN token
         000000CC          = TK_ATN          .EQU    TK_TAN+1        ; ATN token
         000000CD          = TK_PEEK         .EQU    TK_ATN+1        ; PEEK token
         000000CE          = TK_DEEK         .EQU    TK_PEEK+1       ; DEEK token
         000000CF          = TK_SADD         .EQU    TK_DEEK+1       ; SADD token
         000000D0          = TK_LEN          .EQU    TK_SADD+1       ; LEN token
         000000D1          = TK_STRS         .EQU    TK_LEN+1        ; STR$ token
         000000D2          = TK_VAL          .EQU    TK_STRS+1       ; VAL token
         000000D3          = TK_ASC          .EQU    TK_VAL+1        ; ASC token
         000000D4          = TK_UCASES       .EQU    TK_ASC+1        ; UCASE$ token
         000000D5          = TK_LCASES       .EQU    TK_UCASES+1     ; LCASE$ token
         000000D6          = TK_CHRS         .EQU    TK_LCASES+1     ; CHR$ token
         000000D7          = TK_HEXS         .EQU    TK_CHRS+1       ; HEX$ token
         000000D8          = TK_BINS         .EQU    TK_HEXS+1       ; BIN$ token
         000000D9          = TK_BITTST       .EQU    TK_BINS+1       ; BITTST token
         000000DA          = TK_MAX          .EQU    TK_BITTST+1     ; MAX token
         000000DB          = TK_MIN          .EQU    TK_MAX+1        ; MIN token
         000000DC          = TK_PI           .EQU    TK_MIN+1        ; PI token
         000000DD          = TK_TWOPI        .EQU    TK_PI+1         ; TWOPI token
         000000DE          = TK_VPTR         .EQU    TK_TWOPI+1      ; VARPTR token
         000000DF          = TK_LEFTS        .EQU    TK_VPTR+1       ; LEFT$ token
         000000E0          = TK_RIGHTS       .EQU    TK_LEFTS+1      ; RIGHT$ token
         000000E1          = TK_MIDS         .EQU    TK_RIGHTS+1     ; MID$ token

                             ; offsets from a base of X or Y

         00000000          = PLUS_0          .EQU    $00             ; X or Y plus 0
         00000001          = PLUS_1          .EQU    $01             ; X or Y plus 1
         00000002          = PLUS_2          .EQU    $02             ; X or Y plus 2
         00000003          = PLUS_3          .EQU    $03             ; X or Y plus 3

         00000020          = STACK_RES       .EQU    $20             ; reserved stack space

         00000100          = LAB_STAK        .EQU    $0100           ; stack bottom, no offset

         000001FE          = LAB_SKFE        .EQU    LAB_STAK+$FE
                             ; flushed stack address
         000001FF          = LAB_SKFF        .EQU    LAB_STAK+$FF
                             ; flushed stack address

                             ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
                             ; the input buffer must not cross a page boundary and must not overlap with

Portable 65xx Assembler [20.01]

                             ; program RAM pages!

         00000400          = Ibuffs          .EQU    $0400           ; Start of input buffer
         0000047E          = Ibuffe          .EQU    $0400+$7E       ; end of input buffer (127 bytes)

         0000047F          = ccflag          .EQU    Ibuffe+1        ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
         00000480          = ccbyte          .EQU    ccflag+1        ; BASIC CTRL-C byte
         00000481          = ccnull          .EQU    ccbyte+1        ; BASIC CTRL-C byte timeout

         00000482          = VEC_CC          .EQU    ccnull+1        ; ctrl c check vector

         00000484          = VEC_IN          .EQU    VEC_CC+2        ; input vector
         00000486          = VEC_OUT         .EQU    VEC_IN+2        ; output vector
         00000488          = VEC_LD          .EQU    VEC_OUT+2       ; load vector
         0000048A          = VEC_SV          .EQU    VEC_LD+2        ; save vector
         0000048C          = VEC_EXIT        .EQU    VEC_SV+2        ; exit vector

         00000800          = Ram_base        .EQU    $0800           ; start of user RAM (1st 2KB used/reserved)
         00008000          = Ram_top         .EQU    $8000           ; end of user RAM+1 ($8000 is start of ROM)


                             ;===============================================================================
                             ; Minimal W65C265 Support Code
                             ;-------------------------------------------------------------------------------

                                             .INCLUDE "w65c265sxb.inc"
                             ;==============================================================================
                             ; __        ____  ____   ____ ____   __  ____ ______  ______
                             ; \ \      / / /_| ___| / ___|___ \ / /_| ___/ ___\ \/ / __ )
                             ;  \ \ /\ / / '_ \___ \| |     __) | '_ \___ \___ \\  /|  _ \
                             ;   \ V  V /| (_) |__) | |___ / __/| (_) |__) |__) /  \| |_) |
                             ;    \_/\_/  \___/____/ \____|_____|\___/____/____/_/\_\____/
                             ;
                             ; Western Design Center W65C265SXB Development Board Hardware Definitions
                             ;------------------------------------------------------------------------------
                             ; Copyright (C)2015-2020 HandCoded Software Ltd.
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;
                             ;==============================================================================
                             ; Notes:
                             ;
                             ;------------------------------------------------------------------------------

         00384000          = OSC_FREQ        .equ    3686400         ; SXB runs at 3.6864MHz
         00008000          = CLK_FREQ        .equ    32768           ; CLK runs at 32768Hz

         00C00000          = BOOT_ENTRY      .equ    $c00000


Portable 65xx Assembler [20.01]

                                             .include "w65c265.inc"
                             ;===============================================================================
                             ; __        ____  ____   ____ ____   __  ____
                             ; \ \      / / /_| ___| / ___|___ \ / /_| ___|
                             ;  \ \ /\ / / '_ \___ \| |     __) | '_ \___ \
                             ;   \ V  V /| (_) |__) | |___ / __/| (_) |__) |
                             ;    \_/\_/  \___/____/ \____|_____|\___/____/
                             ;
                             ; Western Design Center W65C265 device definitions
                             ;-------------------------------------------------------------------------------
                             ; Copyright (C)2015 HandCoded Software Ltd.
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;
                             ;===============================================================================
                             ; Notes:
                             ;
                             ; Various macros and definitions for the W65C265 microcontroller.
                             ;
                             ;===============================================================================
                             ; Revision History:
                             ;
                             ; 2015-12-18 AJ Initial version
                             ;-------------------------------------------------------------------------------

                             ;===============================================================================
                             ; Hardware Registers
                             ;-------------------------------------------------------------------------------

                             ;00DF00-1F CS0 Port Replacement & Expansion uninitialized

         0000DF00          = PD0             .equ    $00DF00         ; Port 0 Data Register
         0000DF01          = PD1             .equ    $00DF01         ; Port 1 Data Register
         0000DF02          = PD2             .equ    $00DF02         ; Port 2 Data Register
         0000DF03          = PD3             .equ    $00DF03         ; Port 3 Data Register
         0000DF04          = PDD0            .equ    $00DF04         ; Port 0 Data Direction Register
         0000DF05          = PDD1            .equ    $00DF05         ; Port 1 Data Direction Register
         0000DF06          = PDD2            .equ    $00DF06         ; Port 2 Data Direction Register
         0000DF07          = PDD3            .equ    $00DF07         ; Port 3 Data Direction Register

         0000DF20          = PD4             .equ    $00DF20         ; Port 4 Data Register
         0000DF21          = PD5             .equ    $00DF21         ; Port 5 Data Register
         0000DF22          = PD6             .equ    $00DF22         ; Port 6 Data Register
         0000DF23          = PD7             .equ    $00DF23         ; Port 7 Data Register
         0000DF24          = PDD4            .equ    $00DF24         ; Port 4 Data Direction Register
         0000DF25          = PDD5            .equ    $00DF25         ; Port 5 Data Direction Register
         0000DF26          = PDD6            .equ    $00DF26         ; Port 6 Data Direction Register
         0000DF27          = PCS7            .equ    $00DF27         ; Port 7 Chip Select


Portable 65xx Assembler [20.01]

                             ;00DF28-3F --- Reserved uninitialized

         0000DF40          = BCR             .equ    $00DF40         ; Bus Control Register
         0000DF41          = SSCR            .equ    $00DF41         ; System Speed Control Register
         0000DF42          = TCR             .equ    $00DF42         ; Timer Control Register
         0000DF43          = TER             .equ    $00DF43         ; Timer Enable Register
         0000DF44          = TIFR            .equ    $00DF44         ; Timer Interrupt Flag Register
         0000DF45          = EIFR            .equ    $00DF45         ; Edge Interrupt Flag Register
         0000DF46          = TIER            .equ    $00DF46         ; Timer Interrupt Enable Register
         0000DF47          = EIER            .equ    $00DF47         ; Edge Interrupt Enable Register
         0000DF48          = UIFR            .equ    $00DF48         ; UART Interrupt Flag Register
         0000DF49          = UIER            .equ    $00DF49         ; UART Interrupt Enable Register

         0000DF50          = T0LL            .equ    $00DF50         ; Timer 0 Latch Low
         0000DF51          = T0LH            .equ    $00DF51         ; Timer 0 Latch High
         0000DF52          = T1LL            .equ    $00DF52         ; Timer 1 Latch Low
         0000DF53          = T1LH            .equ    $00DF53         ; Timer 1 Latch High
         0000DF54          = T2LL            .equ    $00DF54         ; Timer 2 Latch Low
         0000DF55          = T2LH            .equ    $00DF55         ; Timer 2 Latch High
         0000DF56          = T3LL            .equ    $00DF56         ; Timer 3 Latch Low
         0000DF57          = T3LH            .equ    $00DF57         ; Timer 3 Latch High
         0000DF58          = T4LL            .equ    $00DF58         ; Timer 4 Latch Low
         0000DF59          = T4LH            .equ    $00DF59         ; Timer 4 Latch High
         0000DF5A          = T5LL            .equ    $00DF5A         ; Timer 5 Latch Low
         0000DF5B          = T5LH            .equ    $00DF5B         ; Timer 5 Latch High
         0000DF5C          = T6LL            .equ    $00DF5C         ; Timer 6 Latch Low
         0000DF5D          = T6LH            .equ    $00DF5D         ; Timer 6 Latch High
         0000DF5E          = T7LL            .equ    $00DF5E         ; Timer 7 Latch Low
         0000DF5F          = T7LH            .equ    $00DF5F         ; Timer 7 Latch High
         0000DF60          = T0CL            .equ    $00DF60         ; Timer 0 Counter Low
         0000DF61          = T0CH            .equ    $00DF61         ; Timer 0 Counter High
         0000DF62          = T1CL            .equ    $00DF62         ; Timer 1 Counter Low
         0000DF63          = T1CH            .equ    $00DF63         ; Timer 1 Counter High
         0000DF64          = T2CL            .equ    $00DF64         ; Timer 2 Counter Low
         0000DF65          = T2CH            .equ    $00DF65         ; Timer 2 Counter High
         0000DF66          = T3CL            .equ    $00DF66         ; Timer 3 Counter Low
         0000DF67          = T3CH            .equ    $00DF67         ; Timer 3 Counter High
         0000DF68          = T4CL            .equ    $00DF68         ; Timer 4 Counter Low
         0000DF69          = T4CH            .equ    $00DF69         ; Timer 4 Counter High
         0000DF6A          = T5CL            .equ    $00DF6A         ; Timer 5 Counter Low
         0000DF6B          = T5CH            .equ    $00DF6B         ; Timer 5 Counter High
         0000DF6C          = T6CL            .equ    $00DF6C         ; Timer 6 Counter Low
         0000DF6D          = T6CH            .equ    $00DF6D         ; Timer 6 Counter High
         0000DF6E          = T7CL            .equ    $00DF6E         ; Timer 7 Counter Low
         0000DF6F          = T7CH            .equ    $00DF6F         ; Timer 7 Counter High

                             ;00DFC0-FF CS1 COProcessor Expansion uninitialized

         0000DF70          = ACSR0           .equ    $00DF70         ; UART 0 Control/Status Register
         0000DF71          = ARTD0           .equ    $00DF71         ; UART 0 Data Register
         0000DF72          = ACSR1           .equ    $00DF72         ; UART 1 Control/Status Register
         0000DF73          = ARTD1           .equ    $00DF73         ; UART 1 Data Register
         0000DF74          = ACSR2           .equ    $00DF74         ; UART 2 Control/Status Register
         0000DF75          = ARTD2           .equ    $00DF75         ; UART 2 Data Register

Portable 65xx Assembler [20.01]

         0000DF76          = ACSR3           .equ    $00DF76         ; UART 3 Control/Status Register
         0000DF77          = ARTD3           .equ    $00DF77         ; UART 3 Data Register
         0000DF78          = PIBFR           .equ    $00DF78         ; Parallel Interface Flag Register
         0000DF79          = PIBER           .equ    $00DF79         ; Parallel Interface Enable Register
         0000DF7A          = PIR2            .equ    $00DF7A         ; Parallel Interface Register 2
         0000DF7B          = PIR3            .equ    $00DF7B         ; Parallel Interface Register 3
         0000DF7C          = PIR4            .equ    $00DF7C         ; Parallel Interface Register 4
         0000DF7D          = PIR5            .equ    $00DF7D         ; Parallel Interface Register 5
         0000DF7E          = PIR6            .equ    $00DF7E         ; Parallel Interface Register 6
         0000DF7F          = PIR7            .equ    $00DF7F         ; Parallel Interface Register 7

                             ;00DF80-BF RAM RAM Registers uninitialized

                                             .include "w65c816.inc"
                             ;==============================================================================
                             ; __        ____  ____   ____ ___  _  __
                             ; \ \      / / /_| ___| / ___( _ )/ |/ /_
                             ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \
                             ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
                             ;    \_/\_/  \___/____/ \____\___/|_|\___/
                             ;
                             ; Western Design Center W65C816 device definitions
                             ;------------------------------------------------------------------------------
                             ; Copyright (C)2015 HandCoded Software Ltd.
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;
                             ;===============================================================================
                             ; Notes:
                             ;
                             ; Various macros and definitions for the W65C816 microprocessor.
                             ;
                             ;===============================================================================
                             ; Revision History:
                             ;
                             ; 2015-12-18 AJ Initial version
                             ;-------------------------------------------------------------------------------

                             ;==============================================================================
                             ; Status Register Bits
                             ;------------------------------------------------------------------------------

         00000080          = N_FLAG          .equ    1<<7
         00000040          = V_FLAG          .equ    1<<6
         00000020          = M_FLAG          .equ    1<<5
         00000010          = X_FLAG          .equ    1<<4
         00000010          = B_FLAG          .equ    1<<4
         00000008          = D_FLAG          .equ    1<<3
         00000004          = I_FLAG          .equ    1<<2

Portable 65xx Assembler [20.01]

         00000002          = Z_FLAG          .equ    1<<1
         00000001          = C_FLAG          .equ    1<<0

                             ;==============================================================================
                             ; Macros
                             ;------------------------------------------------------------------------------

                             ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
                             ; is fixed at $0100-$01ff.

                             emulate         .macro
                                             sec
                                             xce
                                             .endm

                             ; Puts the processor in native mode. The size of the memory and index register
                             ; operations is not controlled by the M & X bits in the status register.

                             native          .macro
                                             clc
                                             xce
                                             .endm

                             ; Resets the M bit making the accumulator and memory accesses 16-bits wide.

                             long_a          .macro
                                             rep     #M_FLAG
                                             .longa  on
                                             .endm

                             ; Resets the X bit making the index registers 16-bits wide

                             long_i          .macro
                                             rep     #X_FLAG
                                             .longi  on
                                             .endm

                             ; Resets the M and X bits making the accumulator, memory accesses and index
                             ; registers 16-bits wide.

                             long_ai         .macro
                                             rep     #M_FLAG|X_FLAG
                                             .longa  on
                                             .longi  on
                                             .endm

                             ; Sets the M bit making the accumulator and memory accesses 8-bits wide.

                             short_a         .macro
                                             sep     #M_FLAG
                                             .longa  off
                                             .endm

                             ; Sets the X bit making the index registers 8-bits wide.

Portable 65xx Assembler [20.01]


                             short_i         .macro
                                             sep     #X_FLAG
                                             .longi  off
                                             .endm

                             ; Sets the M & X bits making the accumulator, memory accesses and index
                             ; registers 8-bits wide.

                             short_ai        .macro
                                             sep     #M_FLAG|X_FLAG
                                             .longa  off
                                             .longi  off
                                             .endm

                                             .65816
                                             .CODE
                                             .ORG    $8000

00:8000  58585800          :                 .BYTE   "XXX",0         ; Boot Signature

00:8004  78                :                 SEI                     ; Disable interrupts
00:8005  D8                :                 CLD
00:8006  38                :                 SEC                     ; Return to emulation mode
00:8007  FB                :                 XCE
00:8008  4C2B80            :                 JMP     LAB_COLD        ; And start BASIC

                                             .65C02

                             ; Read a character from the UART if one is available.

                             RDBYTE:
00:800B  AD48DF            :                 LDA     UIFR            ; Any data in the UART buffer?
00:800E  2940              :                 AND     #1<<6
00:8010  18                :                 CLC
00:8011  F004              :                 BEQ     .DONE           ; No
00:8013  AD77DF            :                 LDA     ARTD3           ; Yes, read it
00:8016  38                :                 SEC
00:8017  60                : .DONE           RTS

                             ; Send a character to the UART.

                             WRBYTE:
00:8018  48                :                 PHA
00:8019  AD48DF            : .WAIT           LDA     UIFR            ; Ready to transmit again?
00:801C  2980              :                 AND     #1<<7
00:801E  F0F9              :                 BEQ     .WAIT
00:8020  68                :                 PLA
00:8021  8D77DF            :                 STA     ARTD3           ; Send the character
00:8024  60                :                 RTS

                             ; File Load and Save are not supported

                             SYSLOAD:

Portable 65xx Assembler [20.01]

00:8025  60                :                 RTS

                             SYSSAVE:
00:8026  60                :                 RTS

                             ; Exit from BASIC by using BRK to enter the monitor

                             SYSEXIT:
00:8027  00                :                 BRK
00:8028  EA                :                 NOP
00:8029  80FC              :                 BRA     SYSEXIT

                             ;===============================================================================

                             ; BASIC cold start entry point

                             ; new page $04 initialisation, copy ROM block to RAM
                             ; consists of the vectors Input/Output/Load/Save
                             ; and Control-C flags, pointers

                             LAB_COLD
00:802B  A00E              :                 LDY     #PG2_TABE-PG2_TABS-1 ; byte count-1
                             LAB_2D13
00:802D  B905A0            :                 LDA     PG2_TABS,Y      ; get byte
00:8030  997F04            :                 STA     ccflag,Y        ; store in page 4
00:8033  88                :                 DEY                     ; decrement count
00:8034  10F7              :                 BPL     LAB_2D13        ; loop if not done

00:8036  A2FF              :                 LDX     #$FF            ; set byte
00:8038  863A              :                 STX     Clineh          ; set current line high byte (set immediate mode)
00:803A  9A                :                 TXS                     ; reset stack pointer

00:803B  A94C              :                 LDA     #$4C            ; code for JMP
00:803D  8553              :                 STA     Fnxjmp          ; save for jump vector for functions

                             ; copy block from StrTab to $0000 - $0012

                             LAB_GMEM
00:803F  A20B              :                 LDX     #EndTab-StrTab-1 ; set byte count-1
                             TabLoop
00:8041  BD14A0            :                 LDA     StrTab,X        ; get byte from table
00:8044  9500              :                 STA     PLUS_0,X        ; save byte in page zero
00:8046  CA                :                 DEX                     ; decrement count
00:8047  10F8              :                 BPL     TabLoop         ; loop if not all done

                             ; set-up start values

00:8049  6464              :                 STZ     FAC1_o          ; clear FAC1 overflow byte
00:804B  6419              :                 STZ     last_sh         ; clear descriptor stack top item pointer high byte

00:804D  A90E              :                 LDA     #$0E            ; set default tab size
00:804F  8516              :                 STA     TabSiz          ; save it
00:8051  A903              :                 LDA     #$03            ; set garbage collect step size for descriptor stack
00:8053  8552              :                 STA     g_step          ; save it

Portable 65xx Assembler [20.01]

00:8055  A21A              :                 LDX     #des_sk         ; descriptor stack start
00:8057  8617              :                 STX     next_s          ; set descriptor stack pointer

                             ; bypass user memory prompt, just test, show and go
                             ; we get here with Itempl/h = Ram_base

                             LAB_2D93
00:8059  A900              :                 LDA     #$00            ; get all bits off
00:805B  920A              :                 STA     (Itempl)        ; clear tested memory byte

00:805D  E60A              :                 INC     Itempl          ; increment temporary integer low byte
00:805F  D008              :                 BNE     LAB_2D99        ; branch if no overflow

00:8061  E60B              :                 INC     Itemph          ; increment temporary integer high byte
00:8063  A50B              :                 LDA     Itemph          ; get high byte
00:8065  C980              :                 CMP     #>Ram_top       ; compare with top of RAM+1
00:8067  F00F              :                 BEQ     LAB_2DB6        ; branch if match (end of user RAM)

                             LAB_2D99
00:8069  A955              :                 LDA     #$55            ; set test byte
00:806B  920A              :                 STA     (Itempl)        ; save via temporary integer
00:806D  D20A              :                 CMP     (Itempl)        ; compare via temporary integer
00:806F  D007              :                 BNE     LAB_2DB6        ; branch if fail

00:8071  0A                :                 ASL                     ; shift test byte left (now $AA)
00:8072  920A              :                 STA     (Itempl)        ; save via temporary integer
00:8074  D20A              :                 CMP     (Itempl)        ; compare via temporary integer
00:8076  F0E1              :                 BEQ     LAB_2D93        ; if ok go do next byte

                             LAB_2DB6
00:8078  A50A              :                 LDA     Itempl          ; get temporary integer low byte
00:807A  A40B              :                 LDY     Itemph          ; get temporary integer high byte ($00)

                             MEM_OK
00:807C  8537              :                 STA     Ememl           ; set end of mem low byte
00:807E  8438              :                 STY     Ememh           ; set end of mem high byte
00:8080  8533              :                 STA     Sstorl          ; set bottom of string space low byte
00:8082  8434              :                 STY     Sstorh          ; set bottom of string space high byte

00:8084  A000              :                 LDY     #<Ram_base      ; set start addr low byte
00:8086  A208              :                 LDX     #>Ram_base      ; set start addr high byte
00:8088  842B              :                 STY     Smeml           ; save start of mem low byte
00:808A  862C              :                 STX     Smemh           ; save start of mem high byte

00:808C  98                :                 TYA                     ; clear A ($00)
00:808D  912B              :                 STA     (Smeml),Y       ; clear first byte
00:808F  E62B              :                 INC     Smeml           ; increment start of mem low byte

                             LAB_2E05
00:8091  205F88            :                 JSR     LAB_CRLF        ; print CR/LF
00:8094  204883            :                 JSR     LAB_1463        ; do "NEW" and "CLEAR"
00:8097  A537              :                 LDA     Ememl           ; get end of mem low byte
00:8099  38                :                 SEC                     ; set carry for subtract
00:809A  E52B              :                 SBC     Smeml           ; subtract start of mem low byte

Portable 65xx Assembler [20.01]

00:809C  AA                :                 TAX                     ; copy to X
00:809D  A538              :                 LDA     Ememh           ; get end of mem high byte
00:809F  E52C              :                 SBC     Smemh           ; subtract start of mem high byte
00:80A1  201C9A            :                 JSR     LAB_295E        ; print XA as unsigned integer (bytes free)
00:80A4  A920              :                 LDA     #<LAB_SMSG      ; point to sign-on message (low addr)
00:80A6  A0A0              :                 LDY     #>LAB_SMSG      ; point to sign-on message (high addr)
00:80A8  20A088            :                 JSR     LAB_18C3        ; print null terminated string from memory
00:80AB  A951              :                 LDA     #<LAB_1274      ; warm start vector low byte
00:80AD  A081              :                 LDY     #>LAB_1274      ; warm start vector high byte
00:80AF  8501              :                 STA     Wrmjpl          ; save warm start vector low byte
00:80B1  8402              :                 STY     Wrmjph          ; save warm start vector high byte
00:80B3  6C0100            :                 JMP     (Wrmjpl)        ; go do warm start

                             ; open up space in memory
                             ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)

                             ; Nbendl,Nbendh - new block end address (A/Y)
                             ; Obendl,Obendh - old block end address
                             ; Ostrtl,Ostrth - old block start address

                             ; returns with ..

                             ; Nbendl,Nbendh - new block start address (high byte - $100)
                             ; Obendl,Obendh - old block start address (high byte - $100)
                             ; Ostrtl,Ostrth - old block start address (unchanged)

                             LAB_11CF
00:80B6  200381            :                 JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
                             ; addr to check is in AY (low/high)
00:80B9  8531              :                 STA     Earryl          ; save new array mem end low byte
00:80BB  8432              :                 STY     Earryh          ; save new array mem end high byte

                             ; open up space in memory
                             ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
                             ; don't set array end

                             LAB_11D6
00:80BD  38                :                 SEC                     ; set carry for subtract
00:80BE  A558              :                 LDA     Obendl          ; get block end low byte
00:80C0  E55C              :                 SBC     Ostrtl          ; subtract block start low byte
00:80C2  A8                :                 TAY                     ; copy MOD(block length/$100) byte to Y
00:80C3  A559              :                 LDA     Obendh          ; get block end high byte
00:80C5  E55D              :                 SBC     Ostrth          ; subtract block start high byte
00:80C7  AA                :                 TAX                     ; copy block length high byte to X
00:80C8  E8                :                 INX                     ; +1 to allow for count=0 exit
00:80C9  98                :                 TYA                     ; copy block length low byte to A
00:80CA  F024              :                 BEQ     LAB_120A        ; branch if length low byte=0

                             ; block is (X-1)*256+Y bytes, do the Y bytes first
00:80CC  38                :                 SEC                     ; set carry for add + 1, two's complement
00:80CD  49FF              :                 EOR     #$FF            ; invert low byte for subtract
00:80CF  6558              :                 ADC     Obendl          ; add block end low byte
00:80D1  8558              :                 STA     Obendl          ; save corrected old block end low byte
00:80D3  B003              :                 BCS     LAB_11F3        ; branch if no underflow

Portable 65xx Assembler [20.01]

00:80D5  C659              :                 DEC     Obendh          ; else decrement block end high byte
00:80D7  38                :                 SEC                     ; set carry for add + 1, two's complement
                             LAB_11F3
00:80D8  98                :                 TYA                     ; get MOD(block length/$100) byte
00:80D9  49FF              :                 EOR     #$FF            ; invert low byte for subtract
00:80DB  6556              :                 ADC     Nbendl          ; add destination end low byte
00:80DD  8556              :                 STA     Nbendl          ; save modified new block end low byte
00:80DF  B008              :                 BCS     LAB_1203        ; branch if no underflow
00:80E1  C657              :                 DEC     Nbendh          ; else decrement block end high byte
00:80E3  8004              :                 BRA     LAB_1203        ; branch always

                             LAB_11FF
00:80E5  B158              :                 LDA     (Obendl),Y      ; get byte from source
00:80E7  9156              :                 STA     (Nbendl),Y      ; copy byte to destination
                             LAB_1203
00:80E9  88                :                 DEY                     ; decrement index
00:80EA  D0F9              :                 BNE     LAB_11FF        ; loop until Y=0
                             ; now do Y=0 indexed byte
00:80EC  B158              :                 LDA     (Obendl),Y      ; get byte from source
00:80EE  9156              :                 STA     (Nbendl),Y      ; save byte to destination
                             LAB_120A
00:80F0  C659              :                 DEC     Obendh          ; decrement source pointer high byte
00:80F2  C657              :                 DEC     Nbendh          ; decrement destination pointer high byte
00:80F4  CA                :                 DEX                     ; decrement block count
00:80F5  D0F2              :                 BNE     LAB_1203        ; loop until count = $0
00:80F7  60                :                 RTS

                             ; check room on stack for A bytes
                             ; stack too deep? do OM error

                             LAB_1212                                ; patched for stack floor
00:80F8  18                :                 CLC                     ; prep ADC
00:80F9  6920              :                 ADC     #STACK_RES      ; stack pointer lower limit before interrupts
00:80FB  852A              :                 STA     TempB           ; save result in temp byte
00:80FD  BA                :                 TSX                     ; copy stack
00:80FE  E42A              :                 CPX     TempB           ; compare new "limit" with stack
00:8100  902F              :                 BCC     LAB_OMER        ; if stack < limit do "Out of memory" error then warm start
00:8102  60                :                 RTS

                             ; check available memory, "Out of memory" error if no room
                             ; addr to check is in AY (low/high)

                             LAB_121F
00:8103  C434              :                 CPY     Sstorh          ; compare bottom of string mem high byte
00:8105  9029              :                 BCC     LAB_124B        ; if less then exit (is ok)

00:8107  D004              :                 BNE     LAB_1229        ; skip next test if greater (tested <)

                             ; high byte was =, now do low byte
00:8109  C533              :                 CMP     Sstorl          ; compare with bottom of string mem low byte
00:810B  9023              :                 BCC     LAB_124B        ; if less then exit (is ok)

                             ; addr is > string storage ptr (oops!)
                             LAB_1229

Portable 65xx Assembler [20.01]

00:810D  48                :                 PHA                     ; push addr low byte
00:810E  A208              :                 LDX     #$08            ; set index to save Adatal to expneg inclusive
00:8110  98                :                 TYA                     ; copy addr high byte (to push on stack)

                             ; save misc numeric work area
                             LAB_122D
00:8111  48                :                 PHA                     ; push byte
00:8112  B555              :                 LDA     Adatal-1,X      ; get byte from Adatal to expneg ( ,$00 not pushed)
00:8114  CA                :                 DEX                     ; decrement index
00:8115  10FA              :                 BPL     LAB_122D        ; loop until all done

00:8117  209B91            :                 JSR     LAB_GARB        ; garbage collection routine

                             ; restore misc numeric work area
00:811A  A200              :                 LDX     #$00            ; clear the index to restore bytes
                             LAB_1238
00:811C  68                :                 PLA                     ; pop byte
00:811D  9556              :                 STA     Adatal,X        ; save byte to Adatal to expneg
00:811F  E8                :                 INX                     ; increment index
00:8120  E008              :                 CPX     #$08            ; compare with end + 1
00:8122  30F8              :                 BMI     LAB_1238        ; loop if more to do

00:8124  7A                :                 PLY                     ; pop addr high byte
00:8125  68                :                 PLA                     ; pop addr low byte
00:8126  C434              :                 CPY     Sstorh          ; compare bottom of string mem high byte
00:8128  9006              :                 BCC     LAB_124B        ; if less then exit (is ok)

00:812A  D005              :                 BNE     LAB_OMER        ; if greater do "Out of memory" error then warm start

                             ; high byte was =, now do low byte
00:812C  C533              :                 CMP     Sstorl          ; compare with bottom of string mem low byte
00:812E  B001              :                 BCS     LAB_OMER        ; if >= do "Out of memory" error then warm start
                             ; ok exit, carry clear
                             LAB_124B
00:8130  60                :                 RTS

                             ; do "Out of memory" error then warm start

                             LAB_OMER
00:8131  A20C              :                 LDX     #$0C            ; error code $0C ("Out of memory" error)

                             ; do error #X, then warm start

                             LAB_XERR
00:8133  205F88            :                 JSR     LAB_CRLF        ; print CR/LF

00:8136  BD53A5            :                 LDA     LAB_BAER,X      ; get error message pointer low byte
00:8139  BC54A5            :                 LDY     LAB_BAER+1,X    ; get error message pointer high byte
00:813C  20A088            :                 JSR     LAB_18C3        ; print null terminated string from memory

00:813F  208183            :                 JSR     LAB_1491        ; flush stack and clear continue flag
00:8142  A990              :                 LDA     #<LAB_EMSG      ; point to " Error" low addr
00:8144  A0A6              :                 LDY     #>LAB_EMSG      ; point to " Error" high addr
                             LAB_1269

Portable 65xx Assembler [20.01]

00:8146  20A088            :                 JSR     LAB_18C3        ; print null terminated string from memory
00:8149  A43A              :                 LDY     Clineh          ; get current line high byte
00:814B  C8                :                 INY                     ; increment it
00:814C  F003              :                 BEQ     LAB_1274        ; go do warm start (was immediate mode)

                             ; else print line number
00:814E  20119A            :                 JSR     LAB_2953        ; print " in line [LINE #]"

                             ; BASIC warm start entry point
                             ; wait for Basic command

                             LAB_1274
00:8151  A9A1              :                 LDA     #<LAB_RMSG      ; point to "Ready" message low byte
00:8153  A0A6              :                 LDY     #>LAB_RMSG      ; point to "Ready" message high byte

00:8155  20A088            :                 JSR     LAB_18C3        ; go do print string

                             ; wait for Basic command (no "Ready")

                             LAB_127D
00:8158  203F82            :                 JSR     LAB_1357        ; call for BASIC input
                             LAB_1280
00:815B  866E              :                 STX     Bpntrl          ; set BASIC execute pointer low byte
00:815D  846F              :                 STY     Bpntrh          ; set BASIC execute pointer high byte
00:815F  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:8162  F0F4              :                 BEQ     LAB_127D        ; loop while null

                             ; got to interpret input line now ..

00:8164  A2FF              :                 LDX     #$FF            ; current line to null value
00:8166  863A              :                 STX     Clineh          ; set current line high byte
00:8168  9006              :                 BCC     LAB_1295        ; branch if numeric character (handle new BASIC line)

                             ; no line number .. immediate mode
00:816A  207082            :                 JSR     LAB_13A6        ; crunch keywords into Basic tokens
00:816D  4CE484            :                 JMP     LAB_15F6        ; go scan and interpret code

                             ; handle new BASIC line

                             LAB_1295
00:8170  202B87            :                 JSR     LAB_GFPN        ; get fixed-point number into temp integer
00:8173  207082            :                 JSR     LAB_13A6        ; crunch keywords into Basic tokens
00:8176  840F              :                 STY     Ibptr           ; save index pointer to end of crunched line
00:8178  201C83            :                 JSR     LAB_SSLN        ; search BASIC for temp integer line number
00:817B  9044              :                 BCC     LAB_12E6        ; branch if not found

                             ; aroooogah! line # already exists! delete it
00:817D  A001              :                 LDY     #$01            ; set index to next line pointer high byte
00:817F  B15C              :                 LDA     (Baslnl),Y      ; get next line pointer high byte
00:8181  8524              :                 STA     ut1_ph          ; save it
00:8183  A52D              :                 LDA     Svarl           ; get start of vars low byte
00:8185  8523              :                 STA     ut1_pl          ; save it
00:8187  A55D              :                 LDA     Baslnh          ; get found line pointer high byte
00:8189  8526              :                 STA     ut2_ph          ; save it

Portable 65xx Assembler [20.01]

00:818B  A55C              :                 LDA     Baslnl          ; get found line pointer low byte
00:818D  88                :                 DEY                     ; decrement index
00:818E  F15C              :                 SBC     (Baslnl),Y      ; subtract next line pointer low byte
00:8190  18                :                 CLC                     ; clear carry for add
00:8191  652D              :                 ADC     Svarl           ; add start of vars low byte
00:8193  852D              :                 STA     Svarl           ; save new start of vars low byte
00:8195  8525              :                 STA     ut2_pl          ; save destination pointer low byte
00:8197  A52E              :                 LDA     Svarh           ; get start of vars high byte
00:8199  69FF              :                 ADC     #$FF            ; -1 + carry
00:819B  852E              :                 STA     Svarh           ; save start of vars high byte
00:819D  E55D              :                 SBC     Baslnh          ; subtract found line pointer high byte
00:819F  AA                :                 TAX                     ; copy to block count
00:81A0  38                :                 SEC                     ; set carry for subtract
00:81A1  A55C              :                 LDA     Baslnl          ; get found line pointer low byte
00:81A3  E52D              :                 SBC     Svarl           ; subtract start of vars low byte
00:81A5  A8                :                 TAY                     ; copy to bytes in first block count
00:81A6  B003              :                 BCS     LAB_12D0        ; branch if overflow

00:81A8  E8                :                 INX                     ; increment block count (correct for =0 loop exit)
00:81A9  C626              :                 DEC     ut2_ph          ; decrement destination high byte
                             LAB_12D0
00:81AB  18                :                 CLC                     ; clear carry for add
00:81AC  6523              :                 ADC     ut1_pl          ; add source pointer low byte
00:81AE  9003              :                 BCC     LAB_12D8        ; branch if no overflow

00:81B0  C624              :                 DEC     ut1_ph          ; else decrement source pointer high byte
00:81B2  18                :                 CLC                     ; clear carry

                             ; close up memory to delete old line
                             LAB_12D8
00:81B3  B123              :                 LDA     (ut1_pl),Y      ; get byte from source
00:81B5  9125              :                 STA     (ut2_pl),Y      ; copy to destination
00:81B7  C8                :                 INY                     ; increment index
00:81B8  D0F9              :                 BNE     LAB_12D8        ; while <> 0 do this block

00:81BA  E624              :                 INC     ut1_ph          ; increment source pointer high byte
00:81BC  E626              :                 INC     ut2_ph          ; increment destination pointer high byte
00:81BE  CA                :                 DEX                     ; decrement block count
00:81BF  D0F2              :                 BNE     LAB_12D8        ; loop until all done

                             ; got new line in buffer and no existing same #
                             LAB_12E6
00:81C1  AD0004            :                 LDA     Ibuffs          ; get byte from start of input buffer
00:81C4  F03F              :                 BEQ     LAB_1319        ; if null line just go flush stack/vars and exit

                             ; got new line and it isn't empty line
00:81C6  A537              :                 LDA     Ememl           ; get end of mem low byte
00:81C8  A438              :                 LDY     Ememh           ; get end of mem high byte
00:81CA  8533              :                 STA     Sstorl          ; set bottom of string space low byte
00:81CC  8434              :                 STY     Sstorh          ; set bottom of string space high byte
00:81CE  A52D              :                 LDA     Svarl           ; get start of vars low byte  (end of BASIC)
00:81D0  8558              :                 STA     Obendl          ; save old block end low byte
00:81D2  A42E              :                 LDY     Svarh           ; get start of vars high byte (end of BASIC)
00:81D4  8459              :                 STY     Obendh          ; save old block end high byte

Portable 65xx Assembler [20.01]

00:81D6  650F              :                 ADC     Ibptr           ; add input buffer pointer    (also buffer length)
00:81D8  9001              :                 BCC     LAB_1301        ; branch if no overflow from add
00:81DA  C8                :                 INY                     ; else increment high byte
                             LAB_1301
00:81DB  8556              :                 STA     Nbendl          ; save new block end low byte (move to, low byte)
00:81DD  8457              :                 STY     Nbendh          ; save new block end high byte
00:81DF  20B680            :                 JSR     LAB_11CF        ; open up space in memory
                             ; old start pointer Ostrtl,Ostrth set by the find line call
00:81E2  A531              :                 LDA     Earryl          ; get array mem end low byte
00:81E4  A432              :                 LDY     Earryh          ; get array mem end high byte
00:81E6  852D              :                 STA     Svarl           ; save start of vars low byte
00:81E8  842E              :                 STY     Svarh           ; save start of vars high byte
00:81EA  A40F              :                 LDY     Ibptr           ; get input buffer pointer    (also buffer length)
00:81EC  88                :                 DEY                     ; adjust for loop type
                             LAB_1311
00:81ED  B9FC03            :                 LDA     Ibuffs-4,Y      ; get byte from crunched line
00:81F0  915C              :                 STA     (Baslnl),Y      ; save it to program memory
00:81F2  88                :                 DEY                     ; decrement count
00:81F3  C003              :                 CPY     #$03            ; compare with first byte-1
00:81F5  D0F6              :                 BNE     LAB_1311        ; continue while count <> 3

00:81F7  A50B              :                 LDA     Itemph          ; get line # high byte
00:81F9  915C              :                 STA     (Baslnl),Y      ; save it to program memory
00:81FB  88                :                 DEY                     ; decrement count
00:81FC  A50A              :                 LDA     Itempl          ; get line # low byte
00:81FE  915C              :                 STA     (Baslnl),Y      ; save it to program memory
00:8200  88                :                 DEY                     ; decrement count
00:8201  A9FF              :                 LDA     #$FF            ; set byte to allow chain rebuild. if you didn't set this
                             ; byte then a zero already here would stop the chain rebuild
                             ; as it would think it was the [EOT] marker.
00:8203  915C              :                 STA     (Baslnl),Y      ; save it to program memory

                             LAB_1319
00:8205  205D83            :                 JSR     LAB_1477        ; reset execution to start, clear vars and flush stack
00:8208  A62B              :                 LDX     Smeml           ; get start of mem low byte
00:820A  A52C              :                 LDA     Smemh           ; get start of mem high byte
00:820C  A001              :                 LDY     #$01            ; index to high byte of next line pointer
                             LAB_1325
00:820E  8623              :                 STX     ut1_pl          ; set line start pointer low byte
00:8210  8524              :                 STA     ut1_ph          ; set line start pointer high byte
00:8212  B123              :                 LDA     (ut1_pl),Y      ; get it
00:8214  F018              :                 BEQ     LAB_133E        ; exit if end of program

                             ; rebuild chaining of Basic lines

00:8216  A004              :                 LDY     #$04            ; point to first code byte of line
                             ; there is always 1 byte + [EOL] as null entries are deleted
                             LAB_1330
00:8218  C8                :                 INY                     ; next code byte
00:8219  B123              :                 LDA     (ut1_pl),Y      ; get byte
00:821B  D0FB              :                 BNE     LAB_1330        ; loop if not [EOL]

00:821D  38                :                 SEC                     ; set carry for add + 1
00:821E  98                :                 TYA                     ; copy end index

Portable 65xx Assembler [20.01]

00:821F  6523              :                 ADC     ut1_pl          ; add to line start pointer low byte
00:8221  AA                :                 TAX                     ; copy to X
00:8222  A000              :                 LDY     #$00            ; clear index, point to this line's next line pointer
00:8224  9123              :                 STA     (ut1_pl),Y      ; set next line pointer low byte
00:8226  98                :                 TYA                     ; clear A
00:8227  6524              :                 ADC     ut1_ph          ; add line start pointer high byte + carry
00:8229  C8                :                 INY                     ; increment index to high byte
00:822A  9123              :                 STA     (ut1_pl),Y      ; save next line pointer low byte
00:822C  80E0              :                 BRA     LAB_1325        ; go do next line, branch always, carry clear

                             LAB_133E
00:822E  4C5881            :                 JMP     LAB_127D        ; else we just wait for Basic command, no "Ready"

                             ; print "? " and get BASIC input

                             LAB_INLN
00:8231  20B988            :                 JSR     LAB_18E3        ; print "?" character
00:8234  20B588            :                 JSR     LAB_18E0        ; print " "
00:8237  D006              :                 BNE     LAB_1357        ; call for BASIC input and return

                             ; receive line from keyboard

                             ; $08 as delete key (BACKSPACE on standard keyboard)
                             LAB_134B
00:8239  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:823C  CA                :                 DEX                     ; decrement the buffer counter (delete)
00:823D  8002              :                 BRA     LAB_1359        ; branch over next instruction, save 1 clock cycle

                             ; call for BASIC input (main entry point)

                             LAB_1357
00:823F  A200              :                 LDX     #$00            ; clear BASIC line buffer pointer
                             LAB_1359
00:8241  20F69F            :                 JSR     V_INPT          ; call scan input device
00:8244  90FB              :                 BCC     LAB_1359        ; loop if no byte

00:8246  F0F9              :                 BEQ     LAB_1359        ; loop until valid input (ignore NULLs)

00:8248  C907              :                 CMP     #$07            ; compare with [BELL]
00:824A  F010              :                 BEQ     LAB_1378        ; branch if [BELL]

00:824C  C90D              :                 CMP     #$0D            ; compare with [CR]
00:824E  F019              :                 BEQ     LAB_1384        ; do CR/LF exit if [CR]

00:8250  E000              :                 CPX     #$00            ; compare pointer with $00
00:8252  D004              :                 BNE     LAB_1374        ; branch if not empty

                             ; next two lines ignore any non print character and [SPACE] if input buffer empty

00:8254  C921              :                 CMP     #$21            ; compare with [SP]+1
00:8256  90E9              :                 BCC     LAB_1359        ; if < ignore character

                             LAB_1374
00:8258  C908              :                 CMP     #$08            ; compare with [BACKSPACE] (delete last character)

Portable 65xx Assembler [20.01]

00:825A  F0DD              :                 BEQ     LAB_134B        ; go delete last character

                             LAB_1378
00:825C  E07E              :                 CPX     #Ibuffe-Ibuffs  ; compare character count with max
00:825E  B00C              :                 BCS     LAB_138E        ; skip store and do [BELL] if buffer full

00:8260  9D0004            :                 STA     Ibuffs,X        ; else store in buffer
00:8263  E8                :                 INX                     ; increment pointer
                             LAB_137F
00:8264  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:8267  80D8              :                 BRA     LAB_1359        ; always loop for next character

                             LAB_1384
00:8269  4C5888            :                 JMP     LAB_1866        ; do CR/LF exit to BASIC

                             ; announce buffer full

                             LAB_138E
00:826C  A907              :                 LDA     #$07            ; [BELL] character into A
00:826E  80F4              :                 BRA     LAB_137F        ; go print the [BELL] but ignore input character
                             ; branch always

                             ; crunch keywords into Basic tokens
                             ; position independent buffer version ..
                             ; faster, dictionary search version ....

                             LAB_13A6
00:8270  A0FF              :                 LDY     #$FF            ; set save index (makes for easy math later)
00:8272  38                :                 SEC                     ; set carry for subtract
00:8273  A56E              :                 LDA     Bpntrl          ; get basic execute pointer low byte
00:8275  E900              :                 SBC     #<Ibuffs        ; subtract input buffer start pointer
00:8277  AA                :                 TAX                     ; copy result to X (index past line # if any)
00:8278  8612              :                 STX     Oquote          ; clear open quote/DATA flag
                             LAB_13AC
00:827A  BD0004            :                 LDA     Ibuffs,X        ; get byte from input buffer
00:827D  F051              :                 BEQ     LAB_13EC        ; if null save byte then exit

00:827F  C95F              :                 CMP     #'_'            ; compare with "_"
00:8281  B04D              :                 BCS     LAB_13EC        ; if >= go save byte then continue crunching

00:8283  C93C              :                 CMP     #'<'            ; compare with "<"
00:8285  B00E              :                 BCS     LAB_13CC        ; if >= go crunch now

00:8287  C930              :                 CMP     #'0'            ; compare with "0"
00:8289  B045              :                 BCS     LAB_13EC        ; if >= go save byte then continue crunching

00:828B  850E              :                 STA     Scnquo          ; save buffer byte as search character
00:828D  C922              :                 CMP     #$22            ; is it quote character?
00:828F  F061              :                 BEQ     LAB_1410        ; branch if so (copy quoted string)

00:8291  C92A              :                 CMP     #'*'            ; compare with "*"
00:8293  903B              :                 BCC     LAB_13EC        ; if < go save byte then continue crunching
                             ; else crunch now
                             LAB_13CC

Portable 65xx Assembler [20.01]

00:8295  2412              :                 BIT     Oquote          ; get open quote/DATA token flag
00:8297  7037              :                 BVS     LAB_13EC        ; branch if b6 of Oquote set (was DATA)
                             ; go save byte then continue crunching
00:8299  862A              :                 STX     TempB           ; save buffer read index
00:829B  846C              :                 STY     csidx           ; copy buffer save index
00:829D  A0DB              :                 LDY     #<TAB_1STC      ; get keyword first character table low address
00:829F  8425              :                 STY     ut2_pl          ; save pointer low byte
00:82A1  A0A1              :                 LDY     #>TAB_1STC      ; get keyword first character table high address
00:82A3  8426              :                 STY     ut2_ph          ; save pointer high byte
00:82A5  A000              :                 LDY     #$00            ; clear table pointer

                             LAB_13D0
00:82A7  D125              :                 CMP     (ut2_pl),Y      ; compare with keyword first character table byte
00:82A9  F005              :                 BEQ     LAB_13D1        ; go do word_table_chr if match

00:82AB  9021              :                 BCC     LAB_13EA        ; if < keyword first character table byte go restore
                             ; Y and save to crunched

00:82AD  C8                :                 INY                     ; else increment pointer
00:82AE  80F7              :                 BRA     LAB_13D0        ; and loop (branch always)

                             ; have matched first character of some keyword

                             LAB_13D1
00:82B0  98                :                 TYA                     ; copy matching index
00:82B1  0A                :                 ASL                     ; *2 (bytes per pointer)
00:82B2  AA                :                 TAX                     ; copy to new index
00:82B3  BDF9A1            :                 LDA     TAB_CHRT,X      ; get keyword table pointer low byte
00:82B6  8525              :                 STA     ut2_pl          ; save pointer low byte
00:82B8  BDFAA1            :                 LDA     TAB_CHRT+1,X    ; get keyword table pointer high byte
00:82BB  8526              :                 STA     ut2_ph          ; save pointer high byte
00:82BD  A0FF              :                 LDY     #$FF            ; clear table pointer (make -1 for start)
00:82BF  A62A              :                 LDX     TempB           ; restore buffer read index

                             LAB_13D6
00:82C1  C8                :                 INY                     ; next table byte
00:82C2  B125              :                 LDA     (ut2_pl),Y      ; get byte from table
                             LAB_13D8
00:82C4  3008              :                 BMI     LAB_13EA        ; all bytes matched so go save token
00:82C6  E8                :                 INX                     ; next buffer byte
00:82C7  DD0004            :                 CMP     Ibuffs,X        ; compare with byte from input buffer
00:82CA  F0F5              :                 BEQ     LAB_13D6        ; go compare next if match
00:82CC  D02B              :                 BNE     LAB_1417        ; branch if >< (not found keyword)

                             LAB_13EA
00:82CE  A46C              :                 LDY     csidx           ; restore save index
                             ; save crunched to output
                             LAB_13EC
00:82D0  E8                :                 INX                     ; increment buffer index (to next input byte)
00:82D1  C8                :                 INY                     ; increment save index (to next output byte)
00:82D2  990004            :                 STA     Ibuffs,Y        ; save byte to output
00:82D5  C900              :                 CMP     #$00            ; set the flags, set carry
00:82D7  F032              :                 BEQ     LAB_142A        ; do exit if was null [EOL]


Portable 65xx Assembler [20.01]

                             ; A holds token or byte here
00:82D9  E93A              :                 SBC     #':'            ; subtract ":" (carry set by CMP #00)
00:82DB  F004              :                 BEQ     LAB_13FF        ; branch if it was ":" (is now $00)

                             ; A now holds token-$3A
00:82DD  C949              :                 CMP     #TK_DATA-$3A    ; compare with DATA token - $3A
00:82DF  D002              :                 BNE     LAB_1401        ; branch if not DATA

                             ; token was : or DATA
                             LAB_13FF
00:82E1  8512              :                 STA     Oquote          ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
                             LAB_1401
00:82E3  4955              :                 EOR     #TK_REM-$3A     ; effectively subtract REM token offset
00:82E5  D093              :                 BNE     LAB_13AC        ; If wasn't REM then go crunch rest of line
00:82E7  850E              :                 STA     Asrch           ; else was REM so set search for [EOL]
                             ; loop for REM, "..." etc.
                             LAB_1408
00:82E9  BD0004            :                 LDA     Ibuffs,X        ; get byte from input buffer
00:82EC  F0E2              :                 BEQ     LAB_13EC        ; branch if null [EOL]
00:82EE  C50E              :                 CMP     Asrch           ; compare with stored character
00:82F0  F0DE              :                 BEQ     LAB_13EC        ; branch if match (end quote)
                             ; entry for copy string in quotes, don't crunch
                             LAB_1410
00:82F2  C8                :                 INY                     ; increment buffer save index
00:82F3  990004            :                 STA     Ibuffs,Y        ; save byte to output
00:82F6  E8                :                 INX                     ; increment buffer read index
00:82F7  D0F0              :                 BNE     LAB_1408        ; loop while <> 0 (should never be 0!)
                             ; not found keyword this go
                             LAB_1417
00:82F9  A62A              :                 LDX     TempB           ; compare has failed, restore buffer index (start byte!)

                             ; now find the end of this word in the table
                             LAB_141B
00:82FB  B125              :                 LDA     (ut2_pl),Y      ; get table byte
00:82FD  08                :                 PHP                     ; save status
00:82FE  C8                :                 INY                     ; increment table index
00:82FF  28                :                 PLP                     ; restore byte status
00:8300  10F9              :                 BPL     LAB_141B        ; if not end of keyword go do next

00:8302  B125              :                 LDA     (ut2_pl),Y      ; get byte from keyword table
00:8304  D0BE              :                 BNE     LAB_13D8        ; go test next word if not zero byte (end of table)

                             ; reached end of table with no match
00:8306  BD0004            :                 LDA     Ibuffs,X        ; restore byte from input buffer
00:8309  80C3              :                 BRA     LAB_13EA        ; branch always (all bytes in buffer are $00-$7F)
                             ; go save byte in output and continue crunching
                             ; reached [EOL]
                             LAB_142A
00:830B  C8                :                 INY                     ; increment pointer
00:830C  C8                :                 INY                     ; increment pointer (makes it next line pointer high byte)
00:830D  990004            :                 STA     Ibuffs,Y        ; save [EOL] (marks [EOT] in immediate mode)
00:8310  C8                :                 INY                     ; adjust for line copy
00:8311  C8                :                 INY                     ; adjust for line copy
00:8312  C8                :                 INY                     ; adjust for line copy

Portable 65xx Assembler [20.01]

00:8313  A56E              :                 LDA     Bpntrl          ; test for $00
00:8315  D002              :                 BNE     LAB_142P        ; not $00
00:8317  C66F              :                 DEC     Bpntrh          ; allow for increment when $xx00
                             LAB_142P
00:8319  C66E              :                 DEC     Bpntrl          ; allow for increment
00:831B  60                :                 RTS

                             ; search Basic for temp integer line number from start of mem

                             LAB_SSLN
00:831C  A52B              :                 LDA     Smeml           ; get start of mem low byte
00:831E  A62C              :                 LDX     Smemh           ; get start of mem high byte

                             ; search Basic for temp integer line number from AX
                             ; returns carry set if found
                             ; returns Baslnl/Baslnh pointer to found or next higher (not found) line

                             LAB_SHLN
00:8320  A001              :                 LDY     #$01            ; set index
00:8322  855C              :                 STA     Baslnl          ; save low byte as current
00:8324  865D              :                 STX     Baslnh          ; save high byte as current
00:8326  B15C              :                 LDA     (Baslnl),Y      ; get pointer high byte from addr
00:8328  F01A              :                 BEQ     LAB_145F        ; pointer was zero so we're done, do 'not found' exit

00:832A  A003              :                 LDY     #$03            ; set index to line # high byte
00:832C  B15C              :                 LDA     (Baslnl),Y      ; get line # high byte
00:832E  88                :                 DEY                     ; decrement index (point to low byte)
00:832F  C50B              :                 CMP     Itemph          ; compare with temporary integer high byte
00:8331  D004              :                 BNE     LAB_1455        ; if <> skip low byte check

00:8333  B15C              :                 LDA     (Baslnl),Y      ; get line # low byte
00:8335  C50A              :                 CMP     Itempl          ; compare with temporary integer low byte
                             LAB_1455
00:8337  B009              :                 BCS     LAB_145E        ; else if temp < this line, exit (passed line#)

                             LAB_1456
00:8339  88                :                 DEY                     ; decrement index to next line ptr high byte
00:833A  B15C              :                 LDA     (Baslnl),Y      ; get next line pointer high byte
00:833C  AA                :                 TAX                     ; copy to X
00:833D  88                :                 DEY                     ; decrement index to next line ptr low byte
00:833E  B15C              :                 LDA     (Baslnl),Y      ; get next line pointer low byte
00:8340  80DE              :                 BRA     LAB_SHLN        ; go search for line # in temp (Itempl/Itemph) from AX
                             ; (carry always clear)

                             LAB_145E
00:8342  F001              :                 BEQ     LAB_1460        ; exit if temp = found line #, carry is set

                             LAB_145F
00:8344  18                :                 CLC                     ; clear found flag
                             LAB_1460
00:8345  60                :                 RTS

                             ; perform NEW


Portable 65xx Assembler [20.01]

                             LAB_NEW
00:8346  D0FD              :                 BNE     LAB_1460        ; exit if not end of statement (to do syntax error)

                             LAB_1463
00:8348  A900              :                 LDA     #$00            ; clear A
00:834A  A8                :                 TAY                     ; clear Y
00:834B  912B              :                 STA     (Smeml),Y       ; clear first line, next line pointer, low byte
00:834D  C8                :                 INY                     ; increment index
00:834E  912B              :                 STA     (Smeml),Y       ; clear first line, next line pointer, high byte
00:8350  18                :                 CLC                     ; clear carry
00:8351  A52B              :                 LDA     Smeml           ; get start of mem low byte
00:8353  6902              :                 ADC     #$02            ; calculate end of BASIC low byte
00:8355  852D              :                 STA     Svarl           ; save start of vars low byte
00:8357  A52C              :                 LDA     Smemh           ; get start of mem high byte
00:8359  6900              :                 ADC     #$00            ; add any carry
00:835B  852E              :                 STA     Svarh           ; save start of vars high byte

                             ; reset execution to start, clear vars and flush stack

                             LAB_1477
00:835D  18                :                 CLC                     ; clear carry
00:835E  A52B              :                 LDA     Smeml           ; get start of mem low byte
00:8360  69FF              :                 ADC     #$FF            ; -1
00:8362  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:8364  A52C              :                 LDA     Smemh           ; get start of mem high byte
00:8366  69FF              :                 ADC     #$FF            ; -1+carry
00:8368  856F              :                 STA     Bpntrh          ; save BASIC execute pointer high byte

                             ; "CLEAR" command gets here

                             LAB_147A
00:836A  A537              :                 LDA     Ememl           ; get end of mem low byte
00:836C  A438              :                 LDY     Ememh           ; get end of mem high byte
00:836E  8533              :                 STA     Sstorl          ; set bottom of string space low byte
00:8370  8434              :                 STY     Sstorh          ; set bottom of string space high byte
00:8372  A52D              :                 LDA     Svarl           ; get start of vars low byte
00:8374  A42E              :                 LDY     Svarh           ; get start of vars high byte
00:8376  852F              :                 STA     Sarryl          ; save var mem end low byte
00:8378  8430              :                 STY     Sarryh          ; save var mem end high byte
00:837A  8531              :                 STA     Earryl          ; save array mem end low byte
00:837C  8432              :                 STY     Earryh          ; save array mem end high byte
00:837E  202E85            :                 JSR     LAB_161A        ; perform RESTORE command

                             ; flush stack and clear continue flag

                             LAB_1491
00:8381  A21A              :                 LDX     #des_sk         ; set descriptor stack pointer
00:8383  8617              :                 STX     next_s          ; save descriptor stack pointer
00:8385  FA                :                 PLX                     ; pull return address low byte
00:8386  68                :                 PLA                     ; pull return address high byte
00:8387  8EFE01            :                 STX     LAB_SKFE        ; save to cleared stack
00:838A  8DFF01            :                 STA     LAB_SKFF        ; save to cleared stack
00:838D  A2FD              :                 LDX     #$FD            ; new stack pointer
00:838F  9A                :                 TXS                     ; reset stack

Portable 65xx Assembler [20.01]

00:8390  A900              :                 LDA     #$00            ; clear byte
00:8392  8513              :                 STA     Sufnxf          ; clear subscript/FNX flag
                             LAB_14A6
00:8394  60                :                 RTS

                             ; perform CLEAR

                             LAB_CLEAR
00:8395  F0D3              :                 BEQ     LAB_147A        ; if no following token go do "CLEAR"
                             ; else there was a following token (go do syntax error)
00:8397  60                :                 RTS

                             ; perform LIST [n][-m]
                             ; bigger, faster version (a _lot_ faster)

                             LAB_LIST
00:8398  9006              :                 BCC     LAB_14BD        ; branch if next character numeric (LIST n..)

00:839A  F004              :                 BEQ     LAB_14BD        ; branch if next character [NULL] (LIST)

00:839C  C9B3              :                 CMP     #TK_MINUS       ; compare with token for -
00:839E  D0F4              :                 BNE     LAB_14A6        ; exit if not - (LIST -m)

                             ; LIST [[n][-m]]
                             ; this bit sets the n , if present, as the start and end
                             LAB_14BD
00:83A0  202B87            :                 JSR     LAB_GFPN        ; get fixed-point number into temp integer
00:83A3  201C83            :                 JSR     LAB_SSLN        ; search BASIC for temp integer line number
                             ; (pointer in Baslnl/Baslnh)
00:83A6  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:83A9  F00C              :                 BEQ     LAB_14D4        ; branch if no more characters

                             ; this bit checks the - is present
00:83AB  C9B3              :                 CMP     #TK_MINUS       ; compare with token for -
00:83AD  D096              :                 BNE     LAB_1460        ; return if not "-" (will be Syntax error)

                             ; LIST [n]-m
                             ; the - was there so set m as the end value
00:83AF  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:83B2  202B87            :                 JSR     LAB_GFPN        ; get fixed-point number into temp integer
00:83B5  D08E              :                 BNE     LAB_1460        ; exit if not ok

                             LAB_14D4
00:83B7  A50A              :                 LDA     Itempl          ; get temporary integer low byte
00:83B9  050B              :                 ORA     Itemph          ; OR temporary integer high byte
00:83BB  D006              :                 BNE     LAB_14E2        ; branch if start set

00:83BD  A9FF              :                 LDA     #$FF            ; set for -1
00:83BF  850A              :                 STA     Itempl          ; set temporary integer low byte
00:83C1  850B              :                 STA     Itemph          ; set temporary integer high byte
                             LAB_14E2
00:83C3  A001              :                 LDY     #$01            ; set index for line
00:83C5  8412              :                 STY     Oquote          ; clear open quote flag
00:83C7  205F88            :                 JSR     LAB_CRLF        ; print CR/LF

Portable 65xx Assembler [20.01]

00:83CA  B15C              :                 LDA     (Baslnl),Y      ; get next line pointer high byte
                             ; pointer initially set by search at LAB_14BD
00:83CC  F03E              :                 BEQ     LAB_152B        ; if null all done so exit
00:83CE  200485            :                 JSR     LAB_1629        ; do CRTL-C check vector

00:83D1  C8                :                 INY                     ; increment index for line
00:83D2  B15C              :                 LDA     (Baslnl),Y      ; get line # low byte
00:83D4  AA                :                 TAX                     ; copy to X
00:83D5  C8                :                 INY                     ; increment index
00:83D6  B15C              :                 LDA     (Baslnl),Y      ; get line # high byte
00:83D8  C50B              :                 CMP     Itemph          ; compare with temporary integer high byte
00:83DA  D004              :                 BNE     LAB_14FF        ; branch if no high byte match

00:83DC  E40A              :                 CPX     Itempl          ; compare with temporary integer low byte
00:83DE  F002              :                 BEQ     LAB_1501        ; branch if = last line to do (< will pass next branch)

                             LAB_14FF                                ; else ..
00:83E0  B02A              :                 BCS     LAB_152B        ; if greater all done so exit

                             LAB_1501
00:83E2  8449              :                 STY     Tidx1           ; save index for line
00:83E4  201C9A            :                 JSR     LAB_295E        ; print XA as unsigned integer
00:83E7  A920              :                 LDA     #$20            ; space is the next character
                             LAB_1508
00:83E9  A449              :                 LDY     Tidx1           ; get index for line
00:83EB  297F              :                 AND     #$7F            ; mask top out bit of character
                             LAB_150C
00:83ED  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:83F0  C922              :                 CMP     #$22            ; was it " character
00:83F2  D006              :                 BNE     LAB_1519        ; branch if not
                             ; we are either entering or leaving a pair of quotes
00:83F4  A512              :                 LDA     Oquote          ; get open quote flag
00:83F6  49FF              :                 EOR     #$FF            ; toggle it
00:83F8  8512              :                 STA     Oquote          ; save it back
                             LAB_1519
00:83FA  C8                :                 INY                     ; increment index
00:83FB  B15C              :                 LDA     (Baslnl),Y      ; get next byte
00:83FD  D00E              :                 BNE     LAB_152E        ; branch if not [EOL] (go print character)
00:83FF  A8                :                 TAY                     ; else clear index
00:8400  B15C              :                 LDA     (Baslnl),Y      ; get next line pointer low byte
00:8402  AA                :                 TAX                     ; copy to X
00:8403  C8                :                 INY                     ; increment index
00:8404  B15C              :                 LDA     (Baslnl),Y      ; get next line pointer high byte
00:8406  865C              :                 STX     Baslnl          ; set pointer to line low byte
00:8408  855D              :                 STA     Baslnh          ; set pointer to line high byte
00:840A  D0B7              :                 BNE     LAB_14E2        ; go do next line if not [EOT]
                             ; else ..
                             LAB_152B
00:840C  60                :                 RTS

                             LAB_152E
00:840D  10DE              :                 BPL     LAB_150C        ; just go print it if not token byte
                             ; else was token byte so uncrunch it (maybe)
00:840F  2412              :                 BIT     Oquote          ; test the open quote flag

Portable 65xx Assembler [20.01]

00:8411  30DA              :                 BMI     LAB_150C        ; just go print character if open quote set

00:8413  A2A3              :                 LDX     #>LAB_KEYT      ; get table address high byte
00:8415  0A                :                 ASL                     ; *2
00:8416  0A                :                 ASL                     ; *4
00:8417  9002              :                 BCC     LAB_152F        ; branch if no carry

00:8419  E8                :                 INX                     ; else increment high byte
00:841A  18                :                 CLC                     ; clear carry for add
                             LAB_152F
00:841B  69CB              :                 ADC     #<LAB_KEYT      ; add low byte
00:841D  9001              :                 BCC     LAB_1530        ; branch if no carry
00:841F  E8                :                 INX                     ; else increment high byte

                             LAB_1530
00:8420  8525              :                 STA     ut2_pl          ; save table pointer low byte
00:8422  8626              :                 STX     ut2_ph          ; save table pointer high byte
00:8424  8449              :                 STY     Tidx1           ; save index for line
00:8426  A000              :                 LDY     #$00            ; clear index
00:8428  B125              :                 LDA     (ut2_pl),Y      ; get length
00:842A  AA                :                 TAX                     ; copy length
00:842B  C8                :                 INY                     ; increment index
00:842C  B125              :                 LDA     (ut2_pl),Y      ; get 1st character
00:842E  CA                :                 DEX                     ; decrement length
00:842F  F0B8              :                 BEQ     LAB_1508        ; if no more characters exit and print

00:8431  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:8434  C8                :                 INY                     ; increment index
00:8435  B125              :                 LDA     (ut2_pl),Y      ; get keyword address low byte
00:8437  48                :                 PHA                     ; save it for now
00:8438  C8                :                 INY                     ; increment index
00:8439  B125              :                 LDA     (ut2_pl),Y      ; get keyword address high byte
00:843B  A000              :                 LDY     #$00
00:843D  8526              :                 STA     ut2_ph          ; save keyword pointer high byte
00:843F  68                :                 PLA                     ; pull low byte
00:8440  8525              :                 STA     ut2_pl          ; save keyword pointer low byte
                             LAB_1540
00:8442  B125              :                 LDA     (ut2_pl),Y      ; get character
00:8444  CA                :                 DEX                     ; decrement character count
00:8445  F0A2              :                 BEQ     LAB_1508        ; if last character exit and print

00:8447  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:844A  C8                :                 INY                     ; increment index
00:844B  D0F5              :                 BNE     LAB_1540        ; loop for next character

                             ; perform FOR

                             LAB_FOR
00:844D  A980              :                 LDA     #$80            ; set FNX
00:844F  8513              :                 STA     Sufnxf          ; set subscript/FNX flag
00:8451  208987            :                 JSR     LAB_LET         ; go do LET
00:8454  68                :                 PLA                     ; pull return address
00:8455  68                :                 PLA                     ; pull return address
00:8456  A910              :                 LDA     #$10            ; we need 16d bytes !

Portable 65xx Assembler [20.01]

00:8458  20F880            :                 JSR     LAB_1212        ; check room on stack for A bytes
00:845B  207F86            :                 JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
00:845E  18                :                 CLC                     ; clear carry for add
00:845F  98                :                 TYA                     ; copy index to A
00:8460  656E              :                 ADC     Bpntrl          ; add BASIC execute pointer low byte
00:8462  48                :                 PHA                     ; push onto stack
00:8463  A56F              :                 LDA     Bpntrh          ; get BASIC execute pointer high byte
00:8465  6900              :                 ADC     #$00            ; add carry
00:8467  48                :                 PHA                     ; push onto stack
00:8468  A53A              :                 LDA     Clineh          ; get current line high byte
00:846A  48                :                 PHA                     ; push onto stack
00:846B  A539              :                 LDA     Clinel          ; get current line low byte
00:846D  48                :                 PHA                     ; push onto stack
00:846E  A9AA              :                 LDA     #TK_TO          ; get "TO" token
00:8470  20B98B            :                 JSR     LAB_SCCA        ; scan for CHR$(A) , else do syntax error then warm start
00:8473  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00:8476  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
00:8479  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:847B  097F              :                 ORA     #$7F            ; set all non sign bits
00:847D  255F              :                 AND     FAC1_1          ; and FAC1 mantissa1
00:847F  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:8481  A98C              :                 LDA     #<LAB_159F      ; set return address low byte
00:8483  A084              :                 LDY     #>LAB_159F      ; set return address high byte
00:8485  8523              :                 STA     ut1_pl          ; save return address low byte
00:8487  8424              :                 STY     ut1_ph          ; save return address high byte
00:8489  4C4C8B            :                 JMP     LAB_1B66        ; round FAC1 and put on stack (returns to next instruction)

                             LAB_159F
00:848C  A9B1              :                 LDA     #<LAB_259C      ; set 1 pointer low addr (default step size)
00:848E  A0A0              :                 LDY     #>LAB_259C      ; set 1 pointer high addr
00:8490  202398            :                 JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00:8493  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:8496  C9AF              :                 CMP     #TK_STEP        ; compare with STEP token
00:8498  D006              :                 BNE     LAB_15B3        ; jump if not "STEP"

                             ; was step so ..
00:849A  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:849D  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
                             LAB_15B3
00:84A0  208F98            :                 JSR     LAB_27CA        ; return A=FF,C=1/-ve A=01,C=0/+ve
00:84A3  8562              :                 STA     FAC1_s          ; set FAC1 sign (b7)
                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
                             ; compare the FOR value and the TO value and return +1 if
                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
                             ; here (+/-1) is then compared to that result and if they
                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
                             ; the loop is done
00:84A5  20418B            :                 JSR     LAB_1B5B        ; push sign, round FAC1 and put on stack
00:84A8  A54A              :                 LDA     Frnxth          ; get var pointer for FOR/NEXT high byte
00:84AA  48                :                 PHA                     ; push on stack
00:84AB  A549              :                 LDA     Frnxtl          ; get var pointer for FOR/NEXT low byte
00:84AD  48                :                 PHA                     ; push on stack

Portable 65xx Assembler [20.01]

00:84AE  A981              :                 LDA     #TK_FOR         ; get FOR token
00:84B0  48                :                 PHA                     ; push on stack

                             ; interpreter inner loop

                             LAB_15C2
00:84B1  200485            :                 JSR     LAB_1629        ; do CRTL-C check vector
00:84B4  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:84B6  A46F              :                 LDY     Bpntrh          ; get BASIC execute pointer high byte
00:84B8  A63A              :                 LDX     Clineh          ; continue line is $FFxx for immediate mode
                             ; ($00xx for RUN from immediate mode)
00:84BA  E8                :                 INX                     ; increment it (now $00 if immediate mode)
00:84BB  853D              :                 STA     Cpntrl          ; save continue pointer low byte
00:84BD  843E              :                 STY     Cpntrh          ; save continue pointer high byte
                             LAB_15D1
00:84BF  B26E              :                 LDA     (Bpntrl)        ; get next byte
00:84C1  F007              :                 BEQ     LAB_15DC        ; branch if null [EOL]

00:84C3  C93A              :                 CMP     #':'            ; compare with ":"
00:84C5  F01D              :                 BEQ     LAB_15F6        ; branch if = (statement separator)

                             LAB_15D9
00:84C7  4CC88B            :                 JMP     LAB_SNER        ; else syntax error then warm start
                             ; have reached [EOL]
                             LAB_15DC
00:84CA  A002              :                 LDY     #$02            ; set index
00:84CC  B16E              :                 LDA     (Bpntrl),Y      ; get next line pointer high byte
00:84CE  18                :                 CLC                     ; clear carry for no "BREAK" message
00:84CF  F04F              :                 BEQ     LAB_1651        ; if null go to immediate mode (was immediate or [EOT]
                             ; marker)
00:84D1  C8                :                 INY                     ; increment index
00:84D2  B16E              :                 LDA     (Bpntrl),Y      ; get line # low byte
00:84D4  8539              :                 STA     Clinel          ; save current line low byte
00:84D6  C8                :                 INY                     ; increment index
00:84D7  B16E              :                 LDA     (Bpntrl),Y      ; get line # high byte
00:84D9  853A              :                 STA     Clineh          ; save current line high byte
00:84DB  98                :                 TYA                     ; A now = 4
00:84DC  656E              :                 ADC     Bpntrl          ; add BASIC execute pointer low byte
00:84DE  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:84E0  9002              :                 BCC     LAB_15F6        ; branch if no overflow

00:84E2  E66F              :                 INC     Bpntrh          ; else increment BASIC execute pointer high byte
                             LAB_15F6
00:84E4  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory

                             LAB_15F9
00:84E7  20EC84            :                 JSR     LAB_15FF        ; go interpret BASIC code from (Bpntrl)

                             LAB_15FC
00:84EA  80C5              :                 BRA     LAB_15C2        ; loop

                             ; interpret BASIC code from (Bpntrl)

                             LAB_15FF

Portable 65xx Assembler [20.01]

00:84EC  F04E              :                 BEQ     LAB_1628        ; exit if zero [EOL]

                             LAB_1602
00:84EE  0A                :                 ASL                     ; *2 bytes per vector and normalise token
00:84EF  B003              :                 BCS     LAB_1609        ; branch if was token
00:84F1  4C8987            :                 JMP     LAB_LET         ; else go do implied LET

                             LAB_1609
00:84F4  C950              :                 CMP     #(TK_TAB-$80)*2 ; compare normalised token * 2 with TAB
00:84F6  B0CF              :                 BCS     LAB_15D9        ; branch if A>=TAB (do syntax error then warm start)
                             ; only tokens before TAB can start a line
00:84F8  A8                :                 TAY                     ; copy to index
00:84F9  B9D9A0            :                 LDA     LAB_CTBL+1,Y    ; get vector high byte
00:84FC  48                :                 PHA                     ; onto stack
00:84FD  B9D8A0            :                 LDA     LAB_CTBL,Y      ; get vector low byte
00:8500  48                :                 PHA                     ; onto stack
00:8501  4CD89F            :                 JMP     LAB_IGBY        ; jump to increment and scan memory
                             ; then "return" to vector

                             ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
                             ; key press is detected.

                             LAB_1629
00:8504  6C8204            :                 JMP     (VEC_CC)        ; ctrl-c check vector

                             ; if there was a key press it gets back here ..

                             LAB_1636
00:8507  C903              :                 CMP     #$03            ; compare with CTRL-C

                             ; perform STOP

                             LAB_STOP
00:8509  B001              :                 BCS     LAB_163B        ; branch if token follows STOP
                             ; else just END
                             ; END

                             LAB_END
00:850B  18                :                 CLC                     ; clear the carry, indicate a normal program end
                             LAB_163B
00:850C  D061              :                 BNE     LAB_167A        ; if wasn't CTRL-C or there is a following byte return

00:850E  A56F              :                 LDA     Bpntrh          ; get the BASIC execute pointer high byte
00:8510  A46E              :                 LDY     Bpntrl          ; get BASIC execute pointer low byte
00:8512  843D              :                 STY     Cpntrl          ; save continue pointer low byte
00:8514  853E              :                 STA     Cpntrh          ; save continue pointer high byte
                             LAB_1647
00:8516  A539              :                 LDA     Clinel          ; get current line low byte
00:8518  A43A              :                 LDY     Clineh          ; get current line high byte
00:851A  853B              :                 STA     Blinel          ; save break line low byte
00:851C  843C              :                 STY     Blineh          ; save break line high byte
                             LAB_164F
00:851E  68                :                 PLA                     ; pull return address low
00:851F  68                :                 PLA                     ; pull return address high

Portable 65xx Assembler [20.01]

                             LAB_1651
00:8520  9007              :                 BCC     LAB_165E        ; if was program end just do warm start
                             ; else ..
00:8522  A988              :                 LDA     #<LAB_BMSG      ; point to "Break" low byte
00:8524  A0A6              :                 LDY     #>LAB_BMSG      ; point to "Break" high byte
00:8526  4C4681            :                 JMP     LAB_1269        ; print "Break" and do warm start

                             LAB_165E
00:8529  4C5181            :                 JMP     LAB_1274        ; go do warm start

                             ; perform RESTORE

                             LAB_RESTORE
00:852C  D00F              :                 BNE     LAB_RESTOREn    ; branch if next character not null (RESTORE n)

                             LAB_161A
00:852E  38                :                 SEC                     ; set carry for subtract
00:852F  A52B              :                 LDA     Smeml           ; get start of mem low byte
00:8531  E901              :                 SBC     #$01            ; -1
00:8533  A42C              :                 LDY     Smemh           ; get start of mem high byte
00:8535  B001              :                 BCS     LAB_1624        ; branch if no underflow

                             LAB_uflow
00:8537  88                :                 DEY                     ; else decrement high byte
                             LAB_1624
00:8538  8541              :                 STA     Dptrl           ; save DATA pointer low byte
00:853A  8442              :                 STY     Dptrh           ; save DATA pointer high byte
                             LAB_1628
00:853C  60                :                 RTS
                             ; is RESTORE n
                             LAB_RESTOREn
00:853D  202B87            :                 JSR     LAB_GFPN        ; get fixed-point number into temp integer
00:8540  208386            :                 JSR     LAB_SNBL        ; scan for next BASIC line
00:8543  A53A              :                 LDA     Clineh          ; get current line high byte
00:8545  C50B              :                 CMP     Itemph          ; compare with temporary integer high byte
00:8547  B00B              :                 BCS     LAB_reset_search ; branch if >= (start search from beginning)

00:8549  98                :                 TYA                     ; else copy line index to A
00:854A  38                :                 SEC                     ; set carry (+1)
00:854B  656E              :                 ADC     Bpntrl          ; add BASIC execute pointer low byte
00:854D  A66F              :                 LDX     Bpntrh          ; get BASIC execute pointer high byte
00:854F  9007              :                 BCC     LAB_go_search   ; branch if no overflow to high byte

00:8551  E8                :                 INX                     ; increment high byte
00:8552  8004              :                 BRA     LAB_go_search   ; branch always (can never be carry clear)

                             ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)

                             LAB_reset_search
00:8554  A52B              :                 LDA     Smeml           ; get start of mem low byte
00:8556  A62C              :                 LDX     Smemh           ; get start of mem high byte

                             ; search for line # in temp (Itempl/Itemph) from (AX)


Portable 65xx Assembler [20.01]

                             LAB_go_search

00:8558  202083            :                 JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
00:855B  B003              :                 BCS     LAB_line_found  ; if carry set go set pointer

00:855D  4C5486            :                 JMP     LAB_16F7        ; else go do "Undefined statement" error

                             LAB_line_found
                             ; carry already set for subtract
00:8560  A55C              :                 LDA     Baslnl          ; get pointer low byte
00:8562  E901              :                 SBC     #$01            ; -1
00:8564  A45D              :                 LDY     Baslnh          ; get pointer high byte
00:8566  B0D0              :                 BCS     LAB_1624        ; branch if no underflow (save DATA pointer and return)
00:8568  80CD              :                 BRA     LAB_uflow       ; else decrement high byte then save DATA pointer and
                             ; return (branch always)
                             ; perform NULL

                             LAB_NULL
00:856A  203D94            :                 JSR     LAB_GTBY        ; get byte parameter
00:856D  8606              :                 STX     Nullct          ; save new NULL count
                             LAB_167A
00:856F  60                :                 RTS

                             ; perform CONT

                             LAB_CONT
00:8570  D0FD              :                 BNE     LAB_167A        ; if following byte exit to do syntax error

00:8572  A43E              :                 LDY     Cpntrh          ; get continue pointer high byte
00:8574  C004              :                 CPY     #>Ibuffs        ; *** fix p2: test direct mode
00:8576  D005              :                 BNE     LAB_166C        ; go do continue if we can

00:8578  A21E              :                 LDX     #$1E            ; error code $1E ("Can't continue" error)
00:857A  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start
                             ; we can continue so ..
                             LAB_166C
00:857D  846F              :                 STY     Bpntrh          ; save BASIC execute pointer high byte
00:857F  A53D              :                 LDA     Cpntrl          ; get continue pointer low byte
00:8581  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:8583  A53B              :                 LDA     Blinel          ; get break line low byte
00:8585  A43C              :                 LDY     Blineh          ; get break line high byte
00:8587  8539              :                 STA     Clinel          ; set current line low byte
00:8589  843A              :                 STY     Clineh          ; set current line high byte
00:858B  60                :                 RTS

                             ; perform RUN

                             LAB_RUN
00:858C  D003              :                 BNE     LAB_1696        ; branch if RUN n
00:858E  4C5D83            :                 JMP     LAB_1477        ; reset execution to start, clear variables, flush stack and
                             ; return

                             ; does RUN n


Portable 65xx Assembler [20.01]

                             LAB_1696
00:8591  206A83            :                 JSR     LAB_147A        ; go do "CLEAR"
00:8594  802E              :                 BRA     LAB_16B0        ; get n and do GOTO n (branch always as CLEAR sets Z=1)

                             ; perform DO

                             LAB_DO
00:8596  A905              :                 LDA     #$05            ; need 5 bytes for DO
00:8598  20F880            :                 JSR     LAB_1212        ; check room on stack for A bytes
00:859B  A56F              :                 LDA     Bpntrh          ; get BASIC execute pointer high byte
00:859D  48                :                 PHA                     ; push on stack
00:859E  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:85A0  48                :                 PHA                     ; push on stack
00:85A1  A53A              :                 LDA     Clineh          ; get current line high byte
00:85A3  48                :                 PHA                     ; push on stack
00:85A4  A539              :                 LDA     Clinel          ; get current line low byte
00:85A6  48                :                 PHA                     ; push on stack
00:85A7  A99B              :                 LDA     #TK_DO          ; token for DO
00:85A9  48                :                 PHA                     ; push on stack
00:85AA  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:85AD  4CB184            :                 JMP     LAB_15C2        ; go do interpreter inner loop

                             ; perform GOSUB

                             LAB_GOSUB
00:85B0  A905              :                 LDA     #$05            ; need 5 bytes for GOSUB
00:85B2  20F880            :                 JSR     LAB_1212        ; check room on stack for A bytes
00:85B5  A56F              :                 LDA     Bpntrh          ; get BASIC execute pointer high byte
00:85B7  48                :                 PHA                     ; push on stack
00:85B8  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:85BA  48                :                 PHA                     ; push on stack
00:85BB  A53A              :                 LDA     Clineh          ; get current line high byte
00:85BD  48                :                 PHA                     ; push on stack
00:85BE  A539              :                 LDA     Clinel          ; get current line low byte
00:85C0  48                :                 PHA                     ; push on stack
00:85C1  A98D              :                 LDA     #TK_GOSUB       ; token for GOSUB
00:85C3  48                :                 PHA                     ; push on stack
                             LAB_16B0
00:85C4  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:85C7  20CD85            :                 JSR     LAB_GOTO        ; perform GOTO n
00:85CA  4CB184            :                 JMP     LAB_15C2        ; go do interpreter inner loop
                             ; (can't RTS, we used the stack!)

                             ; perform GOTO

                             LAB_GOTO
00:85CD  202B87            :                 JSR     LAB_GFPN        ; get fixed-point number into temp integer
00:85D0  208386            :                 JSR     LAB_SNBL        ; scan for next BASIC line
00:85D3  A53A              :                 LDA     Clineh          ; get current line high byte
00:85D5  C50B              :                 CMP     Itemph          ; compare with temporary integer high byte
00:85D7  B00B              :                 BCS     LAB_16D0        ; branch if >= (start search from beginning)

00:85D9  98                :                 TYA                     ; else copy line index to A
00:85DA  38                :                 SEC                     ; set carry (+1)

Portable 65xx Assembler [20.01]

00:85DB  656E              :                 ADC     Bpntrl          ; add BASIC execute pointer low byte
00:85DD  A66F              :                 LDX     Bpntrh          ; get BASIC execute pointer high byte
00:85DF  9007              :                 BCC     LAB_16D4        ; branch if no overflow to high byte

00:85E1  E8                :                 INX                     ; increment high byte
00:85E2  8004              :                 BRA     LAB_16D4        ; branch always (can never be carry)

                             ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)

                             LAB_16D0
00:85E4  A52B              :                 LDA     Smeml           ; get start of mem low byte
00:85E6  A62C              :                 LDX     Smemh           ; get start of mem high byte

                             ; search for line # in temp (Itempl/Itemph) from (AX)

                             LAB_16D4
00:85E8  202083            :                 JSR     LAB_SHLN        ; search Basic for temp integer line number from AX
00:85EB  9067              :                 BCC     LAB_16F7        ; if carry clear go do "Undefined statement" error
                             ; (unspecified statement)
                             ; carry already set for subtract
00:85ED  A55C              :                 LDA     Baslnl          ; get pointer low byte
00:85EF  E901              :                 SBC     #$01            ; -1
00:85F1  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:85F3  A55D              :                 LDA     Baslnh          ; get pointer high byte
00:85F5  E900              :                 SBC     #$00            ; subtract carry
00:85F7  856F              :                 STA     Bpntrh          ; save BASIC execute pointer high byte
                             LAB_16E5
00:85F9  60                :                 RTS

                             LAB_DONOK
00:85FA  A222              :                 LDX     #$22            ; error code $22 ("LOOP without DO" error)
00:85FC  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; perform LOOP

                             LAB_LOOP
00:85FF  A8                :                 TAY                     ; save following token
00:8600  BA                :                 TSX                     ; copy stack pointer
00:8601  BD0301            :                 LDA     LAB_STAK+3,X    ; get token byte from stack
00:8604  C99B              :                 CMP     #TK_DO          ; compare with DO token
00:8606  D0F2              :                 BNE     LAB_DONOK       ; branch if no matching DO

00:8608  E8                :                 INX                     ; dump calling routine return address
00:8609  E8                :                 INX                     ; dump calling routine return address
00:860A  9A                :                 TXS                     ; correct stack
00:860B  98                :                 TYA                     ; get saved following token back
00:860C  F020              :                 BEQ     LoopAlways      ; if no following token loop forever
                             ; (stack pointer in X)

00:860E  C93A              :                 CMP     #':'            ; could be ':'
00:8610  F01C              :                 BEQ     LoopAlways      ; if :... loop forever

00:8612  E9B0              :                 SBC     #TK_UNTIL       ; subtract token for UNTIL, we know carry is set here
00:8614  AA                :                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)

Portable 65xx Assembler [20.01]

00:8615  F004              :                 BEQ     DoRest          ; branch if was UNTIL

00:8617  CA                :                 DEX                     ; decrement result
00:8618  D062              :                 BNE     LAB_16FC        ; if not WHILE go do syntax error and warm start
                             ; only if the token was WHILE will this fail

00:861A  CA                :                 DEX                     ; set invert result byte
                             DoRest
00:861B  864A              :                 STX     Frnxth          ; save invert result byte
00:861D  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8620  20AC8A            :                 JSR     LAB_EVEX        ; evaluate expression
00:8623  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:8625  F002              :                 BEQ     DoCmp           ; if =0 go do straight compare

00:8627  A9FF              :                 LDA     #$FF            ; else set all bits
                             DoCmp
00:8629  BA                :                 TSX                     ; copy stack pointer
00:862A  454A              :                 EOR     Frnxth          ; EOR with invert byte
00:862C  D01A              :                 BNE     LoopDone        ; if <> 0 clear stack and back to interpreter loop
                             ; loop condition wasn't met so do it again
                             LoopAlways
00:862E  BD0201            :                 LDA     LAB_STAK+2,X    ; get current line low byte
00:8631  8539              :                 STA     Clinel          ; save current line low byte
00:8633  BD0301            :                 LDA     LAB_STAK+3,X    ; get current line high byte
00:8636  853A              :                 STA     Clineh          ; save current line high byte
00:8638  BD0401            :                 LDA     LAB_STAK+4,X    ; get BASIC execute pointer low byte
00:863B  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:863D  BD0501            :                 LDA     LAB_STAK+5,X    ; get BASIC execute pointer high byte
00:8640  856F              :                 STA     Bpntrh          ; save BASIC execute pointer high byte
00:8642  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:8645  4CB184            :                 JMP     LAB_15C2        ; go do interpreter inner loop

                             ; clear stack and back to interpreter loop
                             LoopDone
00:8648  E8                :                 INX                     ; dump DO token
00:8649  E8                :                 INX                     ; dump current line low byte
00:864A  E8                :                 INX                     ; dump current line high byte
00:864B  E8                :                 INX                     ; dump BASIC execute pointer low byte
00:864C  E8                :                 INX                     ; dump BASIC execute pointer high byte
00:864D  9A                :                 TXS                     ; correct stack
00:864E  801E              :                 BRA     LAB_DATA        ; go perform DATA (find : or [EOL])

                             ; do the return without gosub error

                             LAB_16F4
00:8650  A204              :                 LDX     #$04            ; error code $04 ("RETURN without GOSUB" error)
00:8652  8002              :                 BRA     LAB_16F7b       ; branch around next instruction, save one clock cycle

                             LAB_16F7                                ; do undefined statement error
00:8654  A20E              :                 LDX     #$0E            ; error code $0E ("Undefined statement" error)
                             LAB_16F7b
00:8656  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; perform RETURN

Portable 65xx Assembler [20.01]


                             LAB_RETURN
00:8659  D09E              :                 BNE     LAB_16E5        ; exit if following token (to allow syntax error)

                             LAB_16E8
00:865B  68                :                 PLA                     ; dump calling routine return address
00:865C  68                :                 PLA                     ; dump calling routine return address
00:865D  68                :                 PLA                     ; pull token
00:865E  C98D              :                 CMP     #TK_GOSUB       ; compare with GOSUB token
00:8660  D0EE              :                 BNE     LAB_16F4        ; branch if no matching GOSUB

                             LAB_16FF
00:8662  68                :                 PLA                     ; pull current line low byte
00:8663  8539              :                 STA     Clinel          ; save current line low byte
00:8665  68                :                 PLA                     ; pull current line high byte
00:8666  853A              :                 STA     Clineh          ; save current line high byte
00:8668  68                :                 PLA                     ; pull BASIC execute pointer low byte
00:8669  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:866B  68                :                 PLA                     ; pull BASIC execute pointer high byte
00:866C  856F              :                 STA     Bpntrh          ; save BASIC execute pointer high byte

                             ; now do the DATA statement as we could be returning into
                             ; the middle of an ON <var> GOSUB n,m,p,q line
                             ; (the return address used by the DATA statement is the one
                             ; pushed before the GOSUB was executed!)

                             ; perform DATA

                             LAB_DATA
00:866E  207F86            :                 JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])

                             ; set BASIC execute pointer
                             LAB_170F
00:8671  98                :                 TYA                     ; copy index to A
00:8672  18                :                 CLC                     ; clear carry for add
00:8673  656E              :                 ADC     Bpntrl          ; add BASIC execute pointer low byte
00:8675  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:8677  9002              :                 BCC     LAB_1719        ; skip next if no carry

00:8679  E66F              :                 INC     Bpntrh          ; else increment BASIC execute pointer high byte
                             LAB_1719
00:867B  60                :                 RTS

                             LAB_16FC
00:867C  4CC88B            :                 JMP     LAB_SNER        ; do syntax error then warm start

                             ; scan for next BASIC statement ([:] or [EOL])
                             ; returns Y as index to [:] or [EOL]

                             LAB_SNBS
00:867F  A23A              :                 LDX     #':'            ; set look for character = ":"
00:8681  8002              :                 BRA     LAB_SNBLb       ; branch around next instruction, save one clock cycle

                             ; scan for next BASIC line

Portable 65xx Assembler [20.01]

                             ; returns Y as index to [EOL]

                             LAB_SNBL
00:8683  A200              :                 LDX     #$00            ; set alt search character = [EOL]
                             LAB_SNBLb
00:8685  A000              :                 LDY     #$00            ; set search character = [EOL]
00:8687  840E              :                 STY     Asrch           ; store search character
                             LAB_1725
00:8689  8A                :                 TXA                     ; get alt search character
00:868A  450E              :                 EOR     Asrch           ; toggle search character, effectively swap with $00
00:868C  850E              :                 STA     Asrch           ; save swapped search character
                             LAB_172D
00:868E  B16E              :                 LDA     (Bpntrl),Y      ; get next byte
00:8690  F0E9              :                 BEQ     LAB_1719        ; exit if null [EOL]

00:8692  C50E              :                 CMP     Asrch           ; compare with search character
00:8694  F0E5              :                 BEQ     LAB_1719        ; exit if found

00:8696  C8                :                 INY                     ; increment index
00:8697  C922              :                 CMP     #$22            ; compare current character with open quote
00:8699  D0F3              :                 BNE     LAB_172D        ; if not open quote go get next character

00:869B  F0EC              :                 BEQ     LAB_1725        ; if found go swap search character for alt search character

                             ; perform IF

                             LAB_IF
00:869D  20AC8A            :                 JSR     LAB_EVEX        ; evaluate the expression
00:86A0  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:86A3  C9AD              :                 CMP     #TK_THEN        ; compare with THEN token
00:86A5  F011              :                 BEQ     LAB_174B        ; if it was THEN go do IF

                             ; wasn't IF .. THEN so must be IF .. GOTO
00:86A7  C989              :                 CMP     #TK_GOTO        ; compare with GOTO token
00:86A9  D0D1              :                 BNE     LAB_16FC        ; if it wasn't GOTO go do syntax error

00:86AB  A66E              :                 LDX     Bpntrl          ; save the basic pointer low byte
00:86AD  A46F              :                 LDY     Bpntrh          ; save the basic pointer high byte
00:86AF  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:86B2  B0C8              :                 BCS     LAB_16FC        ; if not numeric go do syntax error

00:86B4  866E              :                 STX     Bpntrl          ; restore the basic pointer low byte
00:86B6  846F              :                 STY     Bpntrh          ; restore the basic pointer high byte
                             LAB_174B
00:86B8  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:86BA  F01C              :                 BEQ     LAB_174E        ; if the result was zero go look for an ELSE

00:86BC  20D89F            :                 JSR     LAB_IGBY        ; else increment and scan memory
00:86BF  B003              :                 BCS     LAB_174D        ; if not numeric go do var or keyword

                             LAB_174C
00:86C1  4CCD85            :                 JMP     LAB_GOTO        ; else was numeric so do GOTO n

                             ; is var or keyword

Portable 65xx Assembler [20.01]

                             LAB_174D
00:86C4  68                :                 PLA                     ; discard interpreter loop return address
00:86C5  68                :                 PLA                     ; so data structures are at the correct stack offset
00:86C6  20DE9F            :                 JSR     LAB_GBYT        ; restore token or variable
00:86C9  20EC84            :                 JSR     LAB_15FF        ; interpret BASIC code from (Bpntrl)

                             ; the IF was executed and there may be a following ELSE so the code needs to return
                             ; here to check and ignore the ELSE if present

00:86CC  B26E              :                 LDA     (Bpntrl)        ; get the next BASIC byte
00:86CE  C9A9              :                 CMP     #TK_ELSE        ; compare it with the token for ELSE
00:86D0  D003              :                 BNE     LAB_no_ELSE     ; no - continue on this line
00:86D2  206E86            :                 JSR     LAB_DATA        ; yes - skip the rest of the line

                             ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
                             ; following ELSE will, correctly, cause a syntax error

                             LAB_no_ELSE
00:86D5  4CB184            :                 JMP     LAB_15C2        ; return to the interpreter inner loop

                             ; perform ELSE after IF

                             LAB_174E
00:86D8  A000              :                 LDY     #$00            ; clear the BASIC byte index
00:86DA  A201              :                 LDX     #$01            ; clear the nesting depth
                             LAB_1750
00:86DC  C8                :                 INY                     ; increment the BASIC byte index
00:86DD  B16E              :                 LDA     (Bpntrl),Y      ; get the next BASIC byte
00:86DF  F00F              :                 BEQ     LAB_1753        ; if EOL go add the pointer and return

00:86E1  C98B              :                 CMP     #TK_IF          ; compare the byte with the token for IF
00:86E3  D003              :                 BNE     LAB_1752        ; if not IF token skip the depth increment

00:86E5  E8                :                 INX                     ; else increment the nesting depth ..
00:86E6  D0F4              :                 BNE     LAB_1750        ; .. and continue looking

                             LAB_1752
00:86E8  C9A9              :                 CMP     #TK_ELSE        ; compare the byte with the token for ELSE
00:86EA  D0F0              :                 BNE     LAB_1750        ; if not ELSE token continue looking

00:86EC  CA                :                 DEX                     ; was ELSE so decrement the nesting depth
00:86ED  D0ED              :                 BNE     LAB_1750        ; loop if still nested

00:86EF  C8                :                 INY                     ; increment the BASIC byte index past the ELSE

                             ; found the matching ELSE, now do <{n|statement}>

                             LAB_1753
00:86F0  98                :                 TYA                     ; else copy line index to A
00:86F1  18                :                 CLC                     ; clear carry for add
00:86F2  656E              :                 ADC     Bpntrl          ; add the BASIC execute pointer low byte
00:86F4  856E              :                 STA     Bpntrl          ; save the BASIC execute pointer low byte
00:86F6  9002              :                 BCC     LAB_1754        ; branch if no overflow to high byte


Portable 65xx Assembler [20.01]

00:86F8  E66F              :                 INC     Bpntrh          ; else increment the BASIC execute pointer high byte
                             LAB_1754
00:86FA  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:86FD  90C2              :                 BCC     LAB_174C        ; if numeric do GOTO n
                             ; the code will return to the interpreter loop at the
                             ; tail end of the GOTO <n>

00:86FF  4CEC84            :                 JMP     LAB_15FF        ; interpret BASIC code from (Bpntrl)
                             ; the code will return to the interpreter loop at the
                             ; tail end of the <statement>

                             ; perform REM, skip (rest of) line

                             LAB_REM
00:8702  208386            :                 JSR     LAB_SNBL        ; scan for next BASIC line
00:8705  4C7186            :                 JMP     LAB_170F        ; go set BASIC execute pointer and return, branch always

                             LAB_16FD
00:8708  4CC88B            :                 JMP     LAB_SNER        ; do syntax error then warm start

                             ; perform ON

                             LAB_ON
00:870B  203D94            :                 JSR     LAB_GTBY        ; get byte parameter
00:870E  48                :                 PHA                     ; push GOTO/GOSUB token
00:870F  C98D              :                 CMP     #TK_GOSUB       ; compare with GOSUB token
00:8711  F004              :                 BEQ     LAB_176B        ; branch if GOSUB

00:8713  C989              :                 CMP     #TK_GOTO        ; compare with GOTO token
                             LAB_1767
00:8715  D0F1              :                 BNE     LAB_16FD        ; if not GOTO do syntax error then warm start

                             ; next character was GOTO or GOSUB

                             LAB_176B
00:8717  C661              :                 DEC     FAC1_3          ; decrement index (byte value)
00:8719  D004              :                 BNE     LAB_1773        ; branch if not zero

00:871B  68                :                 PLA                     ; pull GOTO/GOSUB token
00:871C  4CEE84            :                 JMP     LAB_1602        ; go execute it

                             LAB_1773
00:871F  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8722  202B87            :                 JSR     LAB_GFPN        ; get fixed-point number into temp integer (skip this n)
                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
                             ; just BNE LAB_176B for the loop. should be quicker ..
                             ; no we can't, what if we meet a colon or [EOL]?)
00:8725  C92C              :                 CMP     #$2C            ; compare next character with ","
00:8727  F0EE              :                 BEQ     LAB_176B        ; loop if ","

                             LAB_177E
00:8729  68                :                 PLA                     ; else pull keyword token (run out of options)
                             ; also dump +/-1 pointer low byte and exit
                             LAB_177F

Portable 65xx Assembler [20.01]

00:872A  60                :                 RTS

                             ; takes n * 106 + 11 cycles where n is the number of digits

                             ; get fixed-point number into temp integer

                             LAB_GFPN
00:872B  A200              :                 LDX     #$00            ; clear reg
00:872D  860A              :                 STX     Itempl          ; clear temporary integer low byte
                             LAB_1785
00:872F  860B              :                 STX     Itemph          ; save temporary integer high byte
00:8731  B0F7              :                 BCS     LAB_177F        ; return if carry set, end of scan, character was
                             ; not 0-9

00:8733  E019              :                 CPX     #$19            ; compare high byte with $19
00:8735  A8                :                 TAY                     ; ensure Zb = 0 if the branch is taken
00:8736  B0DD              :                 BCS     LAB_1767        ; branch if >=, makes max line # 63999 because next
                             ; bit does *$0A, = 64000, compare at target will fail
                             ; and do syntax error

00:8738  E92F              :                 SBC     #'0'-1          ; subtract "0", $2F + carry, from byte
00:873A  A8                :                 TAY                     ; copy binary digit
00:873B  A50A              :                 LDA     Itempl          ; get temporary integer low byte
00:873D  0A                :                 ASL                     ; *2 low byte
00:873E  260B              :                 ROL     Itemph          ; *2 high byte
00:8740  0A                :                 ASL                     ; *2 low byte
00:8741  260B              :                 ROL     Itemph          ; *2 high byte, *4
00:8743  650A              :                 ADC     Itempl          ; + low byte, *5
00:8745  850A              :                 STA     Itempl          ; save it
00:8747  8A                :                 TXA                     ; get high byte copy to A
00:8748  650B              :                 ADC     Itemph          ; + high byte, *5
00:874A  060A              :                 ASL     Itempl          ; *2 low byte, *10d
00:874C  2A                :                 ROL                     ; *2 high byte, *10d
00:874D  AA                :                 TAX                     ; copy high byte back to X
00:874E  98                :                 TYA                     ; get binary digit back
00:874F  650A              :                 ADC     Itempl          ; add number low byte
00:8751  850A              :                 STA     Itempl          ; save number low byte
00:8753  9001              :                 BCC     LAB_17B3        ; if no overflow to high byte get next character

00:8755  E8                :                 INX                     ; else increment high byte
                             LAB_17B3
00:8756  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8759  80D4              :                 BRA     LAB_1785        ; loop for next character

                             ; perform DEC

                             LAB_DEC
00:875B  A9B5              :                 LDA     #<LAB_2AFD      ; set -1 pointer low byte
00:875D  8002              :                 BRA     LAB_17B5        ; branch around next instruction, saves one clock cycle

                             ; perform INC

                             LAB_INC
00:875F  A9B1              :                 LDA     #<LAB_259C      ; set 1 pointer low byte

Portable 65xx Assembler [20.01]

                             LAB_17B5
00:8761  48                :                 PHA                     ; save +/-1 pointer low byte
                             LAB_17B7
00:8762  206A8D            :                 JSR     LAB_GVAR        ; get var address
00:8765  A611              :                 LDX     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:8767  301D              :                 BMI     IncrErr         ; exit if string

00:8769  8549              :                 STA     Lvarpl          ; save var address low byte
00:876B  844A              :                 STY     Lvarph          ; save var address high byte
00:876D  202398            :                 JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00:8770  68                :                 PLA                     ; get +/-1 pointer low byte
00:8771  48                :                 PHA                     ; save +/-1 pointer low byte
00:8772  A0A0              :                 LDY     #>LAB_259C      ; set +/-1 pointer high byte (both the same)
00:8774  206B95            :                 JSR     LAB_246C        ; add (AY) to FAC1
00:8777  204998            :                 JSR     LAB_PFAC        ; pack FAC1 into variable (Lvarpl)

00:877A  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:877D  C92C              :                 CMP     #','            ; compare with ","
00:877F  D0A8              :                 BNE     LAB_177E        ; exit if not "," (either end or error)

                             ; was "," so another INCR variable to do
00:8781  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8784  80DC              :                 BRA     LAB_17B7        ; go do next var

                             IncrErr
00:8786  4CA78A            :                 JMP     LAB_1ABC        ; do "Type mismatch" error then warm start

                             ; perform LET

                             LAB_LET
00:8789  206A8D            :                 JSR     LAB_GVAR        ; get var address
00:878C  8549              :                 STA     Lvarpl          ; save var address low byte
00:878E  844A              :                 STY     Lvarph          ; save var address high byte
00:8790  A9BD              :                 LDA     #TK_EQUAL       ; get = token
00:8792  20B98B            :                 JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
00:8795  A511              :                 LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:8797  48                :                 PHA                     ; push data type flag
00:8798  20AC8A            :                 JSR     LAB_EVEX        ; evaluate expression
00:879B  68                :                 PLA                     ; pop data type flag
00:879C  2A                :                 ROL                     ; set carry if type = string
00:879D  209E8A            :                 JSR     LAB_CKTM        ; type match check, set C for string
00:87A0  D003              :                 BNE     LAB_17D5        ; branch if string
00:87A2  4C4998            :                 JMP     LAB_PFAC        ; pack FAC1 into variable (Lvarpl) and return

                             ; string LET

                             LAB_17D5
00:87A5  A002              :                 LDY     #$02            ; set index to pointer high byte
00:87A7  B160              :                 LDA     (des_pl),Y      ; get string pointer high byte
00:87A9  C534              :                 CMP     Sstorh          ; compare bottom of string space high byte
00:87AB  9017              :                 BCC     LAB_17F4        ; if less assign value and exit (was in program memory)

00:87AD  D007              :                 BNE     LAB_17E6        ; branch if >
                             ; else was equal so compare low bytes

Portable 65xx Assembler [20.01]

00:87AF  88                :                 DEY                     ; decrement index
00:87B0  B160              :                 LDA     (des_pl),Y      ; get pointer low byte
00:87B2  C533              :                 CMP     Sstorl          ; compare bottom of string space low byte
00:87B4  900E              :                 BCC     LAB_17F4        ; if less assign value and exit (was in program memory)

                             ; pointer was >= to bottom of string space pointer
                             LAB_17E6
00:87B6  A461              :                 LDY     des_ph          ; get descriptor pointer high byte
00:87B8  C42E              :                 CPY     Svarh           ; compare start of vars high byte
00:87BA  9008              :                 BCC     LAB_17F4        ; branch if less (descriptor is on stack)

00:87BC  D00C              :                 BNE     LAB_17FB        ; branch if greater (descriptor is not on stack)
                             ; else high bytes were equal so ..
00:87BE  A560              :                 LDA     des_pl          ; get descriptor pointer low byte
00:87C0  C52D              :                 CMP     Svarl           ; compare start of vars low byte
00:87C2  B006              :                 BCS     LAB_17FB        ; branch if >= (descriptor is not on stack)

                             LAB_17F4
00:87C4  A560              :                 LDA     des_pl          ; get descriptor pointer low byte
00:87C6  A461              :                 LDY     des_ph          ; get descriptor pointer high byte
00:87C8  8014              :                 BRA     LAB_1811        ; clean stack, copy descriptor to variable and return

                             ; make space and copy string
                             LAB_17FB
00:87CA  B260              :                 LDA     (des_pl)        ; get string length
00:87CC  20ED90            :                 JSR     LAB_209C        ; copy string
00:87CF  A550              :                 LDA     des_2l          ; get descriptor pointer low byte
00:87D1  A451              :                 LDY     des_2h          ; get descriptor pointer high byte
00:87D3  856A              :                 STA     ssptr_l         ; save descriptor pointer low byte
00:87D5  846B              :                 STY     ssptr_h         ; save descriptor pointer high byte
00:87D7  20C992            :                 JSR     LAB_228A        ; copy string from descriptor (sdescr) to (Sutill)
00:87DA  A95E              :                 LDA     #<FAC1_e        ; set descriptor pointer low byte
00:87DC  A000              :                 LDY     #>FAC1_e        ; get descriptor pointer high byte

                             ; clean stack and assign value to string variable
                             LAB_1811
00:87DE  8550              :                 STA     des_2l          ; save descriptor_2 pointer low byte
00:87E0  8451              :                 STY     des_2h          ; save descriptor_2 pointer high byte
00:87E2  202B93            :                 JSR     LAB_22EB        ; clean descriptor stack, YA = pointer
00:87E5  A000              :                 LDY     #$00            ; index to length
00:87E7  B150              :                 LDA     (des_2l),Y      ; get string length
00:87E9  9149              :                 STA     (Lvarpl),Y      ; copy to let string variable
00:87EB  C8                :                 INY                     ; index to string pointer low byte
00:87EC  B150              :                 LDA     (des_2l),Y      ; get string pointer low byte
00:87EE  9149              :                 STA     (Lvarpl),Y      ; copy to let string variable
00:87F0  C8                :                 INY                     ; index to string pointer high byte
00:87F1  B150              :                 LDA     (des_2l),Y      ; get string pointer high byte
00:87F3  9149              :                 STA     (Lvarpl),Y      ; copy to let string variable
00:87F5  60                :                 RTS

                             ; perform GET

                             LAB_GET
00:87F6  206A8D            :                 JSR     LAB_GVAR        ; get var address

Portable 65xx Assembler [20.01]

00:87F9  8549              :                 STA     Lvarpl          ; save var address low byte
00:87FB  844A              :                 STY     Lvarph          ; save var address high byte
00:87FD  20599E            :                 JSR     INGET           ; get input byte
00:8800  A611              :                 LDX     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:8802  3007              :                 BMI     LAB_GETS        ; go get string character
                             ; was numeric get
00:8804  A8                :                 TAY                     ; copy character to Y
00:8805  202390            :                 JSR     LAB_1FD0        ; convert Y to byte in FAC1
00:8808  4C4998            :                 JMP     LAB_PFAC        ; pack FAC1 into variable (Lvarpl) and return

                             LAB_GETS
00:880B  48                :                 PHA                     ; save character
00:880C  A901              :                 LDA     #$01            ; string is single byte
00:880E  B001              :                 BCS     LAB_IsByte      ; branch if byte received

00:8810  68                :                 PLA                     ; string is null
                             LAB_IsByte
00:8811  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00:8814  F005              :                 BEQ     LAB_NoSt        ; skip store if null string

00:8816  68                :                 PLA                     ; get character back
00:8817  A000              :                 LDY     #$00            ; clear index
00:8819  915F              :                 STA     (str_pl),Y      ; save byte in string (byte IS string!)
                             LAB_NoSt
00:881B  204291            :                 JSR     LAB_RTST        ; check for space on descriptor stack then put address
                             ; and length on descriptor stack and update stack pointers

00:881E  8085              :                 BRA     LAB_17D5        ; do string LET and return

                             ; perform PRINT

                             LAB_1829
00:8820  20A388            :                 JSR     LAB_18C6        ; print string from Sutill/Sutilh
                             LAB_182C
00:8823  20DE9F            :                 JSR     LAB_GBYT        ; scan memory

                             ; PRINT

                             LAB_PRINT
00:8826  F037              :                 BEQ     LAB_CRLF        ; if nothing following just print CR/LF

                             LAB_1831
00:8828  C9A8              :                 CMP     #TK_TAB         ; compare with TAB( token
00:882A  F052              :                 BEQ     LAB_18A2        ; go do TAB/SPC

00:882C  C9AC              :                 CMP     #TK_SPC         ; compare with SPC( token
00:882E  F04E              :                 BEQ     LAB_18A2        ; go do TAB/SPC

00:8830  C92C              :                 CMP     #','            ; compare with ","
00:8832  F034              :                 BEQ     LAB_188B        ; go do move to next TAB mark

00:8834  C93B              :                 CMP     #'              ;'            ; compare with ";"
00:8836  F062              :                 BEQ     LAB_18BD        ; if ";" continue with PRINT processing

Portable 65xx Assembler [20.01]


00:8838  20AC8A            :                 JSR     LAB_EVEX        ; evaluate expression
00:883B  2411              :                 BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
00:883D  30E1              :                 BMI     LAB_1829        ; branch if string

00:883F  202F9A            :                 JSR     LAB_296E        ; convert FAC1 to string
00:8842  20FF90            :                 JSR     LAB_20AE        ; print " terminated string to Sutill/Sutilh

                             ; don't check fit if terminal width byte is zero

00:8845  A508              :                 LDA     TWidth          ; get terminal width byte
00:8847  F00A              :                 BEQ     LAB_185E        ; skip check if zero

00:8849  38                :                 SEC                     ; set carry for subtract
00:884A  E507              :                 SBC     TPos            ; subtract terminal position
00:884C  F260              :                 SBC     (des_pl)        ; subtract string length
00:884E  B003              :                 BCS     LAB_185E        ; branch if less than terminal width

00:8850  205F88            :                 JSR     LAB_CRLF        ; else print CR/LF
                             LAB_185E
00:8853  20A388            :                 JSR     LAB_18C6        ; print string from Sutill/Sutilh
00:8856  80CB              :                 BRA     LAB_182C        ; always go continue processing line

                             ; CR/LF return to BASIC from BASIC input handler

                             LAB_1866
                             ;      LDA   #$00              ; clear byte
00:8858  9E0004            :                 STZ     Ibuffs,X        ; null terminate input
00:885B  A200              :                 LDX     #<Ibuffs        ; set X to buffer start-1 low byte
00:885D  A004              :                 LDY     #>Ibuffs        ; set Y to buffer start-1 high byte

                             ; print CR/LF

                             LAB_CRLF
00:885F  A90D              :                 LDA     #$0D            ; load [CR]
00:8861  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:8864  A90A              :                 LDA     #$0A            ; load [LF]
00:8866  8053              :                 BRA     LAB_PRNA        ; go print the character and return, branch always

                             LAB_188B
00:8868  A507              :                 LDA     TPos            ; get terminal position
00:886A  C509              :                 CMP     Iclim           ; compare with input column limit
00:886C  9005              :                 BCC     LAB_1897        ; branch if less

00:886E  205F88            :                 JSR     LAB_CRLF        ; else print CR/LF (next line)
00:8871  8027              :                 BRA     LAB_18BD        ; continue with PRINT processing (branch always)

                             LAB_1897
00:8873  38                :                 SEC                     ; set carry for subtract
                             LAB_1898
00:8874  E516              :                 SBC     TabSiz          ; subtract TAB size
00:8876  B0FC              :                 BCS     LAB_1898        ; loop if result was +ve

00:8878  49FF              :                 EOR     #$FF            ; complement it

Portable 65xx Assembler [20.01]

00:887A  6901              :                 ADC     #$01            ; +1 (twos complement)
00:887C  8012              :                 BRA     LAB_18B6        ; always print A spaces (result is never $00)

                             ; do TAB/SPC
                             LAB_18A2
00:887E  48                :                 PHA                     ; save token
00:887F  203A94            :                 JSR     LAB_SGBY        ; scan and get byte parameter
00:8882  C929              :                 CMP     #$29            ; is next character )
00:8884  D07C              :                 BNE     LAB_1910        ; if not do syntax error then warm start

00:8886  68                :                 PLA                     ; get token back
00:8887  C9A8              :                 CMP     #TK_TAB         ; was it TAB ?
00:8889  D006              :                 BNE     LAB_18B7        ; if not go do SPC

                             ; calculate TAB offset
00:888B  8A                :                 TXA                     ; copy integer value to A
00:888C  E507              :                 SBC     TPos            ; subtract terminal position
00:888E  900A              :                 BCC     LAB_18BD        ; branch if result was < 0 (can't TAB backwards)

                             ; print A spaces
                             LAB_18B6
00:8890  AA                :                 TAX                     ; copy result to X
                             LAB_18B7
00:8891  8A                :                 TXA                     ; set flags on size for SPC
00:8892  F006              :                 BEQ     LAB_18BD        ; branch if result was = $0, already here

                             ; print X spaces
                             LAB_18BA
00:8894  20B588            :                 JSR     LAB_18E0        ; print " "
00:8897  CA                :                 DEX                     ; decrement count
00:8898  D0FA              :                 BNE     LAB_18BA        ; loop if not all done

                             ; continue with PRINT processing
                             LAB_18BD
00:889A  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:889D  D089              :                 BNE     LAB_1831        ; if more to print go do it

00:889F  60                :                 RTS

                             ; print null terminated string from memory

                             LAB_18C3
00:88A0  20FF90            :                 JSR     LAB_20AE        ; print " terminated string to Sutill/Sutilh

                             ; print string from Sutill/Sutilh

                             LAB_18C6
00:88A3  20F692            :                 JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
                             ; space returns with A = length, X=$71=pointer low byte,
                             ; Y=$72=pointer high byte
00:88A6  A000              :                 LDY     #$00            ; reset index
00:88A8  AA                :                 TAX                     ; copy length to X
00:88A9  F04A              :                 BEQ     LAB_188C        ; exit (RTS) if null string


Portable 65xx Assembler [20.01]

                             LAB_18CD

00:88AB  B123              :                 LDA     (ut1_pl),Y      ; get next byte
00:88AD  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:88B0  C8                :                 INY                     ; increment index
00:88B1  CA                :                 DEX                     ; decrement count
00:88B2  D0F7              :                 BNE     LAB_18CD        ; loop if not done yet
00:88B4  60                :                 RTS

                             ; Print single format character
                             ; print " "

                             LAB_18E0
00:88B5  A920              :                 LDA     #$20            ; load " "
00:88B7  8002              :                 BRA     LAB_PRNA        ; branch around next instruction, saves one clock cycle

                             ; print "?" character

                             LAB_18E3
00:88B9  A93F              :                 LDA     #$3F            ; load "?" character

                             ; print character in A
                             ; now includes the null handler
                             ; also includes infinite line length code
                             ; note! some routines expect this one to exit with Zb=0

                             LAB_PRNA
00:88BB  C920              :                 CMP     #' '            ; compare with " "
00:88BD  9019              :                 BCC     LAB_18F9        ; branch if less (non printing)

                             ; else printable character
00:88BF  48                :                 PHA                     ; save the character

                             ; don't check fit if terminal width byte is zero

00:88C0  A508              :                 LDA     TWidth          ; get terminal width
00:88C2  D00A              :                 BNE     LAB_18F0        ; branch if not zero (not infinite length)

                             ; is "infinite line" so check TAB position

00:88C4  A507              :                 LDA     TPos            ; get position
00:88C6  E516              :                 SBC     TabSiz          ; subtract TAB size, carry set by CMP #$20 above
00:88C8  D00B              :                 BNE     LAB_18F7        ; skip reset if different

00:88CA  8507              :                 STA     TPos            ; else reset position
00:88CC  F007              :                 BEQ     LAB_18F7        ; go print character

                             LAB_18F0
00:88CE  C507              :                 CMP     TPos            ; compare with terminal character position
00:88D0  D003              :                 BNE     LAB_18F7        ; branch if not at end of line

00:88D2  205F88            :                 JSR     LAB_CRLF        ; else print CR/LF
                             LAB_18F7
00:88D5  E607              :                 INC     TPos            ; increment terminal position

Portable 65xx Assembler [20.01]

00:88D7  68                :                 PLA                     ; get character back
                             LAB_18F9
00:88D8  20F99F            :                 JSR     V_OUTP          ; output byte via output vector
00:88DB  C90D              :                 CMP     #$0D            ; compare with [CR]
00:88DD  D014              :                 BNE     LAB_188A        ; branch if not [CR]

                             ; else print nullct nulls after the [CR]
00:88DF  862A              :                 STX     TempB           ; save buffer index
00:88E1  A606              :                 LDX     Nullct          ; get null count
00:88E3  F00A              :                 BEQ     LAB_1886        ; branch if no nulls

00:88E5  A900              :                 LDA     #$00            ; load [NULL]
                             LAB_1880
00:88E7  20BB88            :                 JSR     LAB_PRNA        ; go print the character
00:88EA  CA                :                 DEX                     ; decrement count
00:88EB  D0FA              :                 BNE     LAB_1880        ; loop if not all done

00:88ED  A90D              :                 LDA     #$0D            ; restore the character (and set the flags)
                             LAB_1886
00:88EF  8607              :                 STX     TPos            ; clear terminal position (X always = zero when we get here)
00:88F1  A62A              :                 LDX     TempB           ; restore buffer index
                             LAB_188A
00:88F3  29FF              :                 AND     #$FF            ; set the flags
                             LAB_188C
00:88F5  60                :                 RTS

                             ; handle bad input data

                             LAB_1904
00:88F6  A514              :                 LDA     Imode           ; get input mode flag, $00=INPUT, $00=READ
00:88F8  100B              :                 BPL     LAB_1913        ; branch if INPUT (go do redo)

00:88FA  A53F              :                 LDA     Dlinel          ; get current DATA line low byte
00:88FC  A440              :                 LDY     Dlineh          ; get current DATA line high byte
00:88FE  8539              :                 STA     Clinel          ; save current line low byte
00:8900  843A              :                 STY     Clineh          ; save current line high byte
                             LAB_1910
00:8902  4CC88B            :                 JMP     LAB_SNER        ; do syntax error then warm start

                             ; mode was INPUT
                             LAB_1913
00:8905  A9BC              :                 LDA     #<LAB_REDO      ; point to redo message (low addr)
00:8907  A0A6              :                 LDY     #>LAB_REDO      ; point to redo message (high addr)
00:8909  20A088            :                 JSR     LAB_18C3        ; print null terminated string from memory
00:890C  A53D              :                 LDA     Cpntrl          ; get continue pointer low byte
00:890E  A43E              :                 LDY     Cpntrh          ; get continue pointer high byte
00:8910  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:8912  846F              :                 STY     Bpntrh          ; save BASIC execute pointer high byte
00:8914  60                :                 RTS

                             ; perform INPUT

                             LAB_INPUT
00:8915  C922              :                 CMP     #$22            ; compare next byte with open quote

Portable 65xx Assembler [20.01]

00:8917  D00B              :                 BNE     LAB_1934        ; branch if no prompt string

00:8919  20868B            :                 JSR     LAB_1BC1        ; print "..." string
00:891C  A93B              :                 LDA     #$3B            ; load A with ";"
00:891E  20B98B            :                 JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
00:8921  20A388            :                 JSR     LAB_18C6        ; print string from Sutill/Sutilh

                             ; done with prompt, now get data
                             LAB_1934
00:8924  202790            :                 JSR     LAB_CKRN        ; check not Direct, back here if ok
00:8927  203182            :                 JSR     LAB_INLN        ; print "? " and get BASIC input
00:892A  A900              :                 LDA     #$00            ; set mode = INPUT
00:892C  CD0004            :                 CMP     Ibuffs          ; test first byte in buffer
00:892F  D009              :                 BNE     LAB_1953        ; branch if not null input
00:8931  4C1685            :                 JMP     LAB_1647        ; go do BREAK exit

                             ; perform READ

                             LAB_READ
00:8934  A641              :                 LDX     Dptrl           ; get DATA pointer low byte
00:8936  A442              :                 LDY     Dptrh           ; get DATA pointer high byte
00:8938  A980              :                 LDA     #$80            ; set mode = READ

                             LAB_1953
00:893A  8514              :                 STA     Imode           ; set input mode flag, $00=INPUT, $80=READ
00:893C  8643              :                 STX     Rdptrl          ; save READ pointer low byte
00:893E  8444              :                 STY     Rdptrh          ; save READ pointer high byte

                             ; READ or INPUT next variable from list
                             LAB_195B
00:8940  206A8D            :                 JSR     LAB_GVAR        ; get (var) address
00:8943  8549              :                 STA     Lvarpl          ; save address low byte
00:8945  844A              :                 STY     Lvarph          ; save address high byte
00:8947  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:8949  A46F              :                 LDY     Bpntrh          ; get BASIC execute pointer high byte
00:894B  850A              :                 STA     Itempl          ; save as temporary integer low byte
00:894D  840B              :                 STY     Itemph          ; save as temporary integer high byte
00:894F  A643              :                 LDX     Rdptrl          ; get READ pointer low byte
00:8951  A444              :                 LDY     Rdptrh          ; get READ pointer high byte
00:8953  866E              :                 STX     Bpntrl          ; set BASIC execute pointer low byte
00:8955  846F              :                 STY     Bpntrh          ; set BASIC execute pointer high byte
00:8957  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:895A  D011              :                 BNE     LAB_1988        ; branch if not null

                             ; pointer was to null entry
00:895C  2414              :                 BIT     Imode           ; test input mode flag, $00=INPUT, $80=READ
00:895E  3064              :                 BMI     LAB_19DD        ; branch if READ

                             ; mode was INPUT
00:8960  20B988            :                 JSR     LAB_18E3        ; print "?" character (double ? for extended input)
00:8963  203182            :                 JSR     LAB_INLN        ; print "? " and get BASIC input
00:8966  866E              :                 STX     Bpntrl          ; set BASIC execute pointer low byte
00:8968  846F              :                 STY     Bpntrh          ; set BASIC execute pointer high byte
                             LAB_1985

Portable 65xx Assembler [20.01]

00:896A  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
                             LAB_1988
00:896D  2411              :                 BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
00:896F  1023              :                 BPL     LAB_19B0        ; branch if numeric

                             ; else get string
00:8971  850D              :                 STA     Srchc           ; save search character
00:8973  C922              :                 CMP     #$22            ; was it " ?
00:8975  F007              :                 BEQ     LAB_1999        ; branch if so

00:8977  A93A              :                 LDA     #':'            ; else search character is ":"
00:8979  850D              :                 STA     Srchc           ; set new search character
00:897B  A92C              :                 LDA     #','            ; other search character is ","
00:897D  18                :                 CLC                     ; clear carry for add
                             LAB_1999
00:897E  850E              :                 STA     Asrch           ; set second search character
00:8980  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:8982  A46F              :                 LDY     Bpntrh          ; get BASIC execute pointer high byte

00:8984  6900              :                 ADC     #$00            ; c is =1 if we came via the BEQ LAB_1999, else =0
00:8986  9001              :                 BCC     LAB_19A4        ; branch if no execute pointer low byte rollover

00:8988  C8                :                 INY                     ; else increment high byte
                             LAB_19A4
00:8989  200591            :                 JSR     LAB_20B4        ; print Srchc or Asrch terminated string to Sutill/Sutilh
00:898C  207D94            :                 JSR     LAB_23F3        ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00:898F  20A587            :                 JSR     LAB_17D5        ; go do string LET
00:8992  8006              :                 BRA     LAB_19B6        ; go check string terminator

                             ; get numeric INPUT
                             LAB_19B0
00:8994  204799            :                 JSR     LAB_2887        ; get FAC1 from string
00:8997  204998            :                 JSR     LAB_PFAC        ; pack FAC1 into (Lvarpl)
                             LAB_19B6
00:899A  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:899D  F00A              :                 BEQ     LAB_19C5        ; branch if null (last entry)

00:899F  C92C              :                 CMP     #','            ; else compare with ","
00:89A1  F003              :                 BEQ     LAB_19C2        ; branch if ","

00:89A3  4CF688            :                 JMP     LAB_1904        ; else go handle bad input data

                             ; got good input data
                             LAB_19C2
00:89A6  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
                             LAB_19C5
00:89A9  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
00:89AB  A46F              :                 LDY     Bpntrh          ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00:89AD  8543              :                 STA     Rdptrl          ; save for now
00:89AF  8444              :                 STY     Rdptrh          ; save for now
00:89B1  A50A              :                 LDA     Itempl          ; get temporary integer low byte (temp BASIC execute ptr)
00:89B3  A40B              :                 LDY     Itemph          ; get temporary integer high byte (temp BASIC execute ptr)
00:89B5  856E              :                 STA     Bpntrl          ; set BASIC execute pointer low byte
00:89B7  846F              :                 STY     Bpntrh          ; set BASIC execute pointer high byte

Portable 65xx Assembler [20.01]

00:89B9  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:89BC  F02C              :                 BEQ     LAB_1A03        ; if null go do extra ignored message

00:89BE  20C48B            :                 JSR     LAB_1C01        ; else scan for "," , else do syntax error then warm start
00:89C1  4C4089            :                 JMP     LAB_195B        ; go INPUT next variable from list

                             ; find next DATA statement or do "Out of DATA" error
                             LAB_19DD
00:89C4  207F86            :                 JSR     LAB_SNBS        ; scan for next BASIC statement ([:] or [EOL])
00:89C7  C8                :                 INY                     ; increment index
00:89C8  AA                :                 TAX                     ; copy character ([:] or [EOL])
00:89C9  D012              :                 BNE     LAB_19F6        ; branch if [:]

00:89CB  A206              :                 LDX     #$06            ; set for "Out of DATA" error
00:89CD  C8                :                 INY                     ; increment index, now points to next line pointer high byte
00:89CE  B16E              :                 LDA     (Bpntrl),Y      ; get next line pointer high byte
00:89D0  F071              :                 BEQ     LAB_1A54        ; branch if end (eventually does error X)

00:89D2  C8                :                 INY                     ; increment index
00:89D3  B16E              :                 LDA     (Bpntrl),Y      ; get next line # low byte
00:89D5  853F              :                 STA     Dlinel          ; save current DATA line low byte
00:89D7  C8                :                 INY                     ; increment index
00:89D8  B16E              :                 LDA     (Bpntrl),Y      ; get next line # high byte
00:89DA  C8                :                 INY                     ; increment index
00:89DB  8540              :                 STA     Dlineh          ; save current DATA line high byte
                             LAB_19F6
00:89DD  B16E              :                 LDA     (Bpntrl),Y      ; get byte
00:89DF  C8                :                 INY                     ; increment index
00:89E0  AA                :                 TAX                     ; copy to X
00:89E1  207186            :                 JSR     LAB_170F        ; set BASIC execute pointer
00:89E4  E083              :                 CPX     #TK_DATA        ; compare with "DATA" token
00:89E6  F082              :                 BEQ     LAB_1985        ; was "DATA" so go do next READ

00:89E8  D0DA              :                 BNE     LAB_19DD        ; go find next statement if not "DATA"

                             ; end of INPUT/READ routine

                             LAB_1A03
00:89EA  A543              :                 LDA     Rdptrl          ; get temp READ pointer low byte
00:89EC  A444              :                 LDY     Rdptrh          ; get temp READ pointer high byte
00:89EE  A614              :                 LDX     Imode           ; get input mode flag, $00=INPUT, $80=READ
00:89F0  1003              :                 BPL     LAB_1A0E        ; branch if INPUT
00:89F2  4C3885            :                 JMP     LAB_1624        ; save AY as DATA pointer and return

                             ; we were getting INPUT
                             LAB_1A0E
00:89F5  B243              :                 LDA     (Rdptrl)        ; get next byte
00:89F7  D001              :                 BNE     LAB_1A1B        ; error if not end of INPUT
00:89F9  60                :                 RTS

                             ; user typed too much
                             LAB_1A1B
00:89FA  A9AB              :                 LDA     #<LAB_IMSG      ; point to extra ignored message (low addr)
00:89FC  A0A6              :                 LDY     #>LAB_IMSG      ; point to extra ignored message (high addr)

Portable 65xx Assembler [20.01]

00:89FE  4CA088            :                 JMP     LAB_18C3        ; print null terminated string from memory and return

                             ; search the stack for FOR activity
                             ; exit with z=1 if FOR else exit with z=0

                             LAB_11A1
00:8A01  BA                :                 TSX                     ; copy stack pointer
00:8A02  E8                :                 INX                     ; +1 pass return address
00:8A03  E8                :                 INX                     ; +2 pass return address
00:8A04  E8                :                 INX                     ; +3 pass calling routine return address
00:8A05  E8                :                 INX                     ; +4 pass calling routine return address
                             LAB_11A6
00:8A06  BD0101            :                 LDA     LAB_STAK+1,X    ; get token byte from stack
00:8A09  C981              :                 CMP     #TK_FOR         ; is it FOR token
00:8A0B  D021              :                 BNE     LAB_11CE        ; exit if not FOR token

                             ; was FOR token
00:8A0D  A54A              :                 LDA     Frnxth          ; get var pointer for FOR/NEXT high byte
00:8A0F  D00A              :                 BNE     LAB_11BB        ; branch if not null

00:8A11  BD0201            :                 LDA     LAB_STAK+2,X    ; get FOR variable pointer low byte
00:8A14  8549              :                 STA     Frnxtl          ; save var pointer for FOR/NEXT low byte
00:8A16  BD0301            :                 LDA     LAB_STAK+3,X    ; get FOR variable pointer high byte
00:8A19  854A              :                 STA     Frnxth          ; save var pointer for FOR/NEXT high byte
                             LAB_11BB
00:8A1B  DD0301            :                 CMP     LAB_STAK+3,X    ; compare var pointer with stacked var pointer (high byte)
00:8A1E  D007              :                 BNE     LAB_11C7        ; branch if no match

00:8A20  A549              :                 LDA     Frnxtl          ; get var pointer for FOR/NEXT low byte
00:8A22  DD0201            :                 CMP     LAB_STAK+2,X    ; compare var pointer with stacked var pointer (low byte)
00:8A25  F007              :                 BEQ     LAB_11CE        ; exit if match found

                             LAB_11C7
00:8A27  8A                :                 TXA                     ; copy index
00:8A28  18                :                 CLC                     ; clear carry for add
00:8A29  6910              :                 ADC     #$10            ; add FOR stack use size
00:8A2B  AA                :                 TAX                     ; copy back to index
00:8A2C  D0D8              :                 BNE     LAB_11A6        ; loop if not at start of stack

                             LAB_11CE
00:8A2E  60                :                 RTS

                             ; perform NEXT

                             LAB_NEXT
00:8A2F  D004              :                 BNE     LAB_1A46        ; branch if NEXT var

00:8A31  A000              :                 LDY     #$00            ; else clear Y
00:8A33  8003              :                 BRA     LAB_1A49        ; branch always (no variable to search for)

                             ; NEXT var

                             LAB_1A46
00:8A35  206A8D            :                 JSR     LAB_GVAR        ; get variable address

Portable 65xx Assembler [20.01]

                             LAB_1A49
00:8A38  8549              :                 STA     Frnxtl          ; store variable pointer low byte
00:8A3A  844A              :                 STY     Frnxth          ; store variable pointer high byte
                             ; (both cleared if no variable defined)
00:8A3C  20018A            :                 JSR     LAB_11A1        ; search the stack for FOR activity
00:8A3F  F004              :                 BEQ     LAB_1A56        ; branch if found

00:8A41  A200              :                 LDX     #$00            ; else set error $00 ("NEXT without FOR" error)
                             LAB_1A54
00:8A43  F064              :                 BEQ     LAB_1ABE        ; do error #X, then warm start

                             LAB_1A56
00:8A45  9A                :                 TXS                     ; set stack pointer, X set by search, dumps return addresses

00:8A46  8A                :                 TXA                     ; copy stack pointer
00:8A47  38                :                 SEC                     ; set carry for subtract
00:8A48  E9F7              :                 SBC     #$F7            ; point to TO var
00:8A4A  8525              :                 STA     ut2_pl          ; save pointer to TO var for compare
00:8A4C  69FB              :                 ADC     #$FB            ; point to STEP var

00:8A4E  A001              :                 LDY     #>LAB_STAK      ; point to stack page high byte
00:8A50  202398            :                 JSR     LAB_UFAC        ; unpack memory (STEP value) into FAC1
00:8A53  BA                :                 TSX                     ; get stack pointer back
00:8A54  BD0801            :                 LDA     LAB_STAK+8,X    ; get step sign
00:8A57  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
00:8A59  A549              :                 LDA     Frnxtl          ; get FOR variable pointer low byte
00:8A5B  A44A              :                 LDY     Frnxth          ; get FOR variable pointer high byte
00:8A5D  206B95            :                 JSR     LAB_246C        ; add (FOR variable) to FAC1
00:8A60  204998            :                 JSR     LAB_PFAC        ; pack FAC1 into (FOR variable)
00:8A63  A001              :                 LDY     #>LAB_STAK      ; point to stack page high byte
00:8A65  20BB98            :                 JSR     LAB_27FA        ; compare FAC1 with (Y,ut2_pl) (TO value)
00:8A68  BA                :                 TSX                     ; get stack pointer back
00:8A69  DD0801            :                 CMP     LAB_STAK+8,X    ; compare step sign
00:8A6C  F017              :                 BEQ     LAB_1A9B        ; branch if = (loop complete)

                             ; loop back and do it all again
00:8A6E  BD0D01            :                 LDA     LAB_STAK+$0D,X  ; get FOR line low byte
00:8A71  8539              :                 STA     Clinel          ; save current line low byte
00:8A73  BD0E01            :                 LDA     LAB_STAK+$0E,X  ; get FOR line high byte
00:8A76  853A              :                 STA     Clineh          ; save current line high byte
00:8A78  BD1001            :                 LDA     LAB_STAK+$10,X  ; get BASIC execute pointer low byte
00:8A7B  856E              :                 STA     Bpntrl          ; save BASIC execute pointer low byte
00:8A7D  BD0F01            :                 LDA     LAB_STAK+$0F,X  ; get BASIC execute pointer high byte
00:8A80  856F              :                 STA     Bpntrh          ; save BASIC execute pointer high byte
                             LAB_1A98
00:8A82  4CB184            :                 JMP     LAB_15C2        ; go do interpreter inner loop

                             ; loop complete so carry on
                             LAB_1A9B
00:8A85  8A                :                 TXA                     ; stack copy to A
00:8A86  690F              :                 ADC     #$0F            ; add $10 ($0F+carry) to dump FOR structure
00:8A88  AA                :                 TAX                     ; copy back to index
00:8A89  9A                :                 TXS                     ; copy to stack pointer
00:8A8A  20DE9F            :                 JSR     LAB_GBYT        ; scan memory

Portable 65xx Assembler [20.01]

00:8A8D  C92C              :                 CMP     #','            ; compare with ","
00:8A8F  D0F1              :                 BNE     LAB_1A98        ; branch if not "," (go do interpreter inner loop)

                             ; was "," so another NEXT variable to do
00:8A91  20D89F            :                 JSR     LAB_IGBY        ; else increment and scan memory
00:8A94  20358A            :                 JSR     LAB_1A46        ; do NEXT (var)

                             ; evaluate expression and check is numeric, else do type mismatch

                             LAB_EVNM
00:8A97  20AC8A            :                 JSR     LAB_EVEX        ; evaluate expression

                             ; check if source is numeric, else do type mismatch

                             LAB_CTNM
00:8A9A  18                :                 CLC                     ; destination is numeric
00:8A9B  8001              :                 BRA     LAB_CKTM        ; branch around next instruction
                             ;      .byte $24               ; makes next line BIT $38

                             ; check if source is string, else do type mismatch

                             LAB_CTST
00:8A9D  38                :                 SEC                     ; required type is string

                             ; type match check, set C for string, clear C for numeric

                             LAB_CKTM
00:8A9E  2411              :                 BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
00:8AA0  3003              :                 BMI     LAB_1ABA        ; branch if data type is string

                             ; else data type was numeric
00:8AA2  B003              :                 BCS     LAB_1ABC        ; if required type is string do type mismatch error
                             LAB_1AB9
00:8AA4  60                :                 RTS

                             ; data type was string, now check required type
                             LAB_1ABA
00:8AA5  B0FD              :                 BCS     LAB_1AB9        ; exit if required type is string

                             ; else do type mismatch error
                             LAB_1ABC
00:8AA7  A218              :                 LDX     #$18            ; error code $18 ("Type mismatch" error)
                             LAB_1ABE
00:8AA9  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; evaluate expression

                             LAB_EVEX
00:8AAC  A66E              :                 LDX     Bpntrl          ; get BASIC execute pointer low byte
00:8AAE  D002              :                 BNE     LAB_1AC7        ; skip next if not zero

00:8AB0  C66F              :                 DEC     Bpntrh          ; else decrement BASIC execute pointer high byte
                             LAB_1AC7
00:8AB2  C66E              :                 DEC     Bpntrl          ; decrement BASIC execute pointer low byte

Portable 65xx Assembler [20.01]


                             LAB_EVEZ
00:8AB4  A900              :                 LDA     #$00            ; set null precedence (flag done)
                             LAB_1ACC
00:8AB6  48                :                 PHA                     ; push precedence byte
00:8AB7  A902              :                 LDA     #$02            ; 2 bytes
00:8AB9  20F880            :                 JSR     LAB_1212        ; check room on stack for A bytes
00:8ABC  20958B            :                 JSR     LAB_GVAL        ; get value from line
00:8ABF  644D              :                 STZ     comp_f          ; clear compare function flag
                             LAB_1ADB
00:8AC1  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
                             LAB_1ADE
00:8AC4  38                :                 SEC                     ; set carry for subtract
00:8AC5  E9BC              :                 SBC     #TK_GT          ; subtract token for > (lowest comparison function)
00:8AC7  9016              :                 BCC     LAB_1AFA        ; branch if < TK_GT

00:8AC9  C903              :                 CMP     #$03            ; compare with ">" to "<" tokens
00:8ACB  B012              :                 BCS     LAB_1AFA        ; branch if >= TK_SGN (highest evaluation function +1)

                             ; was token for > = or < (A = 0, 1 or 2)
00:8ACD  C901              :                 CMP     #$01            ; compare with token for =
00:8ACF  2A                :                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
                             ; (A = 0, 3 or 5)
00:8AD0  4901              :                 EOR     #$01            ; toggle b0
                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
00:8AD2  454D              :                 EOR     comp_f          ; EOR with compare function flag bits
00:8AD4  C54D              :                 CMP     comp_f          ; compare with compare function flag
00:8AD6  9066              :                 BCC     LAB_1B53        ; if <(comp_f) do syntax error then warm start
                             ; was more than one <, = or >)

00:8AD8  854D              :                 STA     comp_f          ; save new compare function flag
00:8ADA  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8ADD  80E5              :                 BRA     LAB_1ADE        ; go do next character

                             ; token is < ">" or > "<" tokens
                             LAB_1AFA
00:8ADF  A64D              :                 LDX     comp_f          ; get compare function flag
00:8AE1  D02C              :                 BNE     LAB_1B2A        ; branch if compare function

00:8AE3  B079              :                 BCS     LAB_1B78        ; go do functions

                             ; else was <  TK_GT so is operator or lower
00:8AE5  690A              :                 ADC     #TK_GT-TK_PLUS  ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
00:8AE7  9075              :                 BCC     LAB_1B78        ; branch if < + operator

                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
00:8AE9  D007              :                 BNE     LAB_1B0B        ; branch if not + token

00:8AEB  2411              :                 BIT     Dtypef          ; test data type flag, $FF=string, $00=numeric
00:8AED  1003              :                 BPL     LAB_1B0B        ; branch if not string

                             ; will only be $00 if type is string and token was +
00:8AEF  4C8E92            :                 JMP     LAB_224D        ; add strings, string 1 is in descriptor des_pl, string 2
                             ; is in line, and return

Portable 65xx Assembler [20.01]


                             LAB_1B0B
00:8AF2  8523              :                 STA     ut1_pl          ; save it
00:8AF4  0A                :                 ASL                     ; *2
00:8AF5  6523              :                 ADC     ut1_pl          ; *3
00:8AF7  A8                :                 TAY                     ; copy to index
                             LAB_1B13
00:8AF8  68                :                 PLA                     ; pull previous precedence
00:8AF9  D9B4A1            :                 CMP     LAB_OPPT,Y      ; compare with precedence byte
00:8AFC  B065              :                 BCS     LAB_1B7D        ; branch if A >=

00:8AFE  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
                             LAB_1B1C
00:8B01  48                :                 PHA                     ; save precedence
                             LAB_1B1D
00:8B02  202A8B            :                 JSR     LAB_1B43        ; get vector, execute function then continue evaluation
00:8B05  68                :                 PLA                     ; restore precedence
00:8B06  A44B              :                 LDY     prstk           ; get precedence stacked flag
00:8B08  1019              :                 BPL     LAB_1B3C        ; branch if stacked values

00:8B0A  AA                :                 TAX                     ; copy precedence (set flags)
00:8B0B  F076              :                 BEQ     LAB_1B9D        ; exit if done

00:8B0D  805D              :                 BRA     LAB_1B86        ; else pop FAC2 and return, branch always

                             LAB_1B2A
00:8B0F  2611              :                 ROL     Dtypef          ; shift data type flag into Cb
00:8B11  8A                :                 TXA                     ; copy compare function flag
00:8B12  8511              :                 STA     Dtypef          ; clear data type flag, X is 0xxx xxxx
00:8B14  2A                :                 ROL                     ; shift data type into compare function byte b0
00:8B15  A66E              :                 LDX     Bpntrl          ; get BASIC execute pointer low byte
00:8B17  D002              :                 BNE     LAB_1B34        ; branch if no underflow

00:8B19  C66F              :                 DEC     Bpntrh          ; else decrement BASIC execute pointer high byte
                             LAB_1B34
00:8B1B  C66E              :                 DEC     Bpntrl          ; decrement BASIC execute pointer low byte
         0000000C          = TK_LT_PLUS      .EQU    TK_LT-TK_PLUS
00:8B1D  A024              :                 LDY     #TK_LT_PLUS*3   ; set offset to last operator entry
00:8B1F  854D              :                 STA     comp_f          ; save new compare function flag
00:8B21  80D5              :                 BRA     LAB_1B13        ; branch always

                             LAB_1B3C
00:8B23  D9B4A1            :                 CMP     LAB_OPPT,Y      ; compare with stacked function precedence
00:8B26  B044              :                 BCS     LAB_1B86        ; branch if A >=, pop FAC2 and return

00:8B28  80D7              :                 BRA     LAB_1B1C        ; branch always

                             ;.get vector, execute function then continue evaluation

                             LAB_1B43
00:8B2A  B9B6A1            :                 LDA     LAB_OPPT+2,Y    ; get function vector high byte
00:8B2D  48                :                 PHA                     ; onto stack
00:8B2E  B9B5A1            :                 LDA     LAB_OPPT+1,Y    ; get function vector low byte
00:8B31  48                :                 PHA                     ; onto stack

Portable 65xx Assembler [20.01]

                             ; now push sign, round FAC1 and put on stack
00:8B32  20418B            :                 JSR     LAB_1B5B        ; function will return here, then the next RTS will call
                             ; the function
00:8B35  A54D              :                 LDA     comp_f          ; get compare function flag
00:8B37  48                :                 PHA                     ; push compare evaluation byte
00:8B38  B9B4A1            :                 LDA     LAB_OPPT,Y      ; get precedence byte
00:8B3B  4CB68A            :                 JMP     LAB_1ACC        ; continue evaluating expression

                             LAB_1B53
00:8B3E  4CC88B            :                 JMP     LAB_SNER        ; do syntax error then warm start

                             ; push sign, round FAC1 and put on stack

                             LAB_1B5B
00:8B41  68                :                 PLA                     ; get return addr low byte
00:8B42  8523              :                 STA     ut1_pl          ; save it
00:8B44  E623              :                 INC     ut1_pl          ; increment it (was ret-1 pushed? yes!)
                             ; note! no check is made on the high byte! if the calling
                             ; routine assembles to a page edge then this all goes
                             ; horribly wrong !!!
00:8B46  68                :                 PLA                     ; get return addr high byte
00:8B47  8524              :                 STA     ut1_ph          ; save it
00:8B49  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:8B4B  48                :                 PHA                     ; push sign

                             ; round FAC1 and put on stack

                             LAB_1B66
00:8B4C  207F98            :                 JSR     LAB_27BA        ; round FAC1
00:8B4F  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:8B51  48                :                 PHA                     ; push on stack
00:8B52  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:8B54  48                :                 PHA                     ; push on stack
00:8B55  A55F              :                 LDA     FAC1_1          ; get FAC1 mantissa1
00:8B57  48                :                 PHA                     ; push on stack
00:8B58  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:8B5A  48                :                 PHA                     ; push on stack
00:8B5B  6C2300            :                 JMP     (ut1_pl)        ; return, sort of

                             ; do functions

                             LAB_1B78
00:8B5E  A0FF              :                 LDY     #$FF            ; flag function
00:8B60  68                :                 PLA                     ; pull precedence byte
                             LAB_1B7B
00:8B61  F020              :                 BEQ     LAB_1B9D        ; exit if done

                             LAB_1B7D
00:8B63  C964              :                 CMP     #$64            ; compare previous precedence with $64
00:8B65  F003              :                 BEQ     LAB_1B84        ; branch if was $64 (< function)

00:8B67  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
                             LAB_1B84
00:8B6A  844B              :                 STY     prstk           ; save precedence stacked flag

Portable 65xx Assembler [20.01]


                             ; pop FAC2 and return
                             LAB_1B86
00:8B6C  68                :                 PLA                     ; pop byte
00:8B6D  4A                :                 LSR                     ; shift out comparison evaluation lowest bit
00:8B6E  8515              :                 STA     Cflag           ; save comparison evaluation flag
00:8B70  68                :                 PLA                     ; pop exponent
00:8B71  8565              :                 STA     FAC2_e          ; save FAC2 exponent
00:8B73  68                :                 PLA                     ; pop mantissa1
00:8B74  8566              :                 STA     FAC2_1          ; save FAC2 mantissa1
00:8B76  68                :                 PLA                     ; pop mantissa2
00:8B77  8567              :                 STA     FAC2_2          ; save FAC2 mantissa2
00:8B79  68                :                 PLA                     ; pop mantissa3
00:8B7A  8568              :                 STA     FAC2_3          ; save FAC2 mantissa3
00:8B7C  68                :                 PLA                     ; pop sign
00:8B7D  8569              :                 STA     FAC2_s          ; save FAC2 sign (b7)
00:8B7F  4562              :                 EOR     FAC1_s          ; EOR FAC1 sign (b7)
00:8B81  856A              :                 STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
                             LAB_1B9D
00:8B83  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:8B85  60                :                 RTS

                             ; print "..." string to string util area

                             LAB_1BC1
00:8B86  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:8B88  A46F              :                 LDY     Bpntrh          ; get BASIC execute pointer high byte
00:8B8A  6900              :                 ADC     #$00            ; add carry to low byte
00:8B8C  9001              :                 BCC     LAB_1BCA        ; branch if no overflow

00:8B8E  C8                :                 INY                     ; increment high byte
                             LAB_1BCA
00:8B8F  20FF90            :                 JSR     LAB_20AE        ; print " terminated string to Sutill/Sutilh
00:8B92  4C7D94            :                 JMP     LAB_23F3        ; restore BASIC execute pointer from temp and return

                             ; get value from line

                             LAB_GVAL
00:8B95  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8B98  B003              :                 BCS     LAB_1BAC        ; branch if not numeric character

                             ; else numeric string found (e.g. 123)
                             LAB_1BA9
00:8B9A  4C4799            :                 JMP     LAB_2887        ; get FAC1 from string and return

                             ; get value from line .. continued

                             ; wasn't a number so ..
                             LAB_1BAC
00:8B9D  AA                :                 TAX                     ; set the flags
00:8B9E  302D              :                 BMI     LAB_1BD0        ; if -ve go test token values

                             ; else it is either a string, number, variable or (<expr>)
00:8BA0  C924              :                 CMP     #'$'            ; compare with "$"

Portable 65xx Assembler [20.01]

00:8BA2  F0F6              :                 BEQ     LAB_1BA9        ; branch if "$", hex number

00:8BA4  C925              :                 CMP     #'%'            ; else compare with "%"
00:8BA6  F0F2              :                 BEQ     LAB_1BA9        ; branch if "%", binary number

00:8BA8  C92E              :                 CMP     #'.'            ; compare with "."
00:8BAA  F0EE              :                 BEQ     LAB_1BA9        ; if so get FAC1 from string and return (e.g. was .123)

                             ; it wasn't any sort of number so ..
00:8BAC  C922              :                 CMP     #$22            ; compare with "
00:8BAE  F0D6              :                 BEQ     LAB_1BC1        ; branch if open quote

                             ; wasn't any sort of number so ..

                             ; evaluate expression within parentheses

00:8BB0  C928              :                 CMP     #'('            ; compare with "("
00:8BB2  D04C              :                 BNE     LAB_1C18        ; if not "(" get (var), return value in FAC1 and $ flag

                             LAB_1BF7
00:8BB4  20B48A            :                 JSR     LAB_EVEZ        ; evaluate expression, no decrement

                             ; all the 'scan for' routines return the character after the sought character

                             ; scan for ")" , else do syntax error then warm start

                             LAB_1BFB
00:8BB7  A929              :                 LDA     #$29            ; load A with ")"

                             ; scan for CHR$(A) , else do syntax error then warm start

                             LAB_SCCA
00:8BB9  D26E              :                 CMP     (Bpntrl)        ; check next byte is = A
00:8BBB  D00B              :                 BNE     LAB_SNER        ; if not do syntax error then warm start

00:8BBD  4CD89F            :                 JMP     LAB_IGBY        ; increment and scan memory then return

                             ; scan for "(" , else do syntax error then warm start

                             LAB_1BFE
00:8BC0  A928              :                 LDA     #$28            ; load A with "("
00:8BC2  80F5              :                 BRA     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
                             ; (branch always)

                             ; scan for "," , else do syntax error then warm start

                             LAB_1C01
00:8BC4  A92C              :                 LDA     #$2C            ; load A with ","
00:8BC6  80F1              :                 BRA     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
                             ; (branch always)

                             ; syntax error then warm start

                             LAB_SNER

Portable 65xx Assembler [20.01]

00:8BC8  A202              :                 LDX     #$02            ; error code $02 ("Syntax" error)
00:8BCA  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; get value from line .. continued
                             ; do tokens

                             LAB_1BD0
00:8BCD  C9B3              :                 CMP     #TK_MINUS       ; compare with token for -
00:8BCF  F028              :                 BEQ     LAB_1C11        ; branch if - token (do set-up for functions)

                             ; wasn't -n so ..
00:8BD1  C9B2              :                 CMP     #TK_PLUS        ; compare with token for +
00:8BD3  F0C0              :                 BEQ     LAB_GVAL        ; branch if + token (+n = n so ignore leading +)

00:8BD5  C9AE              :                 CMP     #TK_NOT         ; compare with token for NOT
00:8BD7  D013              :                 BNE     LAB_1BE7        ; branch if not token for NOT

                             ; was NOT token
         0000000B          = TK_EQUAL_PLUS   .EQU    TK_EQUAL-TK_PLUS
00:8BD9  A021              :                 LDY     #TK_EQUAL_PLUS*3 ; offset to NOT function
00:8BDB  801E              :                 BRA     LAB_1C13        ; do set-up for function then execute (branch always)

                             ; do = compare

                             LAB_EQUAL
00:8BDD  20648E            :                 JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
00:8BE0  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:8BE2  49FF              :                 EOR     #$FF            ; invert it
00:8BE4  A8                :                 TAY                     ; copy it
00:8BE5  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:8BE7  49FF              :                 EOR     #$FF            ; invert it
00:8BE9  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; get value from line .. continued

                             ; wasn't +, -, or NOT so ..
                             LAB_1BE7
00:8BEC  C9AB              :                 CMP     #TK_FN          ; compare with token for FN
00:8BEE  D003              :                 BNE     LAB_1BEE        ; branch if not token for FN

00:8BF0  4C7090            :                 JMP     LAB_201E        ; go evaluate FNx

                             ; get value from line .. continued

                             ; wasn't +, -, NOT or FN so ..
                             LAB_1BEE
00:8BF3  E9BF              :                 SBC     #TK_SGN         ; subtract with token for SGN
00:8BF5  B018              :                 BCS     LAB_1C27        ; if a function token go do it

00:8BF7  80CF              :                 BRA     LAB_SNER        ; else do syntax error

                             ; set-up for functions

                             LAB_1C11

Portable 65xx Assembler [20.01]

         0000000A          = TK_GT_PLUS      .EQU    TK_GT-TK_PLUS
00:8BF9  A01E              :                 LDY     #TK_GT_PLUS*3   ; set offset from base to > operator
                             LAB_1C13
00:8BFB  68                :                 PLA                     ; dump return address low byte
00:8BFC  68                :                 PLA                     ; dump return address high byte
00:8BFD  4C028B            :                 JMP     LAB_1B1D        ; execute function then continue evaluation

                             ; variable name set-up
                             ; get (var), return value in FAC_1 and $ flag

                             LAB_1C18
00:8C00  206A8D            :                 JSR     LAB_GVAR        ; get (var) address
00:8C03  8560              :                 STA     FAC1_2          ; save address low byte in FAC1 mantissa2
00:8C05  8461              :                 STY     FAC1_3          ; save address high byte in FAC1 mantissa3
00:8C07  A611              :                 LDX     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:8C09  3003              :                 BMI     LAB_1C25        ; if string then return (does RTS)

                             LAB_1C24
00:8C0B  4C2398            :                 JMP     LAB_UFAC        ; unpack memory (AY) into FAC1

                             LAB_1C25
00:8C0E  60                :                 RTS

                             ; get value from line .. continued
                             ; only functions left so ..

                             ; set up function references

                             ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
                             ; to process function calls. now the function vector is computed and pushed on the stack
                             ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
                             ; is calculated and the routine called, if not this routine just does RTS. whichever
                             ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
                             ; the function code

                             ; this also removes some less than elegant code that was used to bypass type checking
                             ; for functions that returned strings

                             LAB_1C27
00:8C0F  0A                :                 ASL                     ; *2 (2 bytes per function address)
00:8C10  A8                :                 TAY                     ; copy to index

00:8C11  B96FA1            :                 LDA     LAB_FTBM,Y      ; get function jump vector high byte
00:8C14  48                :                 PHA                     ; push functions jump vector high byte
00:8C15  B96EA1            :                 LDA     LAB_FTBL,Y      ; get function jump vector low byte
00:8C18  48                :                 PHA                     ; push functions jump vector low byte

00:8C19  B929A1            :                 LDA     LAB_FTPM,Y      ; get function pre process vector high byte
00:8C1C  F005              :                 BEQ     LAB_1C56        ; skip pre process if null vector

00:8C1E  48                :                 PHA                     ; push functions pre process vector high byte
00:8C1F  B928A1            :                 LDA     LAB_FTPL,Y      ; get function pre process vector low byte
00:8C22  48                :                 PHA                     ; push functions pre process vector low byte


Portable 65xx Assembler [20.01]

                             LAB_1C56
00:8C23  60                :                 RTS                     ; do function, or pre process, call

                             ; process string expression in parenthesis

                             LAB_PPFS
00:8C24  20B48B            :                 JSR     LAB_1BF7        ; process expression in parenthesis
00:8C27  4C9D8A            :                 JMP     LAB_CTST        ; check if source is string then do function,
                             ; else do type mismatch

                             ; process numeric expression in parenthesis

                             LAB_PPFN
00:8C2A  20B48B            :                 JSR     LAB_1BF7        ; process expression in parenthesis
00:8C2D  4C9A8A            :                 JMP     LAB_CTNM        ; check if source is numeric then do function,
                             ; else do type mismatch

                             ; set numeric data type and increment BASIC execute pointer

                             LAB_PPBI
00:8C30  4611              :                 LSR     Dtypef          ; clear data type flag, $FF=string, $00=numeric
00:8C32  4CD89F            :                 JMP     LAB_IGBY        ; increment and scan memory then do function

                             ; process string for LEFT$, RIGHT$ or MID$

                             LAB_LRMS
00:8C35  20B48A            :                 JSR     LAB_EVEZ        ; evaluate (should be string) expression
00:8C38  20C48B            :                 JSR     LAB_1C01        ; scan for ",", else do syntax error then warm start
00:8C3B  209D8A            :                 JSR     LAB_CTST        ; check if source is string, else do type mismatch
00:8C3E  FA                :                 PLX                     ; get function jump vector low byte
00:8C3F  7A                :                 PLY                     ; get function jump vector high byte
00:8C40  A561              :                 LDA     des_ph          ; get descriptor pointer high byte
00:8C42  48                :                 PHA                     ; push string pointer high byte
00:8C43  A560              :                 LDA     des_pl          ; get descriptor pointer low byte
00:8C45  48                :                 PHA                     ; push string pointer low byte
00:8C46  5A                :                 PHY                     ; save function jump vector high byte
00:8C47  DA                :                 PHX                     ; save function jump vector low byte
00:8C48  203D94            :                 JSR     LAB_GTBY        ; get byte parameter
00:8C4B  8A                :                 TXA                     ; copy byte parameter to A
00:8C4C  60                :                 RTS                     ; go do function

                             ; process numeric expression(s) for BIN$ or HEX$

                             LAB_BHSS
00:8C4D  20B48A            :                 JSR     LAB_EVEZ        ; process expression
00:8C50  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00:8C53  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:8C55  C998              :                 CMP     #$98            ; compare with exponent = 2^24
00:8C57  B020              :                 BCS     LAB_BHER        ; branch if n>=2^24 (is too big)

00:8C59  20F198            :                 JSR     LAB_2831        ; convert FAC1 floating-to-fixed
00:8C5C  A202              :                 LDX     #$02            ; 3 bytes to do
                             LAB_CFAC
00:8C5E  B55F              :                 LDA     FAC1_1,X        ; get byte from FAC1

Portable 65xx Assembler [20.01]

00:8C60  950A              :                 STA     nums_1,X        ; save byte to temp
00:8C62  CA                :                 DEX                     ; decrement index
00:8C63  10F9              :                 BPL     LAB_CFAC        ; copy FAC1 mantissa to temp

00:8C65  20DE9F            :                 JSR     LAB_GBYT        ; get next BASIC byte
00:8C68  A200              :                 LDX     #$00            ; set default to no leading "0"s
00:8C6A  C929              :                 CMP     #')'            ; compare with close bracket
00:8C6C  F00A              :                 BEQ     LAB_1C54        ; if ")" go do rest of function

00:8C6E  208C94            :                 JSR     LAB_SCGB        ; scan for "," and get byte
00:8C71  20DE9F            :                 JSR     LAB_GBYT        ; get last byte back
00:8C74  C929              :                 CMP     #')'            ; is next character )
00:8C76  D001              :                 BNE     LAB_BHER        ; if not ")" go do error

                             LAB_1C54
00:8C78  60                :                 RTS                     ; else do function

                             LAB_BHER
00:8C79  4CE68E            :                 JMP     LAB_FCER        ; do function call error then warm start

                             ; perform EOR

                             ; added operator format is the same as AND or OR, precedence is the same as OR

                             ; this bit worked first time but it took a while to sort out the operator table
                             ; pointers and offsets afterwards!

                             LAB_EOR
00:8C7C  20A38C            :                 JSR     GetFirst        ; get first integer expression (no sign check)
00:8C7F  450D              :                 EOR     XOAw_l          ; EOR with expression 1 low byte
00:8C81  A8                :                 TAY                     ; save in Y
00:8C82  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:8C84  450E              :                 EOR     XOAw_h          ; EOR with expression 1 high byte
00:8C86  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; perform OR

                             LAB_OR
00:8C89  20A38C            :                 JSR     GetFirst        ; get first integer expression (no sign check)
00:8C8C  050D              :                 ORA     XOAw_l          ; OR with expression 1 low byte
00:8C8E  A8                :                 TAY                     ; save in Y
00:8C8F  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:8C91  050E              :                 ORA     XOAw_h          ; OR with expression 1 high byte
00:8C93  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; perform AND

                             LAB_AND
00:8C96  20A38C            :                 JSR     GetFirst        ; get first integer expression (no sign check)
00:8C99  250D              :                 AND     XOAw_l          ; AND with expression 1 low byte
00:8C9B  A8                :                 TAY                     ; save in Y
00:8C9C  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:8C9E  250E              :                 AND     XOAw_h          ; AND with expression 1 high byte
00:8CA0  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

Portable 65xx Assembler [20.01]


                             ; get first value for OR, AND or EOR

                             GetFirst
00:8CA3  20648E            :                 JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
00:8CA6  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:8CA8  850E              :                 STA     XOAw_h          ; save it
00:8CAA  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:8CAC  850D              :                 STA     XOAw_l          ; save it
00:8CAE  207095            :                 JSR     LAB_279B        ; copy FAC2 to FAC1 (get 2nd value in expression)
00:8CB1  20648E            :                 JSR     LAB_EVIR        ; evaluate integer expression (no sign check)
00:8CB4  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
                             LAB_1C95
00:8CB6  60                :                 RTS

                             ; perform comparisons

                             ; do < compare

                             LAB_LTHAN
00:8CB7  209E8A            :                 JSR     LAB_CKTM        ; type match check, set C for string
00:8CBA  B012              :                 BCS     LAB_1CAE        ; branch if string

                             ; do numeric < compare
00:8CBC  A569              :                 LDA     FAC2_s          ; get FAC2 sign (b7)
00:8CBE  097F              :                 ORA     #$7F            ; set all non sign bits
00:8CC0  2566              :                 AND     FAC2_1          ; and FAC2 mantissa1 (AND in sign bit)
00:8CC2  8566              :                 STA     FAC2_1          ; save FAC2 mantissa1
00:8CC4  A965              :                 LDA     #<FAC2_e        ; set pointer low byte to FAC2
00:8CC6  A000              :                 LDY     #>FAC2_e        ; set pointer high byte to FAC2
00:8CC8  20B998            :                 JSR     LAB_27F8        ; compare FAC1 with FAC2 (AY)
00:8CCB  AA                :                 TAX                     ; copy result
00:8CCC  8031              :                 BRA     LAB_1CE1        ; go evaluate result

                             ; do string < compare
                             LAB_1CAE
00:8CCE  4611              :                 LSR     Dtypef          ; clear data type flag, $FF=string, $00=numeric
00:8CD0  C64D              :                 DEC     comp_f          ; clear < bit in compare function flag
00:8CD2  20F692            :                 JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
                             ; space returns with A = length, X=pointer low byte,
                             ; Y=pointer high byte
00:8CD5  855E              :                 STA     str_ln          ; save length
00:8CD7  865F              :                 STX     str_pl          ; save string pointer low byte
00:8CD9  8460              :                 STY     str_ph          ; save string pointer high byte
00:8CDB  A567              :                 LDA     FAC2_2          ; get descriptor pointer low byte
00:8CDD  A468              :                 LDY     FAC2_3          ; get descriptor pointer high byte
00:8CDF  20FA92            :                 JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
                             ; returns with A = length, X=pointer low byte,
                             ; Y=pointer high byte
00:8CE2  8667              :                 STX     FAC2_2          ; save string pointer low byte
00:8CE4  8468              :                 STY     FAC2_3          ; save string pointer high byte
00:8CE6  AA                :                 TAX                     ; copy length
00:8CE7  38                :                 SEC                     ; set carry for subtract
00:8CE8  E55E              :                 SBC     str_ln          ; subtract string 1 length

Portable 65xx Assembler [20.01]

00:8CEA  F008              :                 BEQ     LAB_1CD6        ; branch if str 1 length = string 2 length

00:8CEC  A901              :                 LDA     #$01            ; set str 1 length > string 2 length
00:8CEE  9004              :                 BCC     LAB_1CD6        ; branch if so

00:8CF0  A65E              :                 LDX     str_ln          ; get string 1 length
00:8CF2  A9FF              :                 LDA     #$FF            ; set str 1 length < string 2 length
                             LAB_1CD6
00:8CF4  8562              :                 STA     FAC1_s          ; save length compare
00:8CF6  A0FF              :                 LDY     #$FF            ; set index
00:8CF8  E8                :                 INX                     ; adjust for loop
                             LAB_1CDB
00:8CF9  C8                :                 INY                     ; increment index
00:8CFA  CA                :                 DEX                     ; decrement count
00:8CFB  D007              :                 BNE     LAB_1CE6        ; branch if still bytes to do

00:8CFD  A662              :                 LDX     FAC1_s          ; get length compare back
                             LAB_1CE1
00:8CFF  300F              :                 BMI     LAB_1CF2        ; branch if str 1 < str 2

00:8D01  18                :                 CLC                     ; flag str 1 <= str 2
00:8D02  900C              :                 BCC     LAB_1CF2        ; go evaluate result

                             LAB_1CE6
00:8D04  B167              :                 LDA     (FAC2_2),Y      ; get string 2 byte
00:8D06  D15F              :                 CMP     (FAC1_1),Y      ; compare with string 1 byte
00:8D08  F0EF              :                 BEQ     LAB_1CDB        ; loop if bytes =

00:8D0A  A2FF              :                 LDX     #$FF            ; set str 1 < string 2
00:8D0C  B002              :                 BCS     LAB_1CF2        ; branch if so

00:8D0E  A201              :                 LDX     #$01            ;        set str 1 > string 2
                             LAB_1CF2
00:8D10  E8                :                 INX                     ; x = 0, 1 or 2
00:8D11  8A                :                 TXA                     ; copy to A
00:8D12  2A                :                 ROL                     ; *2 (1, 2 or 4)
00:8D13  2515              :                 AND     Cflag           ; AND with comparison evaluation flag
00:8D15  F002              :                 BEQ     LAB_1CFB        ; branch if 0 (compare is false)

00:8D17  A9FF              :                 LDA     #$FF            ; else set result true
                             LAB_1CFB
00:8D19  4CA098            :                 JMP     LAB_27DB        ; save A as integer byte and return

                             LAB_1CFE
00:8D1C  20C48B            :                 JSR     LAB_1C01        ; scan for ",", else do syntax error then warm start

                             ; perform DIM

                             LAB_DIM
00:8D1F  AA                :                 TAX                     ; copy "DIM" flag to X
00:8D20  206F8D            :                 JSR     LAB_1D10        ; search for variable
00:8D23  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:8D26  D0F4              :                 BNE     LAB_1CFE        ; scan for "," and loop if not null


Portable 65xx Assembler [20.01]

00:8D28  60                :                 RTS

                             ; perform << (left shift)

                             LAB_LSHIFT
00:8D29  205F8D            :                 JSR     GetPair         ; get integer expression and byte (no sign check)
00:8D2C  A560              :                 LDA     FAC1_2          ; get expression high byte
00:8D2E  A62A              :                 LDX     TempB           ; get shift count
00:8D30  F022              :                 BEQ     NoShift         ; branch if zero

00:8D32  E010              :                 CPX     #$10            ; compare bit count with 16d
00:8D34  B023              :                 BCS     TooBig          ; branch if >=

                             Ls_loop
00:8D36  0661              :                 ASL     FAC1_3          ; shift low byte
00:8D38  2A                :                 ROL                     ; shift high byte
00:8D39  CA                :                 DEX                     ; decrement bit count
00:8D3A  D0FA              :                 BNE     Ls_loop         ; loop if shift not complete

00:8D3C  A461              :                 LDY     FAC1_3          ; get expression low byte
00:8D3E  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; perform >> (right shift)

                             LAB_RSHIFT
00:8D41  205F8D            :                 JSR     GetPair         ; get integer expression and byte (no sign check)
00:8D44  A560              :                 LDA     FAC1_2          ; get expression high byte
00:8D46  A62A              :                 LDX     TempB           ; get shift count
00:8D48  F00A              :                 BEQ     NoShift         ; branch if zero

00:8D4A  E010              :                 CPX     #$10            ; compare bit count with 16d
00:8D4C  B00B              :                 BCS     TooBig          ; branch if >=

                             Rs_loop
00:8D4E  4A                :                 LSR                     ; shift high byte
00:8D4F  6661              :                 ROR     FAC1_3          ; shift low byte
00:8D51  CA                :                 DEX                     ; decrement bit count
00:8D52  D0FA              :                 BNE     Rs_loop         ; loop if shift not complete

                             NoShift
00:8D54  A461              :                 LDY     FAC1_3          ; get expression low byte
00:8D56  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             TooBig
00:8D59  A900              :                 LDA     #$00            ; clear high byte
00:8D5B  A8                :                 TAY                     ; copy to low byte
00:8D5C  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             GetPair
00:8D5F  204094            :                 JSR     LAB_EVBY        ; evaluate byte expression, result in X
00:8D62  862A              :                 STX     TempB           ; save it
00:8D64  207095            :                 JSR     LAB_279B        ; copy FAC2 to FAC1 (get 2nd value in expression)
00:8D67  4C648E            :                 JMP     LAB_EVIR        ; evaluate integer expression (no sign check)


Portable 65xx Assembler [20.01]

                             ; search for variable

                             ; return pointer to variable in Cvaral/Cvarah

                             LAB_GVAR
00:8D6A  A200              :                 LDX     #$00            ; set DIM flag = $00
00:8D6C  20DE9F            :                 JSR     LAB_GBYT        ; scan memory (1st character)
                             LAB_1D10
00:8D6F  8610              :                 STX     Defdim          ; save DIM flag
                             LAB_1D12
00:8D71  8545              :                 STA     Varnm1          ; save 1st character
00:8D73  297F              :                 AND     #$7F            ; clear FN flag bit
00:8D75  20DC8D            :                 JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
00:8D78  B003              :                 BCS     LAB_1D1F        ; branch if ok

00:8D7A  4CC88B            :                 JMP     LAB_SNER        ; else syntax error then warm start

                             ; was variable name so ..
                             LAB_1D1F
00:8D7D  A200              :                 LDX     #$00            ; clear 2nd character temp
00:8D7F  8611              :                 STX     Dtypef          ; clear data type flag, $FF=string, $00=numeric
00:8D81  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory (2nd character)
00:8D84  9005              :                 BCC     LAB_1D2D        ; branch if character = "0"-"9" (ok)

                             ; 2nd character wasn't "0" to "9" so ..
00:8D86  20DC8D            :                 JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
00:8D89  900B              :                 BCC     LAB_1D38        ; branch if <"A" or >"Z" (go check if string)

                             LAB_1D2D
00:8D8B  AA                :                 TAX                     ; copy 2nd character

                             ; ignore further (valid) characters in the variable name
                             LAB_1D2E
00:8D8C  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory (3rd character)
00:8D8F  90FB              :                 BCC     LAB_1D2E        ; loop if character = "0"-"9" (ignore)

00:8D91  20DC8D            :                 JSR     LAB_CASC        ; check byte, return C=0 if<"A" or >"Z"
00:8D94  B0F6              :                 BCS     LAB_1D2E        ; loop if character = "A"-"Z" (ignore)

                             ; check if string variable
                             LAB_1D38
00:8D96  C924              :                 CMP     #'$'            ; compare with "$"
00:8D98  D00B              :                 BNE     LAB_1D47        ; branch if not string

                             ; to introduce a new variable type (% suffix for integers say) then this branch
                             ; will need to go to that check and then that branch, if it fails, go to LAB_1D47

                             ; type is string
00:8D9A  A9FF              :                 LDA     #$FF            ; set data type = string
00:8D9C  8511              :                 STA     Dtypef          ; set data type flag, $FF=string, $00=numeric
00:8D9E  8A                :                 TXA                     ; get 2nd character back
00:8D9F  0980              :                 ORA     #$80            ; set top bit (indicate string var)
00:8DA1  AA                :                 TAX                     ; copy back to 2nd character temp
00:8DA2  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory

Portable 65xx Assembler [20.01]


                             ; after we have determined the variable type we need to come back here to determine
                             ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely


                             LAB_1D47                                ; gets here with character after var name in A
00:8DA5  8646              :                 STX     Varnm2          ; save 2nd character
00:8DA7  0513              :                 ORA     Sufnxf          ; or with subscript/FNX flag (or FN name)
00:8DA9  C928              :                 CMP     #'('            ; compare with "("
00:8DAB  D003              :                 BNE     LAB_1D53        ; branch if not "("

00:8DAD  4C768E            :                 JMP     LAB_1E17        ; go find, or make, array

                             ; either find or create var
                             ; var name (1st two characters only!) is in Varnm1,Varnm2

                             ; variable name wasn't var(... so look for plain var
                             LAB_1D53
00:8DB0  6413              :                 STZ     Sufnxf          ; clear subscript/FNX flag
00:8DB2  A52D              :                 LDA     Svarl           ; get start of vars low byte
00:8DB4  A62E              :                 LDX     Svarh           ; get start of vars high byte
00:8DB6  A000              :                 LDY     #$00            ; clear index
                             LAB_1D5D
00:8DB8  865D              :                 STX     Vrschh          ; save search address high byte
                             LAB_1D5F
00:8DBA  855C              :                 STA     Vrschl          ; save search address low byte
00:8DBC  E430              :                 CPX     Sarryh          ; compare high address with var space end
00:8DBE  D004              :                 BNE     LAB_1D69        ; skip next compare if <>

                             ; high addresses were = so compare low addresses
00:8DC0  C52F              :                 CMP     Sarryl          ; compare low address with var space end
00:8DC2  F02C              :                 BEQ     LAB_1D8B        ; if not found go make new var

                             LAB_1D69
00:8DC4  A545              :                 LDA     Varnm1          ; get 1st character of var to find
00:8DC6  D15C              :                 CMP     (Vrschl),Y      ; compare with variable name 1st character
00:8DC8  D008              :                 BNE     LAB_1D77        ; branch if no match

                             ; 1st characters match so compare 2nd characters
00:8DCA  A546              :                 LDA     Varnm2          ; get 2nd character of var to find
00:8DCC  C8                :                 INY                     ; index to point to variable name 2nd character
00:8DCD  D15C              :                 CMP     (Vrschl),Y      ; compare with variable name 2nd character
00:8DCF  F069              :                 BEQ     LAB_1DD7        ; branch if match (found var)

00:8DD1  88                :                 DEY                     ; else decrement index (now = $00)
                             LAB_1D77
00:8DD2  18                :                 CLC                     ; clear carry for add
00:8DD3  A55C              :                 LDA     Vrschl          ; get search address low byte
00:8DD5  6906              :                 ADC     #$06            ; +6 (offset to next var name)
00:8DD7  90E1              :                 BCC     LAB_1D5F        ; loop if no overflow to high byte

00:8DD9  E8                :                 INX                     ; else increment high byte
00:8DDA  80DC              :                 BRA     LAB_1D5D        ; loop always (RAM doesn't extend to $FFFF !)


Portable 65xx Assembler [20.01]

                             ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"

                             LAB_CASC
00:8DDC  C961              :                 CMP     #'a'            ; compare with "a"
00:8DDE  B00A              :                 BCS     LAB_1D83        ; go check <"z"+1

                             ; check byte, return C=0 if<"A" or >"Z"

                             LAB_1D82
00:8DE0  C941              :                 CMP     #'A'            ; compare with "A"
00:8DE2  9005              :                 BCC     LAB_1D8A        ; exit if less

                             ; carry is set
00:8DE4  E95B              :                 SBC     #$5B            ; subtract "Z"+1
00:8DE6  38                :                 SEC                     ; set carry
00:8DE7  E9A5              :                 SBC     #$A5            ; subtract $A5 (restore byte)
                             ; carry clear if byte>$5A
                             LAB_1D8A
00:8DE9  60                :                 RTS

                             LAB_1D83
00:8DEA  E97B              :                 SBC     #$7B            ; subtract "z"+1
00:8DEC  38                :                 SEC                     ; set carry
00:8DED  E985              :                 SBC     #$85            ; subtract $85 (restore byte)
                             ; carry clear if byte>$7A
00:8DEF  60                :                 RTS

                             ; reached end of variable mem without match
                             ; .. so create new variable
                             LAB_1D8B
00:8DF0  68                :                 PLA                     ; pop return address low byte
00:8DF1  48                :                 PHA                     ; push return address low byte
         00008C02          = LAB_1C18p2      .EQU    LAB_1C18+2
00:8DF2  C902              :                 CMP     #<LAB_1C18p2    ; compare with expected calling routine return low byte
00:8DF4  D005              :                 BNE     LAB_1D98        ; if not get (var) go create new var

                             ; This will only drop through if the call was from LAB_1C18 and is only called
                             ; from there if it is searching for a variable from the RHS of a LET a=b statement
                             ; it prevents the creation of variables not assigned a value.

                             ; value returned by this is either numeric zero (exponent byte is $00) or null string
                             ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.

                             ; doing this saves 6 bytes of variable memory and 168 machine cycles of time

                             ; this is where you would put the undefined variable error call e.g.

                             ;                             ; variable doesn't exist so flag error
                             ;     LDX   #$24              ; error code $24 ("undefined variable" error)
                             ;     JMP   LAB_XERR          ; do error #X then warm start

                             ; the above code has been tested and works a treat! (it replaces the three code lines
                             ; below)


Portable 65xx Assembler [20.01]

                             ; else return dummy null value
00:8DF6  A9B2              :                 LDA     #<LAB_1D96      ; low byte point to $00,$00
                             ; (uses part of misc constants table)
00:8DF8  A0A0              :                 LDY     #>LAB_1D96      ; high byte point to $00,$00
00:8DFA  60                :                 RTS

                             ; create new numeric variable
                             LAB_1D98
00:8DFB  A52F              :                 LDA     Sarryl          ; get var mem end low byte
00:8DFD  A430              :                 LDY     Sarryh          ; get var mem end high byte
00:8DFF  855C              :                 STA     Ostrtl          ; save old block start low byte
00:8E01  845D              :                 STY     Ostrth          ; save old block start high byte
00:8E03  A531              :                 LDA     Earryl          ; get array mem end low byte
00:8E05  A432              :                 LDY     Earryh          ; get array mem end high byte
00:8E07  8558              :                 STA     Obendl          ; save old block end low byte
00:8E09  8459              :                 STY     Obendh          ; save old block end high byte
00:8E0B  18                :                 CLC                     ; clear carry for add
00:8E0C  6906              :                 ADC     #$06            ; +6 (space for one var)
00:8E0E  9001              :                 BCC     LAB_1DAE        ; branch if no overflow to high byte

00:8E10  C8                :                 INY                     ; else increment high byte
                             LAB_1DAE
00:8E11  8556              :                 STA     Nbendl          ; set new block end low byte
00:8E13  8457              :                 STY     Nbendh          ; set new block end high byte
00:8E15  20B680            :                 JSR     LAB_11CF        ; open up space in memory
00:8E18  A556              :                 LDA     Nbendl          ; get new start low byte
00:8E1A  A457              :                 LDY     Nbendh          ; get new start high byte (-$100)
00:8E1C  C8                :                 INY                     ; correct high byte
00:8E1D  852F              :                 STA     Sarryl          ; save new var mem end low byte
00:8E1F  8430              :                 STY     Sarryh          ; save new var mem end high byte
00:8E21  A000              :                 LDY     #$00            ; clear index
00:8E23  A545              :                 LDA     Varnm1          ; get var name 1st character
00:8E25  915C              :                 STA     (Vrschl),Y      ; save var name 1st character
00:8E27  C8                :                 INY                     ; increment index
00:8E28  A546              :                 LDA     Varnm2          ; get var name 2nd character
00:8E2A  915C              :                 STA     (Vrschl),Y      ; save var name 2nd character
00:8E2C  A900              :                 LDA     #$00            ; clear A
00:8E2E  C8                :                 INY                     ; increment index
00:8E2F  915C              :                 STA     (Vrschl),Y      ; initialise var byte
00:8E31  C8                :                 INY                     ; increment index
00:8E32  915C              :                 STA     (Vrschl),Y      ; initialise var byte
00:8E34  C8                :                 INY                     ; increment index
00:8E35  915C              :                 STA     (Vrschl),Y      ; initialise var byte
00:8E37  C8                :                 INY                     ; increment index
00:8E38  915C              :                 STA     (Vrschl),Y      ; initialise var byte

                             ; found a match for var ((Vrschl) = ptr)
                             LAB_1DD7
00:8E3A  A55C              :                 LDA     Vrschl          ; get var address low byte
00:8E3C  18                :                 CLC                     ; clear carry for add
00:8E3D  6902              :                 ADC     #$02            ; +2 (offset past var name bytes)
00:8E3F  A45D              :                 LDY     Vrschh          ; get var address high byte
00:8E41  9001              :                 BCC     LAB_1DE1        ; branch if no overflow from add


Portable 65xx Assembler [20.01]

00:8E43  C8                :                 INY                     ; else increment high byte
                             LAB_1DE1
00:8E44  8547              :                 STA     Cvaral          ; save current var address low byte
00:8E46  8448              :                 STY     Cvarah          ; save current var address high byte
00:8E48  60                :                 RTS

                             ; set-up array pointer (Adatal/h) to first element in array
                             ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05

                             LAB_1DE6
00:8E49  A50F              :                 LDA     Dimcnt          ; get # of dimensions (1, 2 or 3)
00:8E4B  0A                :                 ASL                     ; *2 (also clears the carry !)
00:8E4C  6905              :                 ADC     #$05            ; +5 (result is 7, 9 or 11 here)
00:8E4E  655C              :                 ADC     Astrtl          ; add array start pointer low byte
00:8E50  A45D              :                 LDY     Astrth          ; get array pointer high byte
00:8E52  9001              :                 BCC     LAB_1DF2        ; branch if no overflow

00:8E54  C8                :                 INY                     ; else increment high byte
                             LAB_1DF2
00:8E55  8556              :                 STA     Adatal          ; save array data pointer low byte
00:8E57  8457              :                 STY     Adatah          ; save array data pointer high byte
00:8E59  60                :                 RTS

                             ; evaluate integer expression

                             LAB_EVIN
00:8E5A  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:8E5D  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch

                             ; evaluate integer expression (no check)

                             LAB_EVPI
00:8E60  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:8E62  300D              :                 BMI     LAB_1E12        ; do function call error if -ve

                             ; evaluate integer expression (no sign check)

                             LAB_EVIR
00:8E64  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:8E66  C990              :                 CMP     #$90            ; compare with exponent = 2^16 (n>2^15)
00:8E68  9009              :                 BCC     LAB_1E14        ; branch if n<2^16 (is ok)

00:8E6A  A9B9              :                 LDA     #<LAB_1DF7      ; set pointer low byte to -32768
00:8E6C  A0A0              :                 LDY     #>LAB_1DF7      ; set pointer high byte to -32768
00:8E6E  20B998            :                 JSR     LAB_27F8        ; compare FAC1 with (AY)
                             LAB_1E12
00:8E71  D073              :                 BNE     LAB_FCER        ; if <> do function call error then warm start

                             LAB_1E14
00:8E73  4CF198            :                 JMP     LAB_2831        ; convert FAC1 floating-to-fixed and return

                             ; find or make array


Portable 65xx Assembler [20.01]

                             LAB_1E17
00:8E76  A510              :                 LDA     Defdim          ; get DIM flag
00:8E78  48                :                 PHA                     ; push it
00:8E79  A511              :                 LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:8E7B  48                :                 PHA                     ; push it
00:8E7C  A000              :                 LDY     #$00            ; clear dimensions count

                             ; now get the array dimension(s) and stack it (them) before the data type and DIM flag

                             LAB_1E1F
00:8E7E  5A                :                 PHY                     ; sve dimensions count
00:8E7F  A546              :                 LDA     Varnm2          ; get array name 2nd byte
00:8E81  48                :                 PHA                     ; save it
00:8E82  A545              :                 LDA     Varnm1          ; get array name 1st byte
00:8E84  48                :                 PHA                     ; save it
00:8E85  205A8E            :                 JSR     LAB_EVIN        ; evaluate integer expression
00:8E88  68                :                 PLA                     ; pull array name 1st byte
00:8E89  8545              :                 STA     Varnm1          ; restore array name 1st byte
00:8E8B  68                :                 PLA                     ; pull array name 2nd byte
00:8E8C  8546              :                 STA     Varnm2          ; restore array name 2nd byte
00:8E8E  7A                :                 PLY                     ; restore dimensions count
00:8E8F  BA                :                 TSX                     ; copy stack pointer
00:8E90  BD0201            :                 LDA     LAB_STAK+2,X    ; get DIM flag
00:8E93  48                :                 PHA                     ; push it
00:8E94  BD0101            :                 LDA     LAB_STAK+1,X    ; get data type flag
00:8E97  48                :                 PHA                     ; push it
00:8E98  A560              :                 LDA     FAC1_2          ; get this dimension size high byte
00:8E9A  9D0201            :                 STA     LAB_STAK+2,X    ; stack before flag bytes
00:8E9D  A561              :                 LDA     FAC1_3          ; get this dimension size low byte
00:8E9F  9D0101            :                 STA     LAB_STAK+1,X    ; stack before flag bytes
00:8EA2  C8                :                 INY                     ; increment dimensions count
00:8EA3  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:8EA6  C92C              :                 CMP     #','            ; compare with ","
00:8EA8  F0D4              :                 BEQ     LAB_1E1F        ; if found go do next dimension

00:8EAA  840F              :                 STY     Dimcnt          ; store dimensions count
00:8EAC  20B78B            :                 JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
00:8EAF  68                :                 PLA                     ; pull data type flag
00:8EB0  8511              :                 STA     Dtypef          ; restore data type flag, $FF=string, $00=numeric
00:8EB2  68                :                 PLA                     ; pull DIM flag
00:8EB3  8510              :                 STA     Defdim          ; restore DIM flag
00:8EB5  A62F              :                 LDX     Sarryl          ; get array mem start low byte
00:8EB7  A530              :                 LDA     Sarryh          ; get array mem start high byte

                             ; now check to see if we are at the end of array memory (we would be if there were
                             ; no arrays).

                             LAB_1E5C
00:8EB9  865C              :                 STX     Astrtl          ; save as array start pointer low byte
00:8EBB  855D              :                 STA     Astrth          ; save as array start pointer high byte
00:8EBD  C532              :                 CMP     Earryh          ; compare with array mem end high byte
00:8EBF  D004              :                 BNE     LAB_1E68        ; branch if not reached array mem end

00:8EC1  E431              :                 CPX     Earryl          ; else compare with array mem end low byte

Portable 65xx Assembler [20.01]

00:8EC3  F03A              :                 BEQ     LAB_1EA1        ; go build array if not found

                             ; search for array
                             LAB_1E68
00:8EC5  A000              :                 LDY     #$00            ; clear index
00:8EC7  B15C              :                 LDA     (Astrtl),Y      ; get array name first byte
00:8EC9  C8                :                 INY                     ; increment index to second name byte
00:8ECA  C545              :                 CMP     Varnm1          ; compare with this array name first byte
00:8ECC  D006              :                 BNE     LAB_1E77        ; branch if no match

00:8ECE  A546              :                 LDA     Varnm2          ; else get this array name second byte
00:8ED0  D15C              :                 CMP     (Astrtl),Y      ; compare with array name second byte
00:8ED2  F017              :                 BEQ     LAB_1E8D        ; array found so branch

                             ; no match
                             LAB_1E77
00:8ED4  C8                :                 INY                     ; increment index
00:8ED5  B15C              :                 LDA     (Astrtl),Y      ; get array size low byte
00:8ED7  18                :                 CLC                     ; clear carry for add
00:8ED8  655C              :                 ADC     Astrtl          ; add array start pointer low byte
00:8EDA  AA                :                 TAX                     ; copy low byte to X
00:8EDB  C8                :                 INY                     ; increment index
00:8EDC  B15C              :                 LDA     (Astrtl),Y      ; get array size high byte
00:8EDE  655D              :                 ADC     Astrth          ; add array mem pointer high byte
00:8EE0  90D7              :                 BCC     LAB_1E5C        ; if no overflow go check next array

                             ; do array bounds error

                             LAB_1E85
00:8EE2  A210              :                 LDX     #$10            ; error code $10 ("Array bounds" error)
00:8EE4  8002              :                 BRA     LAB_1E8A        ; branch around next instruction, saves on clock cycle

                             ; do function call error

                             LAB_FCER
00:8EE6  A208              :                 LDX     #$08            ; error code $08 ("Function call" error)
                             LAB_1E8A
00:8EE8  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; found array, are we trying to dimension it?
                             LAB_1E8D
00:8EEB  A212              :                 LDX     #$12            ; set error $12 ("Double dimension" error)
00:8EED  A510              :                 LDA     Defdim          ; get DIM flag
00:8EEF  D0F7              :                 BNE     LAB_1E8A        ; if we are trying to dimension it do error #X, then warm
                             ; start

                             ; found the array and we're not dimensioning it so we must find an element in it

00:8EF1  20498E            :                 JSR     LAB_1DE6        ; set-up array pointer (Adatal/h) to first element in array
                             ; (Astrtl,Astrth points to start of array)
00:8EF4  A50F              :                 LDA     Dimcnt          ; get dimensions count
00:8EF6  A004              :                 LDY     #$04            ; set index to array's # of dimensions
00:8EF8  D15C              :                 CMP     (Astrtl),Y      ; compare with no of dimensions
00:8EFA  D0E6              :                 BNE     LAB_1E85        ; if wrong do array bounds error, could do "Wrong

Portable 65xx Assembler [20.01]

                             ; dimensions" error here .. if we want a different
                             ; error message

00:8EFC  4C828F            :                 JMP     LAB_1F28        ; found array so go get element
                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
                             ; Dimcnt and save it at (Astrtl),Y which is already the
                             ; same or we would have taken the BNE)

                             ; array not found, so build it
                             LAB_1EA1
00:8EFF  20498E            :                 JSR     LAB_1DE6        ; set-up array pointer (Adatal/h) to first element in array
                             ; (Astrtl,Astrth points to start of array)
00:8F02  200381            :                 JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
                             ; addr to check is in AY (low/high)
00:8F05  A000              :                 LDY     #$00            ; clear Y (don't need to clear A)
00:8F07  846D              :                 STY     Aspth           ; clear array data size high byte
00:8F09  A545              :                 LDA     Varnm1          ; get variable name 1st byte
00:8F0B  915C              :                 STA     (Astrtl),Y      ; save array name 1st byte
00:8F0D  C8                :                 INY                     ; increment index
00:8F0E  A546              :                 LDA     Varnm2          ; get variable name 2nd byte
00:8F10  915C              :                 STA     (Astrtl),Y      ; save array name 2nd byte
00:8F12  A50F              :                 LDA     Dimcnt          ; get dimensions count
00:8F14  A004              :                 LDY     #$04            ; index to dimension count
00:8F16  846C              :                 STY     Asptl           ; set array data size low byte (four bytes per element)
00:8F18  915C              :                 STA     (Astrtl),Y      ; set array's dimensions count

                             ; now calculate the size of the data space for the array
00:8F1A  18                :                 CLC                     ; clear carry for add (clear on subsequent loops)
                             LAB_1EC0
00:8F1B  A20B              :                 LDX     #$0B            ; set default dimension value low byte
00:8F1D  A900              :                 LDA     #$00            ; set default dimension value high byte
00:8F1F  2410              :                 BIT     Defdim          ; test default DIM flag
00:8F21  5007              :                 BVC     LAB_1ED0        ; branch if b6 of Defdim is clear

00:8F23  68                :                 PLA                     ; else pull dimension value low byte
00:8F24  6901              :                 ADC     #$01            ; +1 (allow for zeroeth element)
00:8F26  AA                :                 TAX                     ; copy low byte to X
00:8F27  68                :                 PLA                     ; pull dimension value high byte
00:8F28  6900              :                 ADC     #$00            ; add carry from low byte

                             LAB_1ED0
00:8F2A  C8                :                 INY                     ; index to dimension value high byte
00:8F2B  915C              :                 STA     (Astrtl),Y      ; save dimension value high byte
00:8F2D  C8                :                 INY                     ; index to dimension value high byte
00:8F2E  8A                :                 TXA                     ; get dimension value low byte
00:8F2F  915C              :                 STA     (Astrtl),Y      ; save dimension value low byte
00:8F31  20D18F            :                 JSR     LAB_1F7C        ; does XY = (Astrtl),Y * (Asptl)
00:8F34  866C              :                 STX     Asptl           ; save array data size low byte
00:8F36  856D              :                 STA     Aspth           ; save array data size high byte
00:8F38  A423              :                 LDY     ut1_pl          ; restore index (saved by subroutine)
00:8F3A  C60F              :                 DEC     Dimcnt          ; decrement dimensions count
00:8F3C  D0DD              :                 BNE     LAB_1EC0        ; loop while not = 0

00:8F3E  6557              :                 ADC     Adatah          ; add size high byte to first element high byte

Portable 65xx Assembler [20.01]

                             ; (carry is always clear here)
00:8F40  B05D              :                 BCS     LAB_1F45        ; if overflow go do "Out of memory" error

00:8F42  8557              :                 STA     Adatah          ; save end of array high byte
00:8F44  A8                :                 TAY                     ; copy end high byte to Y
00:8F45  8A                :                 TXA                     ; get array size low byte
00:8F46  6556              :                 ADC     Adatal          ; add array start low byte
00:8F48  9003              :                 BCC     LAB_1EF3        ; branch if no carry

00:8F4A  C8                :                 INY                     ; else increment end of array high byte
00:8F4B  F052              :                 BEQ     LAB_1F45        ; if overflow go do "Out of memory" error

                             ; set-up mostly complete, now zero the array
                             LAB_1EF3
00:8F4D  200381            :                 JSR     LAB_121F        ; check available memory, "Out of memory" error if no room
                             ; addr to check is in AY (low/high)
00:8F50  8531              :                 STA     Earryl          ; save array mem end low byte
00:8F52  8432              :                 STY     Earryh          ; save array mem end high byte
00:8F54  A900              :                 LDA     #$00            ; clear byte for array clear
00:8F56  E66D              :                 INC     Aspth           ; increment array size high byte (now block count)
00:8F58  A46C              :                 LDY     Asptl           ; get array size low byte (now index to block)
00:8F5A  F005              :                 BEQ     LAB_1F07        ; branch if low byte = $00

                             LAB_1F02
00:8F5C  88                :                 DEY                     ; decrement index (do 0 to n-1)
00:8F5D  9156              :                 STA     (Adatal),Y      ; zero byte
00:8F5F  D0FB              :                 BNE     LAB_1F02        ; loop until this block done

                             LAB_1F07
00:8F61  C657              :                 DEC     Adatah          ; decrement array pointer high byte
00:8F63  C66D              :                 DEC     Aspth           ; decrement block count high byte
00:8F65  D0F5              :                 BNE     LAB_1F02        ; loop until all blocks done

00:8F67  E657              :                 INC     Adatah          ; correct for last loop
00:8F69  38                :                 SEC                     ; set carry for subtract
00:8F6A  A002              :                 LDY     #$02            ; index to array size low byte
00:8F6C  A531              :                 LDA     Earryl          ; get array mem end low byte
00:8F6E  E55C              :                 SBC     Astrtl          ; subtract array start low byte
00:8F70  915C              :                 STA     (Astrtl),Y      ; save array size low byte
00:8F72  C8                :                 INY                     ; index to array size high byte
00:8F73  A532              :                 LDA     Earryh          ; get array mem end high byte
00:8F75  E55D              :                 SBC     Astrth          ; subtract array start high byte
00:8F77  915C              :                 STA     (Astrtl),Y      ; save array size high byte
00:8F79  A510              :                 LDA     Defdim          ; get default DIM flag
00:8F7B  D053              :                 BNE     LAB_1F7B        ; exit (RET) if this was a DIM command

                             ; else, find element
00:8F7D  C8                :                 INY                     ; index to # of dimensions

                             LAB_1F24
00:8F7E  B15C              :                 LDA     (Astrtl),Y      ; get array's dimension count
00:8F80  850F              :                 STA     Dimcnt          ; save it

                             ; we have found, or built, the array. now we need to find the element

Portable 65xx Assembler [20.01]


                             LAB_1F28
00:8F82  A900              :                 LDA     #$00            ; clear byte
00:8F84  856C              :                 STA     Asptl           ; clear array data pointer low byte
                             LAB_1F2C
00:8F86  856D              :                 STA     Aspth           ; save array data pointer high byte
00:8F88  C8                :                 INY                     ; increment index (point to array bound high byte)
00:8F89  68                :                 PLA                     ; pull array index low byte
00:8F8A  AA                :                 TAX                     ; copy to X
00:8F8B  8560              :                 STA     FAC1_2          ; save index low byte to FAC1 mantissa2
00:8F8D  68                :                 PLA                     ; pull array index high byte
00:8F8E  8561              :                 STA     FAC1_3          ; save index high byte to FAC1 mantissa3
00:8F90  D15C              :                 CMP     (Astrtl),Y      ; compare with array bound high byte
00:8F92  900E              :                 BCC     LAB_1F48        ; branch if within bounds

00:8F94  D006              :                 BNE     LAB_1F42        ; if outside bounds do array bounds error

                             ; else high byte was = so test low bytes
00:8F96  C8                :                 INY                     ; index to array bound low byte
00:8F97  8A                :                 TXA                     ; get array index low byte
00:8F98  D15C              :                 CMP     (Astrtl),Y      ; compare with array bound low byte
00:8F9A  9007              :                 BCC     LAB_1F49        ; branch if within bounds

                             LAB_1F42
00:8F9C  4CE28E            :                 JMP     LAB_1E85        ; else do array bounds error

                             LAB_1F45
00:8F9F  4C3181            :                 JMP     LAB_OMER        ; do "Out of memory" error then warm start

                             LAB_1F48
00:8FA2  C8                :                 INY                     ; index to array bound low byte
                             LAB_1F49
00:8FA3  A56D              :                 LDA     Aspth           ; get array data pointer high byte
00:8FA5  056C              :                 ORA     Asptl           ; OR with array data pointer low byte
00:8FA7  F00A              :                 BEQ     LAB_1F5A        ; branch if array data pointer = null (skip multiply)

00:8FA9  20D18F            :                 JSR     LAB_1F7C        ; does XY = (Astrtl),Y * (Asptl)
00:8FAC  8A                :                 TXA                     ; get result low byte
00:8FAD  6560              :                 ADC     FAC1_2          ; add index low byte from FAC1 mantissa2
00:8FAF  AA                :                 TAX                     ; save result low byte
00:8FB0  98                :                 TYA                     ; get result high byte
00:8FB1  A423              :                 LDY     ut1_pl          ; restore index
                             LAB_1F5A
00:8FB3  6561              :                 ADC     FAC1_3          ; add index high byte from FAC1 mantissa3
00:8FB5  866C              :                 STX     Asptl           ; save array data pointer low byte
00:8FB7  C60F              :                 DEC     Dimcnt          ; decrement dimensions count
00:8FB9  D0CB              :                 BNE     LAB_1F2C        ; loop if dimensions still to do

00:8FBB  066C              :                 ASL     Asptl           ; array data pointer low byte * 2
00:8FBD  2A                :                 ROL                     ; array data pointer high byte * 2
00:8FBE  066C              :                 ASL     Asptl           ; array data pointer low byte * 4
00:8FC0  2A                :                 ROL                     ; array data pointer high byte * 4
00:8FC1  A8                :                 TAY                     ; copy high byte
00:8FC2  A56C              :                 LDA     Asptl           ; get low byte

Portable 65xx Assembler [20.01]

00:8FC4  6556              :                 ADC     Adatal          ; add array data start pointer low byte
00:8FC6  8547              :                 STA     Cvaral          ; save as current var address low byte
00:8FC8  98                :                 TYA                     ; get high byte back
00:8FC9  6557              :                 ADC     Adatah          ; add array data start pointer high byte
00:8FCB  8548              :                 STA     Cvarah          ; save as current var address high byte
00:8FCD  A8                :                 TAY                     ; copy high byte to Y
00:8FCE  A547              :                 LDA     Cvaral          ; get current var address low byte
                             LAB_1F7B
00:8FD0  60                :                 RTS

                             ; does XY = (Astrtl),Y * (Asptl)

                             LAB_1F7C
00:8FD1  8423              :                 STY     ut1_pl          ; save index
00:8FD3  B15C              :                 LDA     (Astrtl),Y      ; get dimension size low byte
00:8FD5  8528              :                 STA     dims_l          ; save dimension size low byte
00:8FD7  88                :                 DEY                     ; decrement index
00:8FD8  B15C              :                 LDA     (Astrtl),Y      ; get dimension size high byte
00:8FDA  8529              :                 STA     dims_h          ; save dimension size high byte

00:8FDC  A910              :                 LDA     #$10            ; count = $10 (16 bit multiply)
00:8FDE  855A              :                 STA     numbit          ; save bit count
00:8FE0  A200              :                 LDX     #$00            ; clear result low byte
00:8FE2  A000              :                 LDY     #$00            ; clear result high byte
                             LAB_1F8F
00:8FE4  8A                :                 TXA                     ; get result low byte
00:8FE5  0A                :                 ASL                     ; *2
00:8FE6  AA                :                 TAX                     ; save result low byte
00:8FE7  98                :                 TYA                     ; get result high byte
00:8FE8  2A                :                 ROL                     ; *2
00:8FE9  A8                :                 TAY                     ; save result high byte
00:8FEA  B0B3              :                 BCS     LAB_1F45        ; if overflow go do "Out of memory" error

00:8FEC  066C              :                 ASL     Asptl           ; shift multiplier low byte
00:8FEE  266D              :                 ROL     Aspth           ; shift multiplier high byte
00:8FF0  900B              :                 BCC     LAB_1FA8        ; skip add if no carry

00:8FF2  18                :                 CLC                     ; else clear carry for add
00:8FF3  8A                :                 TXA                     ; get result low byte
00:8FF4  6528              :                 ADC     dims_l          ; add dimension size low byte
00:8FF6  AA                :                 TAX                     ; save result low byte
00:8FF7  98                :                 TYA                     ; get result high byte
00:8FF8  6529              :                 ADC     dims_h          ; add dimension size high byte
00:8FFA  A8                :                 TAY                     ; save result high byte
00:8FFB  B0A2              :                 BCS     LAB_1F45        ; if overflow go do "Out of memory" error

                             LAB_1FA8
00:8FFD  C65A              :                 DEC     numbit          ; decrement bit count
00:8FFF  D0E3              :                 BNE     LAB_1F8F        ; loop until all done
00:9001  60                :                 RTS

                             ; perform FRE()

                             LAB_FRE

Portable 65xx Assembler [20.01]

00:9002  A511              :                 LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:9004  1003              :                 BPL     LAB_1FB4        ; branch if numeric

00:9006  20F692            :                 JSR     LAB_22B6        ; pop string off descriptor stack, or from top of string
                             ; space returns with A = length, X=$71=pointer low byte,
                             ; Y=$72=pointer high byte

                             ; FRE(n) was numeric so do this
                             LAB_1FB4
00:9009  209B91            :                 JSR     LAB_GARB        ; go do garbage collection
00:900C  38                :                 SEC                     ; set carry for subtract
00:900D  A533              :                 LDA     Sstorl          ; get bottom of string space low byte
00:900F  E531              :                 SBC     Earryl          ; subtract array mem end low byte
00:9011  A8                :                 TAY                     ; copy result to Y
00:9012  A534              :                 LDA     Sstorh          ; get bottom of string space high byte
00:9014  E532              :                 SBC     Earryh          ; subtract array mem end high byte

                             ; save and convert integer AY to FAC1

                             LAB_AYFC
00:9016  4611              :                 LSR     Dtypef          ; clear data type flag, $FF=string, $00=numeric
00:9018  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:901A  8460              :                 STY     FAC1_2          ; save FAC1 mantissa2
00:901C  A290              :                 LDX     #$90            ; set exponent=2^16 (integer)
00:901E  4CA698            :                 JMP     LAB_27E3        ; set exp=X, clear FAC1_3, normalise and return

                             ; perform POS()

                             LAB_POS
00:9021  A407              :                 LDY     TPos            ; get terminal position

                             ; convert Y to byte in FAC1

                             LAB_1FD0
00:9023  A900              :                 LDA     #$00            ; clear high byte
00:9025  80EF              :                 BRA     LAB_AYFC        ; always save and convert integer AY to FAC1 and return

                             ; check not Direct (used by DEF and INPUT)

                             LAB_CKRN
00:9027  A63A              :                 LDX     Clineh          ; get current line high byte
00:9029  E8                :                 INX                     ; increment it
00:902A  D0A4              :                 BNE     LAB_1F7B        ; return if can continue not direct mode

                             ; else do illegal direct error
                             LAB_1FD9
00:902C  A216              :                 LDX     #$16            ; error code $16 ("Illegal direct" error)
                             LAB_1FDB
00:902E  4C3381            :                 JMP     LAB_XERR        ; go do error #X, then warm start

                             ; perform DEF

                             LAB_DEF
00:9031  206190            :                 JSR     LAB_200B        ; check FNx syntax

Portable 65xx Assembler [20.01]

00:9034  854E              :                 STA     func_l          ; save function pointer low byte
00:9036  844F              :                 STY     func_h          ; save function pointer high byte
00:9038  202790            :                 JSR     LAB_CKRN        ; check not Direct (back here if ok)
00:903B  20C08B            :                 JSR     LAB_1BFE        ; scan for "(" , else do syntax error then warm start
00:903E  A980              :                 LDA     #$80            ; set flag for FNx
00:9040  8513              :                 STA     Sufnxf          ; save subscript/FNx flag
00:9042  206A8D            :                 JSR     LAB_GVAR        ; get (var) address
00:9045  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00:9048  20B78B            :                 JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
00:904B  A9BD              :                 LDA     #TK_EQUAL       ; get = token
00:904D  20B98B            :                 JSR     LAB_SCCA        ; scan for CHR$(A), else do syntax error then warm start
00:9050  A548              :                 LDA     Cvarah          ; get current var address high byte
00:9052  48                :                 PHA                     ; push it
00:9053  A547              :                 LDA     Cvaral          ; get current var address low byte
00:9055  48                :                 PHA                     ; push it
00:9056  A56F              :                 LDA     Bpntrh          ; get BASIC execute pointer high byte
00:9058  48                :                 PHA                     ; push it
00:9059  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:905B  48                :                 PHA                     ; push it
00:905C  206E86            :                 JSR     LAB_DATA        ; go perform DATA
00:905F  806E              :                 BRA     LAB_207A        ; put execute pointer and variable pointer into function
                             ; and return

                             ; check FNx syntax

                             LAB_200B
00:9061  A9AB              :                 LDA     #TK_FN          ; get FN" token
00:9063  20B98B            :                 JSR     LAB_SCCA        ; scan for CHR$(A) , else do syntax error then warm start
                             ; return character after A
00:9066  0980              :                 ORA     #$80            ; set FN flag bit
00:9068  8513              :                 STA     Sufnxf          ; save FN flag so array variable test fails
00:906A  20718D            :                 JSR     LAB_1D12        ; search for FN variable
00:906D  4C9A8A            :                 JMP     LAB_CTNM        ; check if source is numeric and return, else do type
                             ; mismatch

                             ; Evaluate FNx
                             LAB_201E
00:9070  206190            :                 JSR     LAB_200B        ; check FNx syntax
00:9073  48                :                 PHA                     ; push function pointer low byte
00:9074  5A                :                 PHY                     ; push function pointer high byte
00:9075  20C08B            :                 JSR     LAB_1BFE        ; scan for "(", else do syntax error then warm start
00:9078  20AC8A            :                 JSR     LAB_EVEX        ; evaluate expression
00:907B  20B78B            :                 JSR     LAB_1BFB        ; scan for ")", else do syntax error then warm start
00:907E  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00:9081  68                :                 PLA                     ; pop function pointer high byte
00:9082  854F              :                 STA     func_h          ; restore it
00:9084  68                :                 PLA                     ; pop function pointer low byte
00:9085  854E              :                 STA     func_l          ; restore it
00:9087  A220              :                 LDX     #$20            ; error code $20 ("Undefined function" error)
00:9089  A003              :                 LDY     #$03            ; index to variable pointer high byte
00:908B  B14E              :                 LDA     (func_l),Y      ; get variable pointer high byte
00:908D  F09F              :                 BEQ     LAB_1FDB        ; if zero go do undefined function error

00:908F  8548              :                 STA     Cvarah          ; save variable address high byte

Portable 65xx Assembler [20.01]

00:9091  88                :                 DEY                     ; index to variable address low byte
00:9092  B14E              :                 LDA     (func_l),Y      ; get variable address low byte
00:9094  8547              :                 STA     Cvaral          ; save variable address low byte
00:9096  AA                :                 TAX                     ; copy address low byte

                             ; now stack the function variable value before use
00:9097  C8                :                 INY                     ; index to mantissa_3
                             LAB_2043
00:9098  B147              :                 LDA     (Cvaral),Y      ; get byte from variable
00:909A  48                :                 PHA                     ; stack it
00:909B  88                :                 DEY                     ; decrement index
00:909C  10FA              :                 BPL     LAB_2043        ; loop until variable stacked

00:909E  A448              :                 LDY     Cvarah          ; get variable address high byte
00:90A0  204D98            :                 JSR     LAB_2778        ; pack FAC1 (function expression value) into (XY)
                             ; (function variable), return Y=0, always
00:90A3  A56F              :                 LDA     Bpntrh          ; get BASIC execute pointer high byte
00:90A5  48                :                 PHA                     ; push it
00:90A6  A56E              :                 LDA     Bpntrl          ; get BASIC execute pointer low byte
00:90A8  48                :                 PHA                     ; push it
00:90A9  B14E              :                 LDA     (func_l),Y      ; get function execute pointer low byte
00:90AB  856E              :                 STA     Bpntrl          ; save as BASIC execute pointer low byte
00:90AD  C8                :                 INY                     ; index to high byte
00:90AE  B14E              :                 LDA     (func_l),Y      ; get function execute pointer high byte
00:90B0  856F              :                 STA     Bpntrh          ; save as BASIC execute pointer high byte
00:90B2  A548              :                 LDA     Cvarah          ; get variable address high byte
00:90B4  48                :                 PHA                     ; push it
00:90B5  A547              :                 LDA     Cvaral          ; get variable address low byte
00:90B7  48                :                 PHA                     ; push it
00:90B8  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
00:90BB  68                :                 PLA                     ; pull variable address low byte
00:90BC  854E              :                 STA     func_l          ; save variable address low byte
00:90BE  68                :                 PLA                     ; pull variable address high byte
00:90BF  854F              :                 STA     func_h          ; save variable address high byte
00:90C1  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:90C4  F003              :                 BEQ     LAB_2074        ; branch if null (should be [EOL] marker)

00:90C6  4CC88B            :                 JMP     LAB_SNER        ; else syntax error then warm start

                             ; restore Bpntrl,Bpntrh and function variable from stack

                             LAB_2074
00:90C9  68                :                 PLA                     ; pull BASIC execute pointer low byte
00:90CA  856E              :                 STA     Bpntrl          ; restore BASIC execute pointer low byte
00:90CC  68                :                 PLA                     ; pull BASIC execute pointer high byte
00:90CD  856F              :                 STA     Bpntrh          ; restore BASIC execute pointer high byte

                             ; put execute pointer and variable pointer into function

                             LAB_207A
00:90CF  A000              :                 LDY     #$00            ; clear index
00:90D1  68                :                 PLA                     ; pull BASIC execute pointer low byte
00:90D2  914E              :                 STA     (func_l),Y      ; save to function

Portable 65xx Assembler [20.01]

00:90D4  C8                :                 INY                     ; increment index
00:90D5  68                :                 PLA                     ; pull BASIC execute pointer high byte
00:90D6  914E              :                 STA     (func_l),Y      ; save to function
00:90D8  C8                :                 INY                     ; increment index
00:90D9  68                :                 PLA                     ; pull current var address low byte
00:90DA  914E              :                 STA     (func_l),Y      ; save to function
00:90DC  C8                :                 INY                     ; increment index
00:90DD  68                :                 PLA                     ; pull current var address high byte
00:90DE  914E              :                 STA     (func_l),Y      ; save to function
00:90E0  60                :                 RTS

                             ; perform STR$()

                             LAB_STRS
00:90E1  209A8A            :                 JSR     LAB_CTNM        ; check if source is numeric, else do type mismatch
00:90E4  202F9A            :                 JSR     LAB_296E        ; convert FAC1 to string
00:90E7  A975              :                 LDA     #<Decssp1       ; set result string low pointer
00:90E9  A000              :                 LDY     #>Decssp1       ; set result string high pointer
00:90EB  F012              :                 BEQ     LAB_20AE        ; print null terminated string to Sutill/Sutilh

                             ; Do string vector
                             ; copy des_pl/h to des_2l/h and make string space A bytes long

                             LAB_209C
00:90ED  A660              :                 LDX     des_pl          ; get descriptor pointer low byte
00:90EF  A461              :                 LDY     des_ph          ; get descriptor pointer high byte
00:90F1  8650              :                 STX     des_2l          ; save descriptor pointer low byte
00:90F3  8451              :                 STY     des_2h          ; save descriptor pointer high byte

                             ; make string space A bytes long
                             ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte

                             LAB_MSSP
00:90F5  206991            :                 JSR     LAB_2115        ; make space in string memory for string A long
                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00:90F8  865F              :                 STX     str_pl          ; save string pointer low byte
00:90FA  8460              :                 STY     str_ph          ; save string pointer high byte
00:90FC  855E              :                 STA     str_ln          ; save length
00:90FE  60                :                 RTS

                             ; Scan, set up string
                             ; print " terminated string to Sutill/Sutilh

                             LAB_20AE
00:90FF  A222              :                 LDX     #$22            ; set terminator to "
00:9101  860D              :                 STX     Srchc           ; set search character (terminator 1)
00:9103  860E              :                 STX     Asrch           ; set terminator 2

                             ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
                             ; source is AY

                             LAB_20B4
00:9105  856A              :                 STA     ssptr_l         ; store string start low byte
00:9107  846B              :                 STY     ssptr_h         ; store string start high byte

Portable 65xx Assembler [20.01]

00:9109  855F              :                 STA     str_pl          ; save string pointer low byte
00:910B  8460              :                 STY     str_ph          ; save string pointer high byte
00:910D  A0FF              :                 LDY     #$FF            ; set length to -1
                             LAB_20BE
00:910F  C8                :                 INY                     ; increment length
00:9110  B16A              :                 LDA     (ssptr_l),Y     ; get byte from string
00:9112  F00C              :                 BEQ     LAB_20CF        ; exit loop if null byte [EOS]

00:9114  C50D              :                 CMP     Srchc           ; compare with search character (terminator 1)
00:9116  F004              :                 BEQ     LAB_20CB        ; branch if terminator

00:9118  C50E              :                 CMP     Asrch           ; compare with terminator 2
00:911A  D0F3              :                 BNE     LAB_20BE        ; loop if not terminator 2

                             LAB_20CB
00:911C  C922              :                 CMP     #$22            ; compare with "
00:911E  F001              :                 BEQ     LAB_20D0        ; branch if " (carry set if = !)

                             LAB_20CF
00:9120  18                :                 CLC                     ; clear carry for add (only if [EOL] terminated string)
                             LAB_20D0
00:9121  845E              :                 STY     str_ln          ; save length in FAC1 exponent
00:9123  98                :                 TYA                     ; copy length to A
00:9124  656A              :                 ADC     ssptr_l         ; add string start low byte
00:9126  856C              :                 STA     Sendl           ; save string end low byte
00:9128  A66B              :                 LDX     ssptr_h         ; get string start high byte
00:912A  9001              :                 BCC     LAB_20DC        ; branch if no low byte overflow

00:912C  E8                :                 INX                     ; else increment high byte
                             LAB_20DC
00:912D  866D              :                 STX     Sendh           ; save string end high byte
00:912F  A56B              :                 LDA     ssptr_h         ; get string start high byte
00:9131  F004              :                 BEQ     LAB_MVST        ; fix STR$() using page zero via LAB_296E
00:9133  C904              :                 CMP     #>Ibuffs        ; compare with location of input buffer page
00:9135  D00B              :                 BNE     LAB_RTST        ; branch if not in utility area

                             LAB_MVST
                             ; string in utility area, move to string memory
00:9137  98                :                 TYA                     ; copy length to A
00:9138  20ED90            :                 JSR     LAB_209C        ; copy des_pl/h to des_2l/h and make string space A bytes
                             ; long
00:913B  A66A              :                 LDX     ssptr_l         ; get string start low byte
00:913D  A46B              :                 LDY     ssptr_h         ; get string start high byte
00:913F  20D792            :                 JSR     LAB_2298        ; store string A bytes long from XY to (Sutill)

                             ; check for space on descriptor stack then ..
                             ; put string address and length on descriptor stack and update stack pointers

                             LAB_RTST
00:9142  A617              :                 LDX     next_s          ; get string stack pointer
00:9144  E023              :                 CPX     #des_sk+$09     ; compare with max+1
00:9146  D005              :                 BNE     LAB_20F8        ; branch if space on string stack

                             ; else do string too complex error

Portable 65xx Assembler [20.01]

00:9148  A21C              :                 LDX     #$1C            ; error code $1C ("String too complex" error)
                             LAB_20F5
00:914A  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; put string address and length on descriptor stack and update stack pointers

                             LAB_20F8
00:914D  A55E              :                 LDA     str_ln          ; get string length
00:914F  9500              :                 STA     PLUS_0,X        ; put on string stack
00:9151  A55F              :                 LDA     str_pl          ; get string pointer low byte
00:9153  9501              :                 STA     PLUS_1,X        ; put on string stack
00:9155  A560              :                 LDA     str_ph          ; get string pointer high byte
00:9157  9502              :                 STA     PLUS_2,X        ; put on string stack
00:9159  8660              :                 STX     des_pl          ; save string descriptor pointer low byte
00:915B  6461              :                 STZ     des_ph          ; save string descriptor pointer high byte (always $00)
00:915D  A0FF              :                 LDY     #$FF            ; Y = $FF
00:915F  8411              :                 STY     Dtypef          ; save data type flag, $FF=string
00:9161  8618              :                 STX     last_sl         ; save old stack pointer (current top item)
00:9163  E8                :                 INX                     ; update stack pointer
00:9164  E8                :                 INX                     ; update stack pointer
00:9165  E8                :                 INX                     ; update stack pointer
00:9166  8617              :                 STX     next_s          ; save new top item value
00:9168  60                :                 RTS

                             ; Build descriptor
                             ; make space in string memory for string A long
                             ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte

                             LAB_2115
00:9169  4612              :                 LSR     Gclctd          ; clear garbage collected flag (b7)

                             ; make space for string A long
                             LAB_2117
00:916B  48                :                 PHA                     ; save string length
00:916C  49FF              :                 EOR     #$FF            ; complement it
00:916E  38                :                 SEC                     ; set carry for subtract (twos comp add)
00:916F  6533              :                 ADC     Sstorl          ; add bottom of string space low byte (subtract length)
00:9171  A434              :                 LDY     Sstorh          ; get bottom of string space high byte
00:9173  B001              :                 BCS     LAB_2122        ; skip decrement if no underflow

00:9175  88                :                 DEY                     ; decrement bottom of string space high byte
                             LAB_2122
00:9176  C432              :                 CPY     Earryh          ; compare with array mem end high byte
00:9178  9011              :                 BCC     LAB_2137        ; do out of memory error if less

00:917A  D004              :                 BNE     LAB_212C        ; if not = skip next test

00:917C  C531              :                 CMP     Earryl          ; compare with array mem end low byte
00:917E  900B              :                 BCC     LAB_2137        ; do out of memory error if less

                             LAB_212C
00:9180  8533              :                 STA     Sstorl          ; save bottom of string space low byte
00:9182  8434              :                 STY     Sstorh          ; save bottom of string space high byte
00:9184  8535              :                 STA     Sutill          ; save string utility ptr low byte

Portable 65xx Assembler [20.01]

00:9186  8436              :                 STY     Sutilh          ; save string utility ptr high byte
00:9188  AA                :                 TAX                     ; copy low byte to X
00:9189  68                :                 PLA                     ; get string length back
00:918A  60                :                 RTS

                             LAB_2137
00:918B  A20C              :                 LDX     #$0C            ; error code $0C ("Out of memory" error)
00:918D  A512              :                 LDA     Gclctd          ; get garbage collected flag
00:918F  30B9              :                 BMI     LAB_20F5        ; if set then do error code X

00:9191  209B91            :                 JSR     LAB_GARB        ; else go do garbage collection
00:9194  A980              :                 LDA     #$80            ; flag for garbage collected
00:9196  8512              :                 STA     Gclctd          ; set garbage collected flag
00:9198  68                :                 PLA                     ; pull length
00:9199  80D0              :                 BRA     LAB_2117        ; go try again (loop always, length should never be = $00)

                             ; garbage collection routine

                             LAB_GARB
00:919B  A637              :                 LDX     Ememl           ; get end of mem low byte
00:919D  A538              :                 LDA     Ememh           ; get end of mem high byte

                             ; re-run routine from last ending

                             LAB_214B
00:919F  8633              :                 STX     Sstorl          ; set string storage low byte
00:91A1  8534              :                 STA     Sstorh          ; set string storage high byte
00:91A3  644F              :                 STZ     garb_h          ; clear working pointer high byte (flag no strings to move)
00:91A5  A531              :                 LDA     Earryl          ; get array mem end low byte
00:91A7  A632              :                 LDX     Earryh          ; get array mem end high byte
00:91A9  855C              :                 STA     Histrl          ; save as highest string low byte
00:91AB  865D              :                 STX     Histrh          ; save as highest string high byte
00:91AD  A91A              :                 LDA     #des_sk         ; set descriptor stack pointer
00:91AF  8523              :                 STA     ut1_pl          ; save descriptor stack pointer low byte
00:91B1  6424              :                 STZ     ut1_ph          ; save descriptor stack pointer high byte ($00)
                             LAB_2161
00:91B3  C517              :                 CMP     next_s          ; compare with descriptor stack pointer
00:91B5  F005              :                 BEQ     LAB_216A        ; branch if =

00:91B7  201D92            :                 JSR     LAB_21D7        ; go garbage collect descriptor stack
00:91BA  80F7              :                 BRA     LAB_2161        ; loop always

                             ; done stacked strings, now do string vars
                             LAB_216A
00:91BC  0652              :                 ASL     g_step          ; set step size = $06
00:91BE  A52D              :                 LDA     Svarl           ; get start of vars low byte
00:91C0  A62E              :                 LDX     Svarh           ; get start of vars high byte
00:91C2  8523              :                 STA     ut1_pl          ; save as pointer low byte
00:91C4  8624              :                 STX     ut1_ph          ; save as pointer high byte
                             LAB_2176
00:91C6  E430              :                 CPX     Sarryh          ; compare start of arrays high byte
00:91C8  D004              :                 BNE     LAB_217E        ; branch if no high byte match

00:91CA  C52F              :                 CMP     Sarryl          ; else compare start of arrays low byte

Portable 65xx Assembler [20.01]

00:91CC  F005              :                 BEQ     LAB_2183        ; branch if = var mem end

                             LAB_217E
00:91CE  201792            :                 JSR     LAB_21D1        ; go garbage collect strings
00:91D1  80F3              :                 BRA     LAB_2176        ; loop always

                             ; done string vars, now do string arrays
                             LAB_2183
00:91D3  8556              :                 STA     Nbendl          ; save start of arrays low byte as working pointer
00:91D5  8657              :                 STX     Nbendh          ; save start of arrays high byte as working pointer
00:91D7  A904              :                 LDA     #$04            ; set step size
00:91D9  8552              :                 STA     g_step          ; save step size
                             LAB_218B
00:91DB  A556              :                 LDA     Nbendl          ; get pointer low byte
00:91DD  A657              :                 LDX     Nbendh          ; get pointer high byte
                             LAB_218F
00:91DF  E432              :                 CPX     Earryh          ; compare with array mem end high byte
00:91E1  D004              :                 BNE     LAB_219A        ; branch if not at end

00:91E3  C531              :                 CMP     Earryl          ; else compare with array mem end low byte
00:91E5  F075              :                 BEQ     LAB_2216        ; tidy up and exit if at end

                             LAB_219A
00:91E7  8523              :                 STA     ut1_pl          ; save pointer low byte
00:91E9  8624              :                 STX     ut1_ph          ; save pointer high byte
00:91EB  A002              :                 LDY     #$02            ; set index
00:91ED  B123              :                 LDA     (ut1_pl),Y      ; get array size low byte
00:91EF  6556              :                 ADC     Nbendl          ; add start of this array low byte
00:91F1  8556              :                 STA     Nbendl          ; save start of next array low byte
00:91F3  C8                :                 INY                     ; increment index
00:91F4  B123              :                 LDA     (ut1_pl),Y      ; get array size high byte
00:91F6  6557              :                 ADC     Nbendh          ; add start of this array high byte
00:91F8  8557              :                 STA     Nbendh          ; save start of next array high byte
00:91FA  A001              :                 LDY     #$01            ; set index
00:91FC  B123              :                 LDA     (ut1_pl),Y      ; get name second byte
00:91FE  10DB              :                 BPL     LAB_218B        ; skip if not string array

                             ; was string array so ..

00:9200  A004              :                 LDY     #$04            ; set index
00:9202  B123              :                 LDA     (ut1_pl),Y      ; get # of dimensions
00:9204  0A                :                 ASL                     ; *2
00:9205  6905              :                 ADC     #$05            ; +5 (array header size)
00:9207  204F92            :                 JSR     LAB_2208        ; go set up for first element
                             LAB_21C4
00:920A  E457              :                 CPX     Nbendh          ; compare with start of next array high byte
00:920C  D004              :                 BNE     LAB_21CC        ; branch if <> (go do this array)

00:920E  C556              :                 CMP     Nbendl          ; else compare element pointer low byte with next array
                             ; low byte
00:9210  F0CD              :                 BEQ     LAB_218F        ; if equal then go do next array

                             LAB_21CC
00:9212  201D92            :                 JSR     LAB_21D7        ; go defrag array strings

Portable 65xx Assembler [20.01]

00:9215  80F3              :                 BRA     LAB_21C4        ; go do next array string (loop always)

                             ; defrag string variables
                             ; enter with XA = variable pointer
                             ; return with XA = next variable pointer

                             LAB_21D1
00:9217  C8                :                 INY                     ; increment index (Y was $00)
00:9218  B123              :                 LDA     (ut1_pl),Y      ; get var name byte 2
00:921A  1030              :                 BPL     LAB_2206        ; if not string, step pointer to next var and return

00:921C  C8                :                 INY                     ; else increment index
                             LAB_21D7
00:921D  B123              :                 LDA     (ut1_pl),Y      ; get string length
00:921F  F02B              :                 BEQ     LAB_2206        ; if null, step pointer to next string and return

00:9221  C8                :                 INY                     ; else increment index
00:9222  B123              :                 LDA     (ut1_pl),Y      ; get string pointer low byte
00:9224  AA                :                 TAX                     ; copy to X
00:9225  C8                :                 INY                     ; increment index
00:9226  B123              :                 LDA     (ut1_pl),Y      ; get string pointer high byte
00:9228  C534              :                 CMP     Sstorh          ; compare bottom of string space high byte
00:922A  9006              :                 BCC     LAB_21EC        ; branch if less

00:922C  D01E              :                 BNE     LAB_2206        ; if greater, step pointer to next string and return

                             ; high bytes were = so compare low bytes
00:922E  E433              :                 CPX     Sstorl          ; compare bottom of string space low byte
00:9230  B01A              :                 BCS     LAB_2206        ; if >=, step pointer to next string and return

                             ; string pointer is < string storage pointer (pos in mem)
                             LAB_21EC
00:9232  C55D              :                 CMP     Histrh          ; compare to highest string high byte
00:9234  9017              :                 BCC     LAB_2207        ; if <, step pointer to next string and return

00:9236  D004              :                 BNE     LAB_21F6        ; if > update pointers, step to next and return

                             ; high bytes were = so compare low bytes
00:9238  E45C              :                 CPX     Histrl          ; compare to highest string low byte
00:923A  9011              :                 BCC     LAB_2207        ; if <, step pointer to next string and return

                             ; string is in string memory space
                             LAB_21F6
00:923C  865C              :                 STX     Histrl          ; save as new highest string low byte
00:923E  855D              :                 STA     Histrh          ; save as new highest string high byte
00:9240  A523              :                 LDA     ut1_pl          ; get start of vars(descriptors) low byte
00:9242  A624              :                 LDX     ut1_ph          ; get start of vars(descriptors) high byte
00:9244  854E              :                 STA     garb_l          ; save as working pointer low byte
00:9246  864F              :                 STX     garb_h          ; save as working pointer high byte
00:9248  88                :                 DEY                     ; decrement index DIFFERS
00:9249  88                :                 DEY                     ; decrement index (should point to descriptor start)
00:924A  8454              :                 STY     g_indx          ; save index pointer

                             ; step pointer to next string

Portable 65xx Assembler [20.01]

                             LAB_2206
00:924C  18                :                 CLC                     ; clear carry for add
                             LAB_2207
00:924D  A552              :                 LDA     g_step          ; get step size
                             LAB_2208
00:924F  6523              :                 ADC     ut1_pl          ; add pointer low byte
00:9251  8523              :                 STA     ut1_pl          ; save pointer low byte
00:9253  9002              :                 BCC     LAB_2211        ; branch if no overflow

00:9255  E624              :                 INC     ut1_ph          ; else increment high byte
                             LAB_2211
00:9257  A624              :                 LDX     ut1_ph          ; get pointer high byte
00:9259  A000              :                 LDY     #$00            ; clear Y
00:925B  60                :                 RTS

                             ; search complete, now either exit or set-up and move string

                             LAB_2216
00:925C  C652              :                 DEC     g_step          ; decrement step size (now $03 for descriptor stack)
00:925E  A64F              :                 LDX     garb_h          ; get string to move high byte
00:9260  F0F5              :                 BEQ     LAB_2211        ; exit if nothing to move

00:9262  A454              :                 LDY     g_indx          ; get index byte back (points to descriptor)
00:9264  18                :                 CLC                     ; clear carry for add
00:9265  B14E              :                 LDA     (garb_l),Y      ; get string length
00:9267  655C              :                 ADC     Histrl          ; add highest string low byte
00:9269  8558              :                 STA     Obendl          ; save old block end low pointer
00:926B  A55D              :                 LDA     Histrh          ; get highest string high byte
00:926D  6900              :                 ADC     #$00            ; add any carry
00:926F  8559              :                 STA     Obendh          ; save old block end high byte
00:9271  A533              :                 LDA     Sstorl          ; get bottom of string space low byte
00:9273  A634              :                 LDX     Sstorh          ; get bottom of string space high byte
00:9275  8556              :                 STA     Nbendl          ; save new block end low byte
00:9277  8657              :                 STX     Nbendh          ; save new block end high byte
00:9279  20BD80            :                 JSR     LAB_11D6        ; open up space in memory, don't set array end
00:927C  A454              :                 LDY     g_indx          ; get index byte
00:927E  C8                :                 INY                     ; point to descriptor low byte
00:927F  A556              :                 LDA     Nbendl          ; get string pointer low byte
00:9281  914E              :                 STA     (garb_l),Y      ; save new string pointer low byte
00:9283  AA                :                 TAX                     ; copy string pointer low byte
00:9284  E657              :                 INC     Nbendh          ; correct high byte (move sets high byte -1)
00:9286  A557              :                 LDA     Nbendh          ; get new string pointer high byte
00:9288  C8                :                 INY                     ; point to descriptor high byte
00:9289  914E              :                 STA     (garb_l),Y      ; save new string pointer high byte
00:928B  4C9F91            :                 JMP     LAB_214B        ; re-run routine from last ending
                             ; (but don't collect this string)

                             ; concatenate
                             ; add strings, string 1 is in descriptor des_pl, string 2 is in line

                             LAB_224D
00:928E  A561              :                 LDA     des_ph          ; get descriptor pointer high byte
00:9290  48                :                 PHA                     ; put on stack
00:9291  A560              :                 LDA     des_pl          ; get descriptor pointer low byte

Portable 65xx Assembler [20.01]

00:9293  48                :                 PHA                     ; put on stack
00:9294  20958B            :                 JSR     LAB_GVAL        ; get value from line
00:9297  209D8A            :                 JSR     LAB_CTST        ; check if source is string, else do type mismatch
00:929A  68                :                 PLA                     ; get descriptor pointer low byte back
00:929B  856A              :                 STA     ssptr_l         ; set pointer low byte
00:929D  68                :                 PLA                     ; get descriptor pointer high byte back
00:929E  856B              :                 STA     ssptr_h         ; set pointer high byte
00:92A0  B26A              :                 LDA     (ssptr_l)       ; get length_1 from descriptor
00:92A2  18                :                 CLC                     ; clear carry for add
00:92A3  7260              :                 ADC     (des_pl)        ; add length_2
00:92A5  9005              :                 BCC     LAB_226D        ; branch if no overflow

00:92A7  A21A              :                 LDX     #$1A            ; else set error code $1A ("String too long" error)
00:92A9  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             LAB_226D
00:92AC  20ED90            :                 JSR     LAB_209C        ; copy des_pl/h to des_2l/h and make string space A bytes
                             ; long
00:92AF  20C992            :                 JSR     LAB_228A        ; copy string from descriptor (sdescr) to (Sutill)
00:92B2  A550              :                 LDA     des_2l          ; get descriptor pointer low byte
00:92B4  A451              :                 LDY     des_2h          ; get descriptor pointer high byte
00:92B6  20FA92            :                 JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
                             ; returns with A = length, ut1_pl = pointer low byte,
                             ; ut1_ph = pointer high byte
00:92B9  20DB92            :                 JSR     LAB_229C        ; store string A bytes long from (ut1_pl) to (Sutill)
00:92BC  A56A              :                 LDA     ssptr_l         ; set descriptor pointer low byte
00:92BE  A46B              :                 LDY     ssptr_h         ; set descriptor pointer high byte
00:92C0  20FA92            :                 JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
                             ; returns with A = length, X=ut1_pl=pointer low byte,
                             ; Y=ut1_ph=pointer high byte
00:92C3  204291            :                 JSR     LAB_RTST        ; check for space on descriptor stack then put string
                             ; address and length on descriptor stack and update stack
                             ; pointers
00:92C6  4CC18A            :                 JMP     LAB_1ADB        ; continue evaluation

                             ; copy string from descriptor (sdescr) to (Sutill)

                             LAB_228A
00:92C9  A000              :                 LDY     #$00            ; clear index
00:92CB  B16A              :                 LDA     (sdescr),Y      ; get string length
00:92CD  48                :                 PHA                     ; save on stack
00:92CE  C8                :                 INY                     ; increment index
00:92CF  B16A              :                 LDA     (sdescr),Y      ; get source string pointer low byte
00:92D1  AA                :                 TAX                     ; copy to X
00:92D2  C8                :                 INY                     ; increment index
00:92D3  B16A              :                 LDA     (sdescr),Y      ; get source string pointer high byte
00:92D5  A8                :                 TAY                     ; copy to Y
00:92D6  68                :                 PLA                     ; get length back

                             ; store string A bytes long from YX to (Sutill)

                             LAB_2298
00:92D7  8623              :                 STX     ut1_pl          ; save source string pointer low byte
00:92D9  8424              :                 STY     ut1_ph          ; save source string pointer high byte

Portable 65xx Assembler [20.01]


                             ; store string A bytes long from (ut1_pl) to (Sutill)

                             LAB_229C
00:92DB  AA                :                 TAX                     ; copy length to index (don't count with Y)
00:92DC  F014              :                 BEQ     LAB_22B2        ; branch if = $0 (null string) no need to add zero length

00:92DE  A000              :                 LDY     #$00            ; zero pointer (copy forward)
                             LAB_22A0
00:92E0  B123              :                 LDA     (ut1_pl),Y      ; get source byte
00:92E2  9135              :                 STA     (Sutill),Y      ; save destination byte

00:92E4  C8                :                 INY                     ; increment index
00:92E5  CA                :                 DEX                     ; decrement counter
00:92E6  D0F8              :                 BNE     LAB_22A0        ; loop while <> 0

00:92E8  98                :                 TYA                     ; restore length from Y
                             LAB_22A9
00:92E9  18                :                 CLC                     ; clear carry for add
00:92EA  6535              :                 ADC     Sutill          ; add string utility ptr low byte
00:92EC  8535              :                 STA     Sutill          ; save string utility ptr low byte
00:92EE  9002              :                 BCC     LAB_22B2        ; branch if no carry

00:92F0  E636              :                 INC     Sutilh          ; else increment string utility ptr high byte
                             LAB_22B2
00:92F2  60                :                 RTS

                             ; evaluate string

                             LAB_EVST
00:92F3  209D8A            :                 JSR     LAB_CTST        ; check if source is string, else do type mismatch

                             ; pop string off descriptor stack, or from top of string space
                             ; returns with A = length, X=pointer low byte, Y=pointer high byte

                             LAB_22B6
00:92F6  A560              :                 LDA     des_pl          ; get descriptor pointer low byte
00:92F8  A461              :                 LDY     des_ph          ; get descriptor pointer high byte

                             ; pop (YA) descriptor off stack or from top of string space
                             ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte

                             LAB_22BA
00:92FA  8523              :                 STA     ut1_pl          ; save descriptor pointer low byte
00:92FC  8424              :                 STY     ut1_ph          ; save descriptor pointer high byte
00:92FE  202B93            :                 JSR     LAB_22EB        ; clean descriptor stack, YA = pointer
00:9301  08                :                 PHP                     ; save status flags
00:9302  A000              :                 LDY     #$00            ; clear index
00:9304  B123              :                 LDA     (ut1_pl),Y      ; get length from string descriptor
00:9306  48                :                 PHA                     ; put on stack
00:9307  C8                :                 INY                     ; increment index
00:9308  B123              :                 LDA     (ut1_pl),Y      ; get string pointer low byte from descriptor
00:930A  AA                :                 TAX                     ; copy to X
00:930B  C8                :                 INY                     ; increment index

Portable 65xx Assembler [20.01]

00:930C  B123              :                 LDA     (ut1_pl),Y      ; get string pointer high byte from descriptor
00:930E  A8                :                 TAY                     ; copy to Y
00:930F  68                :                 PLA                     ; get string length back
00:9310  28                :                 PLP                     ; restore status
00:9311  D013              :                 BNE     LAB_22E6        ; branch if pointer <> last_sl,last_sh

00:9313  C434              :                 CPY     Sstorh          ; compare bottom of string space high byte
00:9315  D00F              :                 BNE     LAB_22E6        ; branch if <>

00:9317  E433              :                 CPX     Sstorl          ; else compare bottom of string space low byte
00:9319  D00B              :                 BNE     LAB_22E6        ; branch if <>

00:931B  48                :                 PHA                     ; save string length
00:931C  18                :                 CLC                     ; clear carry for add
00:931D  6533              :                 ADC     Sstorl          ; add bottom of string space low byte
00:931F  8533              :                 STA     Sstorl          ; save bottom of string space low byte
00:9321  9002              :                 BCC     LAB_22E5        ; skip increment if no overflow

00:9323  E634              :                 INC     Sstorh          ; increment bottom of string space high byte
                             LAB_22E5
00:9325  68                :                 PLA                     ; restore string length
                             LAB_22E6
00:9326  8623              :                 STX     ut1_pl          ; save string pointer low byte
00:9328  8424              :                 STY     ut1_ph          ; save string pointer high byte
00:932A  60                :                 RTS

                             ; clean descriptor stack, YA = pointer
                             ; checks if AY is on the descriptor stack, if so does a stack discard

                             LAB_22EB
00:932B  C419              :                 CPY     last_sh         ; compare pointer high byte
00:932D  D00C              :                 BNE     LAB_22FB        ; exit if <>

00:932F  C518              :                 CMP     last_sl         ; compare pointer low byte
00:9331  D008              :                 BNE     LAB_22FB        ; exit if <>

00:9333  8517              :                 STA     next_s          ; save descriptor stack pointer
00:9335  E903              :                 SBC     #$03            ; -3
00:9337  8518              :                 STA     last_sl         ; save low byte -3
00:9339  A000              :                 LDY     #$00            ; clear high byte
                             LAB_22FB
00:933B  60                :                 RTS

                             ; perform CHR$()

                             LAB_CHRS
00:933C  204094            :                 JSR     LAB_EVBY        ; evaluate byte expression, result in X
00:933F  DA                :                 PHX                     ; save character to stack
00:9340  A901              :                 LDA     #$01            ; string is single byte
00:9342  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00:9345  68                :                 PLA                     ; get character back
00:9346  925F              :                 STA     (str_pl)        ; save byte in string (byte IS string!)
00:9348  4C4291            :                 JMP     LAB_RTST        ; check for space on descriptor stack then put string

Portable 65xx Assembler [20.01]

                             ; address and length on descriptor stack and update stack
                             ; pointers

                             ; perform LEFT$()

                             LAB_LEFT
00:934B  48                :                 PHA                     ; push byte parameter
00:934C  20AB93            :                 JSR     LAB_236F        ; pull string data and byte parameter from stack
                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00:934F  D150              :                 CMP     (des_2l),Y      ; compare byte parameter with string length
00:9351  98                :                 TYA                     ; clear A
00:9352  8009              :                 BRA     LAB_2316        ; go do string copy (branch always)

                             ; perform RIGHT$()

                             LAB_RIGHT
00:9354  48                :                 PHA                     ; push byte parameter
00:9355  20AB93            :                 JSR     LAB_236F        ; pull string data and byte parameter from stack
                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00:9358  18                :                 CLC                     ; clear carry for add-1
00:9359  F150              :                 SBC     (des_2l),Y      ; subtract string length
00:935B  49FF              :                 EOR     #$FF            ; invert it (A=LEN(expression$)-l)

                             LAB_2316
00:935D  9004              :                 BCC     LAB_231C        ; branch if string length > byte parameter

00:935F  B150              :                 LDA     (des_2l),Y      ; else make parameter = length
00:9361  AA                :                 TAX                     ; copy to byte parameter copy
00:9362  98                :                 TYA                     ; clear string start offset
                             LAB_231C
00:9363  48                :                 PHA                     ; save string start offset
                             LAB_231D
00:9364  8A                :                 TXA                     ; copy byte parameter (or string length if <)
                             LAB_231E
00:9365  48                :                 PHA                     ; save string length
00:9366  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long A=$AC=length,
                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00:9369  A550              :                 LDA     des_2l          ; get descriptor pointer low byte
00:936B  A451              :                 LDY     des_2h          ; get descriptor pointer high byte
00:936D  20FA92            :                 JSR     LAB_22BA        ; pop (YA) descriptor off stack or from top of string space
                             ; returns with A = length, X=ut1_pl=pointer low byte,
                             ; Y=ut1_ph=pointer high byte
00:9370  7A                :                 PLY                     ; get string length back
00:9371  68                :                 PLA                     ; get string start offset back
00:9372  18                :                 CLC                     ; clear carry for add
00:9373  6523              :                 ADC     ut1_pl          ; add start offset to string start pointer low byte
00:9375  8523              :                 STA     ut1_pl          ; save string start pointer low byte
00:9377  9002              :                 BCC     LAB_2335        ; branch if no overflow

00:9379  E624              :                 INC     ut1_ph          ; else increment string start pointer high byte
                             LAB_2335
00:937B  98                :                 TYA                     ; copy length to A
00:937C  20DB92            :                 JSR     LAB_229C        ; store string A bytes long from (ut1_pl) to (Sutill)
00:937F  4C4291            :                 JMP     LAB_RTST        ; check for space on descriptor stack then put string

Portable 65xx Assembler [20.01]

                             ; address and length on descriptor stack and update stack
                             ; pointers

                             ; perform MID$()

                             LAB_MIDS
00:9382  48                :                 PHA                     ; push byte parameter
00:9383  A9FF              :                 LDA     #$FF            ; set default length = 255
00:9385  8561              :                 STA     mids_l          ; save default length
00:9387  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:938A  C929              :                 CMP     #')'            ; compare with ")"
00:938C  F006              :                 BEQ     LAB_2358        ; branch if = ")" (skip second byte get)

00:938E  20C48B            :                 JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
00:9391  203D94            :                 JSR     LAB_GTBY        ; get byte parameter (use copy in mids_l)
                             LAB_2358
00:9394  20AB93            :                 JSR     LAB_236F        ; pull string data and byte parameter from stack
                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00:9397  CA                :                 DEX                     ; decrement start index
00:9398  8A                :                 TXA                     ; copy to A
00:9399  48                :                 PHA                     ; save string start offset
00:939A  18                :                 CLC                     ; clear carry for sub-1
00:939B  A200              :                 LDX     #$00            ; clear output string length
00:939D  F150              :                 SBC     (des_2l),Y      ; subtract string length
00:939F  B0C3              :                 BCS     LAB_231D        ; if start>string length go do null string

00:93A1  49FF              :                 EOR     #$FF            ; complement -length
00:93A3  C561              :                 CMP     mids_l          ; compare byte parameter
00:93A5  90BE              :                 BCC     LAB_231E        ; if length>remaining string go do RIGHT$

00:93A7  A561              :                 LDA     mids_l          ; get length byte
00:93A9  80BA              :                 BRA     LAB_231E        ; go do string copy (branch always)

                             ; pull string data and byte parameter from stack
                             ; return pointer in des_2l/h, byte in A (and X), Y=0

                             LAB_236F
00:93AB  20B78B            :                 JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
00:93AE  68                :                 PLA                     ; pull return address low byte (return address)
00:93AF  8554              :                 STA     Fnxjpl          ; save functions jump vector low byte
00:93B1  68                :                 PLA                     ; pull return address high byte (return address)
00:93B2  8555              :                 STA     Fnxjph          ; save functions jump vector high byte
00:93B4  FA                :                 PLX                     ; get byte parameter
00:93B5  68                :                 PLA                     ; pull string pointer low byte
00:93B6  8550              :                 STA     des_2l          ; save it
00:93B8  68                :                 PLA                     ; pull string pointer high byte
00:93B9  8551              :                 STA     des_2h          ; save it
00:93BB  A000              :                 LDY     #$00            ; clear index
00:93BD  8A                :                 TXA                     ; copy byte parameter
00:93BE  F077              :                 BEQ     LAB_23A8        ; if null do function call error then warm start

00:93C0  E654              :                 INC     Fnxjpl          ; increment function jump vector low byte
                             ; (JSR pushes return addr-1. this is all very nice
                             ; but will go tits up if either call is on a page

Portable 65xx Assembler [20.01]

                             ; boundary!)
00:93C2  6C5400            :                 JMP     (Fnxjpl)        ; in effect, RTS

                             ; perform LCASE$()

                             LAB_LCASE
00:93C5  20F392            :                 JSR     LAB_EVST        ; evaluate string
00:93C8  855E              :                 STA     str_ln          ; set string length
00:93CA  A8                :                 TAY                     ; copy length to Y
00:93CB  F038              :                 BEQ     NoString        ; branch if null string

00:93CD  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long A=length,
                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00:93D0  865F              :                 STX     str_pl          ; save string pointer low byte
00:93D2  8460              :                 STY     str_ph          ; save string pointer high byte
00:93D4  A8                :                 TAY                     ; get string length back

                             LC_loop
00:93D5  88                :                 DEY                     ; decrement index
00:93D6  B123              :                 LDA     (ut1_pl),Y      ; get byte from string
00:93D8  20E08D            :                 JSR     LAB_1D82        ; is character "A" to "Z"
00:93DB  9002              :                 BCC     NoUcase         ; branch if not upper case alpha

00:93DD  0920              :                 ORA     #$20            ; convert upper to lower case
                             NoUcase
00:93DF  9135              :                 STA     (Sutill),Y      ; save byte back to string
00:93E1  98                :                 TYA                     ; test index
00:93E2  D0F1              :                 BNE     LC_loop         ; loop if not all done

00:93E4  801F              :                 BRA     NoString        ; tidy up and exit, branch always

                             ; perform UCASE$()

                             LAB_UCASE
00:93E6  20F392            :                 JSR     LAB_EVST        ; evaluate string
00:93E9  855E              :                 STA     str_ln          ; set string length
00:93EB  A8                :                 TAY                     ; copy length to Y
00:93EC  F017              :                 BEQ     NoString        ; branch if null string

00:93EE  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long A=length,
                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00:93F1  865F              :                 STX     str_pl          ; save string pointer low byte
00:93F3  8460              :                 STY     str_ph          ; save string pointer high byte
00:93F5  A8                :                 TAY                     ; get string length back

                             UC_loop
00:93F6  88                :                 DEY                     ; decrement index
00:93F7  B123              :                 LDA     (ut1_pl),Y      ; get byte from string
00:93F9  20DC8D            :                 JSR     LAB_CASC        ; is character "a" to "z" (or "A" to "Z")
00:93FC  9002              :                 BCC     NoLcase         ; branch if not alpha

00:93FE  29DF              :                 AND     #$DF            ; convert lower to upper case
                             NoLcase
00:9400  9135              :                 STA     (Sutill),Y      ; save byte back to string

Portable 65xx Assembler [20.01]

00:9402  98                :                 TYA                     ; test index
00:9403  D0F1              :                 BNE     UC_loop         ; loop if not all done

                             NoString
00:9405  4C4291            :                 JMP     LAB_RTST        ; check for space on descriptor stack then put string
                             ; address and length on descriptor stack and update stack
                             ; pointers

                             ; perform SADD()

                             LAB_SADD
00:9408  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:940B  206A8D            :                 JSR     LAB_GVAR        ; get var address

00:940E  20B78B            :                 JSR     LAB_1BFB        ; scan for ")", else do syntax error then warm start
00:9411  209D8A            :                 JSR     LAB_CTST        ; check if source is string, else do type mismatch

00:9414  A002              :                 LDY     #$02            ; index to string pointer high byte
00:9416  B147              :                 LDA     (Cvaral),Y      ; get string pointer high byte
00:9418  AA                :                 TAX                     ; copy string pointer high byte to X
00:9419  88                :                 DEY                     ; index to string pointer low byte
00:941A  B147              :                 LDA     (Cvaral),Y      ; get string pointer low byte
00:941C  A8                :                 TAY                     ; copy string pointer low byte to Y
00:941D  8A                :                 TXA                     ; copy string pointer high byte to A
00:941E  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; perform LEN()

                             LAB_LENS
00:9421  202794            :                 JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
00:9424  4C2390            :                 JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return

                             ; evaluate string, get length in Y

                             LAB_ESGL
00:9427  20F392            :                 JSR     LAB_EVST        ; evaluate string
00:942A  A8                :                 TAY                     ; copy length to Y
00:942B  60                :                 RTS

                             ; perform ASC()

                             LAB_ASC
00:942C  202794            :                 JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
00:942F  F006              :                 BEQ     LAB_23A8        ; if null do function call error then warm start

00:9431  B223              :                 LDA     (ut1_pl)        ; get byte
00:9433  A8                :                 TAY                     ; copy to Y
00:9434  4C2390            :                 JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return

                             ; do function call error then warm start

                             LAB_23A8
00:9437  4CE68E            :                 JMP     LAB_FCER        ; do function call error then warm start


Portable 65xx Assembler [20.01]

                             ; scan and get byte parameter

                             LAB_SGBY
00:943A  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory

                             ; get byte parameter

                             LAB_GTBY
00:943D  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch

                             ; evaluate byte expression, result in X

                             LAB_EVBY
00:9440  20608E            :                 JSR     LAB_EVPI        ; evaluate integer expression (no check)

00:9443  A460              :                 LDY     FAC1_2          ; get FAC1 mantissa2
00:9445  D0F0              :                 BNE     LAB_23A8        ; if top byte <> 0 do function call error then warm start

00:9447  A661              :                 LDX     FAC1_3          ; get FAC1 mantissa3
00:9449  4CDE9F            :                 JMP     LAB_GBYT        ; scan memory and return

                             ; perform VAL()

                             LAB_VAL
00:944C  202794            :                 JSR     LAB_ESGL        ; evaluate string, get length in A (and Y)
00:944F  D003              :                 BNE     LAB_23C5        ; branch if not null string

                             ; string was null so set result = $00
00:9451  4CF995            :                 JMP     LAB_24F1        ; clear FAC1 exponent and sign and return

                             LAB_23C5
00:9454  A66E              :                 LDX     Bpntrl          ; get BASIC execute pointer low byte
00:9456  A46F              :                 LDY     Bpntrh          ; get BASIC execute pointer high byte
00:9458  866C              :                 STX     Btmpl           ; save BASIC execute pointer low byte
00:945A  846D              :                 STY     Btmph           ; save BASIC execute pointer high byte
00:945C  A623              :                 LDX     ut1_pl          ; get string pointer low byte
00:945E  866E              :                 STX     Bpntrl          ; save as BASIC execute pointer low byte
00:9460  18                :                 CLC                     ; clear carry
00:9461  6523              :                 ADC     ut1_pl          ; add string length
00:9463  8525              :                 STA     ut2_pl          ; save string end low byte
00:9465  A524              :                 LDA     ut1_ph          ; get string pointer high byte
00:9467  856F              :                 STA     Bpntrh          ; save as BASIC execute pointer high byte
00:9469  6900              :                 ADC     #$00            ; add carry to high byte
00:946B  8526              :                 STA     ut2_ph          ; save string end high byte
00:946D  B225              :                 LDA     (ut2_pl)        ; get string end +1 byte
00:946F  48                :                 PHA                     ; push it
00:9470  A900              :                 LDA     #$00            ; clear A
00:9472  9225              :                 STA     (ut2_pl)        ; terminate string with $00
00:9474  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:9477  204799            :                 JSR     LAB_2887        ; get FAC1 from string
00:947A  68                :                 PLA                     ; restore string end +1 byte
00:947B  9225              :                 STA     (ut2_pl)        ; put string end byte back


Portable 65xx Assembler [20.01]

                             ; restore BASIC execute pointer from temp (Btmpl/Btmph)

                             LAB_23F3
00:947D  A66C              :                 LDX     Btmpl           ; get BASIC execute pointer low byte back
00:947F  A46D              :                 LDY     Btmph           ; get BASIC execute pointer high byte back
00:9481  866E              :                 STX     Bpntrl          ; save BASIC execute pointer low byte
00:9483  846F              :                 STY     Bpntrh          ; save BASIC execute pointer high byte
00:9485  60                :                 RTS

                             ; get two parameters for POKE or WAIT

                             LAB_GADB
00:9486  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
00:9489  209F94            :                 JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer

                             ; scan for "," and get byte, else do Syntax error then warm start

                             LAB_SCGB
00:948C  20C48B            :                 JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
00:948F  A50B              :                 LDA     Itemph          ; save temporary integer high byte
00:9491  48                :                 PHA                     ; on stack
00:9492  A50A              :                 LDA     Itempl          ; save temporary integer low byte
00:9494  48                :                 PHA                     ; on stack
00:9495  203D94            :                 JSR     LAB_GTBY        ; get byte parameter
00:9498  68                :                 PLA                     ; pull low byte
00:9499  850A              :                 STA     Itempl          ; restore temporary integer low byte
00:949B  68                :                 PLA                     ; pull high byte
00:949C  850B              :                 STA     Itemph          ; restore temporary integer high byte
00:949E  60                :                 RTS

                             ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
                             ; -ve and converts it into a right truncated integer in Itempl and Itemph

                             ; save unsigned 16 bit integer part of FAC1 in temporary integer

                             LAB_F2FX
00:949F  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:94A1  C998              :                 CMP     #$98            ; compare with exponent = 2^24
00:94A3  B092              :                 BCS     LAB_23A8        ; if >= do function call error then warm start

                             LAB_F2FU
00:94A5  20F198            :                 JSR     LAB_2831        ; convert FAC1 floating-to-fixed
00:94A8  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:94AA  A461              :                 LDY     FAC1_3          ; get FAC1 mantissa3
00:94AC  840A              :                 STY     Itempl          ; save temporary integer low byte
00:94AE  850B              :                 STA     Itemph          ; save temporary integer high byte
00:94B0  60                :                 RTS

                             ; perform PEEK()

                             LAB_PEEK
00:94B1  209F94            :                 JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
00:94B4  A200              :                 LDX     #$00            ; clear index

Portable 65xx Assembler [20.01]

00:94B6  A10A              :                 LDA     (Itempl,X)      ; get byte via temporary integer (addr)
00:94B8  A8                :                 TAY                     ; copy byte to Y
00:94B9  4C2390            :                 JMP     LAB_1FD0        ; convert Y to byte in FAC1 and return

                             ; perform POKE

                             LAB_POKE
00:94BC  208694            :                 JSR     LAB_GADB        ; get two parameters for POKE or WAIT
00:94BF  8A                :                 TXA                     ; copy byte argument to A
00:94C0  A200              :                 LDX     #$00            ; clear index
00:94C2  810A              :                 STA     (Itempl,X)      ; save byte via temporary integer (addr)
00:94C4  60                :                 RTS

                             ; perform DEEK()

                             LAB_DEEK
00:94C5  209F94            :                 JSR     LAB_F2FX        ; save integer part of FAC1 in temporary integer
00:94C8  A200              :                 LDX     #$00            ; clear index
00:94CA  A10A              :                 LDA     (Itempl,X)      ; PEEK low byte
00:94CC  A8                :                 TAY                     ; copy to Y
00:94CD  E60A              :                 INC     Itempl          ; increment pointer low byte
00:94CF  D002              :                 BNE     Deekh           ; skip high increment if no rollover

00:94D1  E60B              :                 INC     Itemph          ; increment pointer high byte
                             Deekh
00:94D3  A10A              :                 LDA     (Itempl,X)      ; PEEK high byte
00:94D5  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; perform DOKE

                             LAB_DOKE
00:94D8  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
00:94DB  209F94            :                 JSR     LAB_F2FX        ; convert floating-to-fixed

00:94DE  8449              :                 STY     Frnxtl          ; save pointer low byte (float to fixed returns word in AY)
00:94E0  854A              :                 STA     Frnxth          ; save pointer high byte

00:94E2  20C48B            :                 JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
00:94E5  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
00:94E8  209F94            :                 JSR     LAB_F2FX        ; convert floating-to-fixed

00:94EB  98                :                 TYA                     ; copy value low byte (float to fixed returns word in AY)
00:94EC  A200              :                 LDX     #$00            ; clear index
00:94EE  8149              :                 STA     (Frnxtl,X)      ; POKE low byte
00:94F0  E649              :                 INC     Frnxtl          ; increment pointer low byte
00:94F2  D002              :                 BNE     Dokeh           ; skip high increment if no rollover

00:94F4  E64A              :                 INC     Frnxth          ; increment pointer high byte
                             Dokeh
00:94F6  A50B              :                 LDA     Itemph          ; get value high byte
00:94F8  8149              :                 STA     (Frnxtl,X)      ; POKE high byte
00:94FA  4CDE9F            :                 JMP     LAB_GBYT        ; scan memory and return

Portable 65xx Assembler [20.01]


                             ; perform SWAP

                             LAB_SWAP
00:94FD  206A8D            :                 JSR     LAB_GVAR        ; get var1 address
00:9500  8549              :                 STA     Lvarpl          ; save var1 address low byte
00:9502  844A              :                 STY     Lvarph          ; save var1 address high byte
00:9504  A511              :                 LDA     Dtypef          ; get data type flag, $FF=string, $00=numeric
00:9506  48                :                 PHA                     ; save data type flag

00:9507  20C48B            :                 JSR     LAB_1C01        ; scan for "," , else do syntax error then warm start
00:950A  206A8D            :                 JSR     LAB_GVAR        ; get var2 address (pointer in Cvaral/h)
00:950D  68                :                 PLA                     ; pull var1 data type flag
00:950E  4511              :                 EOR     Dtypef          ; compare with var2 data type
00:9510  1010              :                 BPL     SwapErr         ; exit if not both the same type

00:9512  A003              :                 LDY     #$03            ; four bytes to swap (either value or descriptor+1)
                             SwapLp
00:9514  B149              :                 LDA     (Lvarpl),Y      ; get byte from var1
00:9516  AA                :                 TAX                     ; save var1 byte
00:9517  B147              :                 LDA     (Cvaral),Y      ; get byte from var2
00:9519  9149              :                 STA     (Lvarpl),Y      ; save byte to var1
00:951B  8A                :                 TXA                     ; restore var1 byte
00:951C  9147              :                 STA     (Cvaral),Y      ; save byte to var2
00:951E  88                :                 DEY                     ; decrement index
00:951F  10F3              :                 BPL     SwapLp          ; loop until done

00:9521  60                :                 RTS

                             SwapErr
00:9522  4CA78A            :                 JMP     LAB_1ABC        ; do "Type mismatch" error then warm start

                             ; perform CALL

                             LAB_CALL
00:9525  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch
00:9528  209F94            :                 JSR     LAB_F2FX        ; convert floating-to-fixed
00:952B  A995              :                 LDA     #>CallExit      ; set return address high byte
00:952D  48                :                 PHA                     ; put on stack
00:952E  A933              :                 LDA     #<CallExit-1    ; set return address low byte
00:9530  48                :                 PHA                     ; put on stack
00:9531  6C0A00            :                 JMP     (Itempl)        ; do indirect jump to user routine

                             ; if the called routine exits correctly then it will return to here. this will then get
                             ; the next byte for the interpreter and return

                             CallExit
00:9534  4CDE9F            :                 JMP     LAB_GBYT        ; scan memory and return

                             ; perform WAIT

                             LAB_WAIT
00:9537  208694            :                 JSR     LAB_GADB        ; get two parameters for POKE or WAIT

Portable 65xx Assembler [20.01]

00:953A  8649              :                 STX     Frnxtl          ; save byte
00:953C  A200              :                 LDX     #$00            ; clear mask
00:953E  20DE9F            :                 JSR     LAB_GBYT        ; scan memory
00:9541  F003              :                 BEQ     LAB_2441        ; skip if no third argument

00:9543  208C94            :                 JSR     LAB_SCGB        ; scan for "," and get byte, else SN error then warm start
                             LAB_2441
00:9546  864A              :                 STX     Frnxth          ; save EOR argument
                             LAB_2445
00:9548  B10A              :                 LDA     (Itempl),Y      ; get byte via temporary integer (addr)
00:954A  454A              :                 EOR     Frnxth          ; EOR with second argument (mask)
00:954C  2549              :                 AND     Frnxtl          ; AND with first argument (byte)
00:954E  F0F8              :                 BEQ     LAB_2445        ; loop if result is zero

                             LAB_244D
00:9550  60                :                 RTS

                             ; perform subtraction, FAC1 from (AY)

                             LAB_2455
00:9551  203297            :                 JSR     LAB_264D        ; unpack memory (AY) into FAC2

                             ; perform subtraction, FAC1 from FAC2

                             LAB_SUBTRACT
00:9554  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9556  49FF              :                 EOR     #$FF            ; complement it
00:9558  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
00:955A  4569              :                 EOR     FAC2_s          ; EOR with FAC2 sign (b7)
00:955C  856A              :                 STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00:955E  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9560  800C              :                 BRA     LAB_ADD         ; go add FAC2 to FAC1

                             ; perform addition

                             LAB_2467
00:9562  208396            :                 JSR     LAB_257B        ; shift FACX A times right (>8 shifts)
00:9565  9049              :                 BCC     LAB_24A8        ; go subtract mantissas

                             ; add 0.5 to FAC1

                             LAB_244E
00:9567  A9BA              :                 LDA     #<LAB_2A96      ; set 0.5 pointer low byte
00:9569  A0A0              :                 LDY     #>LAB_2A96      ; set 0.5 pointer high byte

                             ; add (AY) to FAC1

                             LAB_246C
00:956B  203297            :                 JSR     LAB_264D        ; unpack memory (AY) into FAC2

                             ; add FAC2 to FAC1

                             LAB_ADD
00:956E  D010              :                 BNE     LAB_2474        ; branch if FAC1 was not zero

Portable 65xx Assembler [20.01]


                             ; copy FAC2 to FAC1

                             LAB_279B
00:9570  A569              :                 LDA     FAC2_s          ; get FAC2 sign (b7)

                             ; save FAC1 sign and copy ABS(FAC2) to FAC1

                             LAB_279D
00:9572  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
00:9574  A204              :                 LDX     #$04            ; 4 bytes to copy
                             LAB_27A1
00:9576  B564              :                 LDA     FAC1_o,X        ; get byte from FAC2,X
00:9578  955D              :                 STA     FAC1_e-1,X      ; save byte at FAC1,X
00:957A  CA                :                 DEX                     ; decrement count
00:957B  D0F9              :                 BNE     LAB_27A1        ; loop if not all done

00:957D  866B              :                 STX     FAC1_r          ; clear FAC1 rounding byte
00:957F  60                :                 RTS

                             ; FAC1 is non zero
                             LAB_2474
00:9580  A66B              :                 LDX     FAC1_r          ; get FAC1 rounding byte
00:9582  8655              :                 STX     FAC2_r          ; save as FAC2 rounding byte
00:9584  A265              :                 LDX     #FAC2_e         ; set index to FAC2 exponent addr
00:9586  A565              :                 LDA     FAC2_e          ; get FAC2 exponent
                             LAB_247C
00:9588  A8                :                 TAY                     ; copy exponent
00:9589  F0C5              :                 BEQ     LAB_244D        ; exit if zero

00:958B  38                :                 SEC                     ; set carry for subtract
00:958C  E55E              :                 SBC     FAC1_e          ; subtract FAC1 exponent
00:958E  F020              :                 BEQ     LAB_24A8        ; branch if = (go add mantissa)

00:9590  9010              :                 BCC     LAB_2498        ; branch if <

                             ; FAC2>FAC1
00:9592  845E              :                 STY     FAC1_e          ; save FAC1 exponent
00:9594  A469              :                 LDY     FAC2_s          ; get FAC2 sign (b7)
00:9596  8462              :                 STY     FAC1_s          ; save FAC1 sign (b7)
00:9598  49FF              :                 EOR     #$FF            ; complement A
00:959A  6900              :                 ADC     #$00            ; +1 (twos complement, carry is set)
00:959C  6455              :                 STZ     FAC2_r          ; clear FAC2 rounding byte
00:959E  A25E              :                 LDX     #FAC1_e         ; set index to FAC1 exponent addr
00:95A0  8002              :                 BRA     LAB_249C        ; branch always

                             LAB_2498
00:95A2  646B              :                 STZ     FAC1_r          ; clear FAC1 rounding byte
                             LAB_249C
00:95A4  C9F9              :                 CMP     #$F9            ; compare exponent diff with $F9
00:95A6  30BA              :                 BMI     LAB_2467        ; branch if range $79-$F8

00:95A8  A8                :                 TAY                     ; copy exponent difference to Y
00:95A9  A56B              :                 LDA     FAC1_r          ; get FAC1 rounding byte

Portable 65xx Assembler [20.01]

00:95AB  5601              :                 LSR     PLUS_1,X        ; shift FAC? mantissa1
00:95AD  209A96            :                 JSR     LAB_2592        ; shift FACX Y times right

                             ; exponents are equal now do mantissa subtract
                             LAB_24A8
00:95B0  246A              :                 BIT     FAC_sc          ; test sign compare (FAC1 EOR FAC2)
00:95B2  104C              :                 BPL     LAB_24F8        ; if = add FAC2 mantissa to FAC1 mantissa and return

00:95B4  A05E              :                 LDY     #FAC1_e         ; set index to FAC1 exponent addr
00:95B6  E065              :                 CPX     #FAC2_e         ; compare X to FAC2 exponent addr
00:95B8  F002              :                 BEQ     LAB_24B4        ; branch if =

00:95BA  A065              :                 LDY     #FAC2_e         ; else set index to FAC2 exponent addr

                             ; subtract smaller from bigger (take sign of bigger)
                             LAB_24B4
00:95BC  38                :                 SEC                     ; set carry for subtract
00:95BD  49FF              :                 EOR     #$FF            ; ones complement A
00:95BF  6555              :                 ADC     FAC2_r          ; add FAC2 rounding byte
00:95C1  856B              :                 STA     FAC1_r          ; save FAC1 rounding byte
00:95C3  B90300            :                 LDA     PLUS_3,Y        ; get FACY mantissa3
00:95C6  F503              :                 SBC     PLUS_3,X        ; subtract FACX mantissa3
00:95C8  8561              :                 STA     FAC1_3          ; save FAC1 mantissa3
00:95CA  B90200            :                 LDA     PLUS_2,Y        ; get FACY mantissa2
00:95CD  F502              :                 SBC     PLUS_2,X        ; subtract FACX mantissa2
00:95CF  8560              :                 STA     FAC1_2          ; save FAC1 mantissa2
00:95D1  B90100            :                 LDA     PLUS_1,Y        ; get FACY mantissa1
00:95D4  F501              :                 SBC     PLUS_1,X        ; subtract FACX mantissa1
00:95D6  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1

                             ; do ABS and normalise FAC1

                             LAB_24D0
00:95D8  B003              :                 BCS     LAB_24D5        ; branch if number is +ve

00:95DA  203F96            :                 JSR     LAB_2537        ; negate FAC1

                             ; normalise FAC1

                             LAB_24D5
00:95DD  A000              :                 LDY     #$00            ; clear Y
00:95DF  98                :                 TYA                     ; clear A
00:95E0  18                :                 CLC                     ; clear carry for add
                             LAB_24D9
00:95E1  A65F              :                 LDX     FAC1_1          ; get FAC1 mantissa1
00:95E3  D03E              :                 BNE     LAB_251B        ; if not zero normalise FAC1

00:95E5  A660              :                 LDX     FAC1_2          ; get FAC1 mantissa2
00:95E7  865F              :                 STX     FAC1_1          ; save FAC1 mantissa1
00:95E9  A661              :                 LDX     FAC1_3          ; get FAC1 mantissa3
00:95EB  8660              :                 STX     FAC1_2          ; save FAC1 mantissa2
00:95ED  A66B              :                 LDX     FAC1_r          ; get FAC1 rounding byte
00:95EF  8661              :                 STX     FAC1_3          ; save FAC1 mantissa3
00:95F1  846B              :                 STY     FAC1_r          ; clear FAC1 rounding byte

Portable 65xx Assembler [20.01]

00:95F3  6908              :                 ADC     #$08            ; add x to exponent offset
00:95F5  C918              :                 CMP     #$18            ; compare with $18 (max offset, all bits would be =0)
00:95F7  D0E8              :                 BNE     LAB_24D9        ; loop if not max

                             ; clear FAC1 exponent and sign

                             LAB_24F1
00:95F9  A900              :                 LDA     #$00            ; clear A
                             LAB_24F3
00:95FB  855E              :                 STA     FAC1_e          ; set FAC1 exponent

                             ; save FAC1 sign

                             LAB_24F5
00:95FD  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
00:95FF  60                :                 RTS

                             ; add FAC2 mantissa to FAC1 mantissa

                             LAB_24F8
00:9600  6555              :                 ADC     FAC2_r          ; add FAC2 rounding byte
00:9602  856B              :                 STA     FAC1_r          ; save FAC1 rounding byte
00:9604  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:9606  6568              :                 ADC     FAC2_3          ; add FAC2 mantissa3
00:9608  8561              :                 STA     FAC1_3          ; save FAC1 mantissa3
00:960A  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:960C  6567              :                 ADC     FAC2_2          ; add FAC2 mantissa2
00:960E  8560              :                 STA     FAC1_2          ; save FAC1 mantissa2
00:9610  A55F              :                 LDA     FAC1_1          ; get FAC1 mantissa1
00:9612  6566              :                 ADC     FAC2_1          ; add FAC2 mantissa1
00:9614  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:9616  B01A              :                 BCS     LAB_252A        ; if carry then normalise FAC1 for C=1

00:9618  60                :                 RTS                     ; else just exit

                             LAB_2511
00:9619  6901              :                 ADC     #$01            ; add 1 to exponent offset
00:961B  066B              :                 ASL     FAC1_r          ; shift FAC1 rounding byte
00:961D  2661              :                 ROL     FAC1_3          ; shift FAC1 mantissa3
00:961F  2660              :                 ROL     FAC1_2          ; shift FAC1 mantissa2
00:9621  265F              :                 ROL     FAC1_1          ; shift FAC1 mantissa1

                             ; normalise FAC1

                             LAB_251B
00:9623  10F4              :                 BPL     LAB_2511        ; loop if not normalised

00:9625  38                :                 SEC                     ; set carry for subtract
00:9626  E55E              :                 SBC     FAC1_e          ; subtract FAC1 exponent
00:9628  B0CF              :                 BCS     LAB_24F1        ; branch if underflow (set result = $0)

00:962A  49FF              :                 EOR     #$FF            ; complement exponent
00:962C  6901              :                 ADC     #$01            ; +1 (twos complement)
00:962E  855E              :                 STA     FAC1_e          ; save FAC1 exponent

Portable 65xx Assembler [20.01]


                             ; test and normalise FAC1 for C=0/1

                             LAB_2528
00:9630  900C              :                 BCC     LAB_2536        ; exit if no overflow

                             ; normalise FAC1 for C=1

                             LAB_252A
00:9632  E65E              :                 INC     FAC1_e          ; increment FAC1 exponent
00:9634  F036              :                 BEQ     LAB_2564        ; if zero do overflow error and warm start

00:9636  665F              :                 ROR     FAC1_1          ; shift FAC1 mantissa1
00:9638  6660              :                 ROR     FAC1_2          ; shift FAC1 mantissa2
00:963A  6661              :                 ROR     FAC1_3          ; shift FAC1 mantissa3
00:963C  666B              :                 ROR     FAC1_r          ; shift FAC1 rounding byte
                             LAB_2536
00:963E  60                :                 RTS

                             ; negate FAC1

                             LAB_2537
00:963F  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9641  49FF              :                 EOR     #$FF            ; complement it
00:9643  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)

                             ; twos complement FAC1 mantissa

                             LAB_253D
00:9645  A55F              :                 LDA     FAC1_1          ; get FAC1 mantissa1
00:9647  49FF              :                 EOR     #$FF            ; complement it
00:9649  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:964B  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:964D  49FF              :                 EOR     #$FF            ; complement it
00:964F  8560              :                 STA     FAC1_2          ; save FAC1 mantissa2
00:9651  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:9653  49FF              :                 EOR     #$FF            ; complement it
00:9655  8561              :                 STA     FAC1_3          ; save FAC1 mantissa3
00:9657  A56B              :                 LDA     FAC1_r          ; get FAC1 rounding byte
00:9659  49FF              :                 EOR     #$FF            ; complement it
00:965B  856B              :                 STA     FAC1_r          ; save FAC1 rounding byte
00:965D  E66B              :                 INC     FAC1_r          ; increment FAC1 rounding byte
00:965F  D00A              :                 BNE     LAB_2563        ; exit if no overflow

                             ; increment FAC1 mantissa

                             LAB_2559
00:9661  E661              :                 INC     FAC1_3          ; increment FAC1 mantissa3
00:9663  D006              :                 BNE     LAB_2563        ; finished if no rollover

00:9665  E660              :                 INC     FAC1_2          ; increment FAC1 mantissa2
00:9667  D002              :                 BNE     LAB_2563        ; finished if no rollover

00:9669  E65F              :                 INC     FAC1_1          ; increment FAC1 mantissa1

Portable 65xx Assembler [20.01]

                             LAB_2563
00:966B  60                :                 RTS

                             ; do overflow error (overflow exit)

                             LAB_2564
00:966C  A20A              :                 LDX     #$0A            ; error code $0A ("Overflow" error)
00:966E  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; shift FCAtemp << A+8 times

                             LAB_2569
00:9671  A226              :                 LDX     #FACt_1-1       ; set offset to FACtemp
                             LAB_256B
00:9673  B403              :                 LDY     PLUS_3,X        ; get FACX mantissa3
00:9675  846B              :                 STY     FAC1_r          ; save as FAC1 rounding byte
00:9677  B402              :                 LDY     PLUS_2,X        ; get FACX mantissa2
00:9679  9403              :                 STY     PLUS_3,X        ; save FACX mantissa3
00:967B  B401              :                 LDY     PLUS_1,X        ; get FACX mantissa1
00:967D  9402              :                 STY     PLUS_2,X        ; save FACX mantissa2
00:967F  A464              :                 LDY     FAC1_o          ; get FAC1 overflow byte
00:9681  9401              :                 STY     PLUS_1,X        ; save FACX mantissa1

                             ; shift FACX -A times right (> 8 shifts)

                             LAB_257B
00:9683  6908              :                 ADC     #$08            ; add 8 to shift count
00:9685  30EC              :                 BMI     LAB_256B        ; go do 8 shift if still -ve

00:9687  F0EA              :                 BEQ     LAB_256B        ; go do 8 shift if zero

00:9689  E908              :                 SBC     #$08            ; else subtract 8 again
00:968B  A8                :                 TAY                     ; save count to Y
00:968C  A56B              :                 LDA     FAC1_r          ; get FAC1 rounding byte
00:968E  B012              :                 BCS     LAB_259A        ;

                             LAB_2588
00:9690  1601              :                 ASL     PLUS_1,X        ; shift FACX mantissa1
00:9692  9002              :                 BCC     LAB_258E        ; branch if +ve

00:9694  F601              :                 INC     PLUS_1,X        ; this sets b7 eventually
                             LAB_258E
00:9696  7601              :                 ROR     PLUS_1,X        ; shift FACX mantissa1 (correct for ASL)
00:9698  7601              :                 ROR     PLUS_1,X        ; shift FACX mantissa1 (put carry in b7)

                             ; shift FACX Y times right

                             LAB_2592
00:969A  7602              :                 ROR     PLUS_2,X        ; shift FACX mantissa2
00:969C  7603              :                 ROR     PLUS_3,X        ; shift FACX mantissa3
00:969E  6A                :                 ROR                     ; shift FACX rounding byte
00:969F  C8                :                 INY                     ; increment exponent diff
00:96A0  D0EE              :                 BNE     LAB_2588        ; branch if range adjust not complete


Portable 65xx Assembler [20.01]

                             LAB_259A
00:96A2  18                :                 CLC                     ; just clear it
00:96A3  60                :                 RTS

                             ; perform LOG()

                             LAB_LOG
00:96A4  208F98            :                 JSR     LAB_27CA        ; test sign and zero
00:96A7  F002              :                 BEQ     LAB_25C4        ; if zero do function call error then warm start

00:96A9  1003              :                 BPL     LAB_25C7        ; skip error if +ve

                             LAB_25C4
00:96AB  4CE68E            :                 JMP     LAB_FCER        ; do function call error then warm start (-ve)

                             LAB_25C7
00:96AE  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:96B0  E97F              :                 SBC     #$7F            ; normalise it
00:96B2  48                :                 PHA                     ; save it
00:96B3  A980              :                 LDA     #$80            ; set exponent to zero
00:96B5  855E              :                 STA     FAC1_e          ; save FAC1 exponent
00:96B7  A93A              :                 LDA     #<LAB_25AD      ; set 1/root2 pointer low byte
00:96B9  A0A0              :                 LDY     #>LAB_25AD      ; set 1/root2 pointer high byte
00:96BB  206B95            :                 JSR     LAB_246C        ; add (AY) to FAC1 (1/root2)
00:96BE  A93E              :                 LDA     #<LAB_25B1      ; set root2 pointer low byte
00:96C0  A0A0              :                 LDY     #>LAB_25B1      ; set root2 pointer high byte
00:96C2  20A897            :                 JSR     LAB_26CA        ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00:96C5  A9B1              :                 LDA     #<LAB_259C      ; set 1 pointer low byte
00:96C7  A0A0              :                 LDY     #>LAB_259C      ; set 1 pointer high byte
00:96C9  205195            :                 JSR     LAB_2455        ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
00:96CC  A92D              :                 LDA     #<LAB_25A0      ; set pointer low byte to counter
00:96CE  A0A0              :                 LDY     #>LAB_25A0      ; set pointer high byte to counter
00:96D0  20E99B            :                 JSR     LAB_2B6E        ; ^2 then series evaluation
00:96D3  A942              :                 LDA     #<LAB_25B5      ; set -0.5 pointer low byte
00:96D5  A0A0              :                 LDY     #>LAB_25B5      ; set -0.5 pointer high byte
00:96D7  206B95            :                 JSR     LAB_246C        ; add (AY) to FAC1
00:96DA  68                :                 PLA                     ; restore FAC1 exponent
00:96DB  20E299            :                 JSR     LAB_2912        ; evaluate new ASCII digit
00:96DE  A946              :                 LDA     #<LAB_25B9      ; set LOG(2) pointer low byte
00:96E0  A0A0              :                 LDY     #>LAB_25B9      ; set LOG(2) pointer high byte

                             ; do convert AY, FCA1*(AY)

                             LAB_25FB
00:96E2  203297            :                 JSR     LAB_264D        ; unpack memory (AY) into FAC2
                             LAB_MULTIPLY
00:96E5  F04A              :                 BEQ     LAB_264C        ; exit if zero

00:96E7  205897            :                 JSR     LAB_2673        ; test and adjust accumulators
00:96EA  6427              :                 STZ     FACt_1          ; clear temp mantissa1
00:96EC  6428              :                 STZ     FACt_2          ; clear temp mantissa2
00:96EE  6429              :                 STZ     FACt_3          ; clear temp mantissa3
00:96F0  A56B              :                 LDA     FAC1_r          ; get FAC1 rounding byte
00:96F2  200797            :                 JSR     LAB_2622        ; go do shift/add FAC2

Portable 65xx Assembler [20.01]

00:96F5  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:96F7  200797            :                 JSR     LAB_2622        ; go do shift/add FAC2
00:96FA  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:96FC  200797            :                 JSR     LAB_2622        ; go do shift/add FAC2
00:96FF  A55F              :                 LDA     FAC1_1          ; get FAC1 mantissa1
00:9701  200C97            :                 JSR     LAB_2627        ; go do shift/add FAC2
00:9704  4C1498            :                 JMP     LAB_273C        ; copy temp to FAC1, normalise and return

                             LAB_2622
00:9707  D003              :                 BNE     LAB_2627        ; branch if byte <> zero

00:9709  4C7196            :                 JMP     LAB_2569        ; shift FCAtemp << A+8 times

                             ; else do shift and add
                             LAB_2627
00:970C  4A                :                 LSR                     ; shift byte
00:970D  0980              :                 ORA     #$80            ; set top bit (mark for 8 times)
                             LAB_262A
00:970F  A8                :                 TAY                     ; copy result
00:9710  9013              :                 BCC     LAB_2640        ; skip next if bit was zero

00:9712  18                :                 CLC                     ; clear carry for add
00:9713  A529              :                 LDA     FACt_3          ; get temp mantissa3
00:9715  6568              :                 ADC     FAC2_3          ; add FAC2 mantissa3
00:9717  8529              :                 STA     FACt_3          ; save temp mantissa3
00:9719  A528              :                 LDA     FACt_2          ; get temp mantissa2
00:971B  6567              :                 ADC     FAC2_2          ; add FAC2 mantissa2
00:971D  8528              :                 STA     FACt_2          ; save temp mantissa2
00:971F  A527              :                 LDA     FACt_1          ; get temp mantissa1
00:9721  6566              :                 ADC     FAC2_1          ; add FAC2 mantissa1
00:9723  8527              :                 STA     FACt_1          ; save temp mantissa1
                             LAB_2640
00:9725  6627              :                 ROR     FACt_1          ; shift temp mantissa1
00:9727  6628              :                 ROR     FACt_2          ; shift temp mantissa2
00:9729  6629              :                 ROR     FACt_3          ; shift temp mantissa3
00:972B  666B              :                 ROR     FAC1_r          ; shift temp rounding byte
00:972D  98                :                 TYA                     ; get byte back
00:972E  4A                :                 LSR                     ; shift byte
00:972F  D0DE              :                 BNE     LAB_262A        ; loop if all bits not done

                             LAB_264C
00:9731  60                :                 RTS

                             ; unpack memory (AY) into FAC2

                             LAB_264D
00:9732  8523              :                 STA     ut1_pl          ; save pointer low byte
00:9734  8424              :                 STY     ut1_ph          ; save pointer high byte
00:9736  A003              :                 LDY     #$03            ; 4 bytes to get (0-3)
00:9738  B123              :                 LDA     (ut1_pl),Y      ; get mantissa3
00:973A  8568              :                 STA     FAC2_3          ; save FAC2 mantissa3
00:973C  88                :                 DEY                     ; decrement index
00:973D  B123              :                 LDA     (ut1_pl),Y      ; get mantissa2
00:973F  8567              :                 STA     FAC2_2          ; save FAC2 mantissa2

Portable 65xx Assembler [20.01]

00:9741  88                :                 DEY                     ; decrement index
00:9742  B123              :                 LDA     (ut1_pl),Y      ; get mantissa1+sign
00:9744  8569              :                 STA     FAC2_s          ; save FAC2 sign (b7)
00:9746  4562              :                 EOR     FAC1_s          ; EOR with FAC1 sign (b7)
00:9748  856A              :                 STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00:974A  A569              :                 LDA     FAC2_s          ; recover FAC2 sign (b7)
00:974C  0980              :                 ORA     #$80            ; set 1xxx xxx (set normal bit)
00:974E  8566              :                 STA     FAC2_1          ; save FAC2 mantissa1
00:9750  88                :                 DEY                     ; decrement index
00:9751  B123              :                 LDA     (ut1_pl),Y      ; get exponent byte
00:9753  8565              :                 STA     FAC2_e          ; save FAC2 exponent
00:9755  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9757  60                :                 RTS

                             ; test and adjust accumulators

                             LAB_2673
00:9758  A565              :                 LDA     FAC2_e          ; get FAC2 exponent
                             LAB_2675
00:975A  F01E              :                 BEQ     LAB_2696        ; branch if FAC2 = $00 (handle underflow)

00:975C  18                :                 CLC                     ; clear carry for add
00:975D  655E              :                 ADC     FAC1_e          ; add FAC1 exponent
00:975F  9005              :                 BCC     LAB_2680        ; branch if sum of exponents <$0100

00:9761  3032              :                 BMI     LAB_269B        ; do overflow error

00:9763  18                :                 CLC                     ; clear carry for the add
00:9764  8002              :                 BRA     LAB_2680b       ; branch around next instruction, saves one clock cycle
                             LAB_2680
00:9766  1012              :                 BPL     LAB_2696        ; if +ve go handle underflow
                             LAB_2680b
00:9768  6980              :                 ADC     #$80            ; adjust exponent
00:976A  855E              :                 STA     FAC1_e          ; save FAC1 exponent
00:976C  D003              :                 BNE     LAB_268B        ; branch if not zero

00:976E  4CFD95            :                 JMP     LAB_24F5        ; save FAC1 sign and return

                             LAB_268B
00:9771  A56A              :                 LDA     FAC_sc          ; get sign compare (FAC1 EOR FAC2)
00:9773  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
                             LAB_268F
00:9775  60                :                 RTS

                             ; handle overflow and underflow

                             LAB_2690
00:9776  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9778  101B              :                 BPL     LAB_269B        ; do overflow error

                             ; handle underflow
                             LAB_2696
00:977A  68                :                 PLA                     ; pop return address low byte
00:977B  68                :                 PLA                     ; pop return address high byte

Portable 65xx Assembler [20.01]

00:977C  4CF995            :                 JMP     LAB_24F1        ; clear FAC1 exponent and sign and return

                             ; multiply by 10

                             LAB_269E
00:977F  207098            :                 JSR     LAB_27AB        ; round and copy FAC1 to FAC2
00:9782  AA                :                 TAX                     ; copy exponent (set the flags)
00:9783  F0F0              :                 BEQ     LAB_268F        ; exit if zero

00:9785  18                :                 CLC                     ; clear carry for add
00:9786  6902              :                 ADC     #$02            ; add two to exponent (*4)
00:9788  B00B              :                 BCS     LAB_269B        ; do overflow error if > $FF

00:978A  A200              :                 LDX     #$00            ; clear byte
00:978C  866A              :                 STX     FAC_sc          ; clear sign compare (FAC1 EOR FAC2)
00:978E  208895            :                 JSR     LAB_247C        ; add FAC2 to FAC1 (*5)
00:9791  E65E              :                 INC     FAC1_e          ; increment FAC1 exponent (*10)
00:9793  D0E0              :                 BNE     LAB_268F        ; if non zero just do RTS

                             LAB_269B
00:9795  4C6C96            :                 JMP     LAB_2564        ; do overflow error and warm start

                             ; divide by 10

                             LAB_26B9
00:9798  207098            :                 JSR     LAB_27AB        ; round and copy FAC1 to FAC2
00:979B  A9C2              :                 LDA     #<LAB_26B5      ; set pointer to 10d low addr
00:979D  A0A0              :                 LDY     #>LAB_26B5      ; set pointer to 10d high addr
00:979F  A200              :                 LDX     #$00            ; clear sign

                             ; divide by (AY) (X=sign)

                             LAB_26C2
00:97A1  866A              :                 STX     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00:97A3  202398            :                 JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00:97A6  8003              :                 BRA     LAB_DIVIDE      ; do FAC2/FAC1

                             ; Perform divide-by
                             ; convert AY and do (AY)/FAC1

                             LAB_26CA
00:97A8  203297            :                 JSR     LAB_264D        ; unpack memory (AY) into FAC2

                             ; Perform divide-into
                             LAB_DIVIDE
00:97AB  F062              :                 BEQ     LAB_2737        ; if zero go do /0 error

00:97AD  207F98            :                 JSR     LAB_27BA        ; round FAC1
00:97B0  A900              :                 LDA     #$00            ; clear A
00:97B2  38                :                 SEC                     ; set carry for subtract
00:97B3  E55E              :                 SBC     FAC1_e          ; subtract FAC1 exponent (2s complement)
00:97B5  855E              :                 STA     FAC1_e          ; save FAC1 exponent
00:97B7  205897            :                 JSR     LAB_2673        ; test and adjust accumulators
00:97BA  E65E              :                 INC     FAC1_e          ; increment FAC1 exponent

Portable 65xx Assembler [20.01]

00:97BC  F0D7              :                 BEQ     LAB_269B        ; if zero do overflow error

00:97BE  A2FF              :                 LDX     #$FF            ; set index for pre increment
00:97C0  A901              :                 LDA     #$01            ; set bit to flag byte save
                             LAB_26E4
00:97C2  A466              :                 LDY     FAC2_1          ; get FAC2 mantissa1
00:97C4  C45F              :                 CPY     FAC1_1          ; compare FAC1 mantissa1
00:97C6  D00A              :                 BNE     LAB_26F4        ; branch if <>

00:97C8  A467              :                 LDY     FAC2_2          ; get FAC2 mantissa2
00:97CA  C460              :                 CPY     FAC1_2          ; compare FAC1 mantissa2
00:97CC  D004              :                 BNE     LAB_26F4        ; branch if <>

00:97CE  A468              :                 LDY     FAC2_3          ; get FAC2 mantissa3
00:97D0  C461              :                 CPY     FAC1_3          ; compare FAC1 mantissa3
                             LAB_26F4
00:97D2  08                :                 PHP                     ; save FAC2-FAC1 compare status
00:97D3  2A                :                 ROL                     ; shift the result byte
00:97D4  900E              :                 BCC     LAB_2702        ; if no carry skip the byte save

00:97D6  A001              :                 LDY     #$01            ; set bit to flag byte save
00:97D8  E8                :                 INX                     ; else increment the index to FACt
00:97D9  E002              :                 CPX     #$02            ; compare with the index to FACt_3
00:97DB  3004              :                 BMI     LAB_2701        ; if not last byte just go save it

00:97DD  D028              :                 BNE     LAB_272B        ; if all done go save FAC1 rounding byte, normalise and
                             ; return

00:97DF  A040              :                 LDY     #$40            ; set bit to flag byte save for the rounding byte
                             LAB_2701
00:97E1  9527              :                 STA     FACt_1,X        ; write result byte to FACt_1 + index
00:97E3  98                :                 TYA                     ; copy the next save byte flag
                             LAB_2702
00:97E4  28                :                 PLP                     ; restore FAC2-FAC1 compare status
00:97E5  9014              :                 BCC     LAB_2704        ; if FAC2 < FAC1 then skip the subtract

00:97E7  A8                :                 TAY                     ; save FAC2-FAC1 compare status
00:97E8  A568              :                 LDA     FAC2_3          ; get FAC2 mantissa3
00:97EA  E561              :                 SBC     FAC1_3          ; subtract FAC1 mantissa3
00:97EC  8568              :                 STA     FAC2_3          ; save FAC2 mantissa3
00:97EE  A567              :                 LDA     FAC2_2          ; get FAC2 mantissa2
00:97F0  E560              :                 SBC     FAC1_2          ; subtract FAC1 mantissa2
00:97F2  8567              :                 STA     FAC2_2          ; save FAC2 mantissa2
00:97F4  A566              :                 LDA     FAC2_1          ; get FAC2 mantissa1
00:97F6  E55F              :                 SBC     FAC1_1          ; subtract FAC1 mantissa1
00:97F8  8566              :                 STA     FAC2_1          ; save FAC2 mantissa1
00:97FA  98                :                 TYA                     ; restore FAC2-FAC1 compare status

                             ; FAC2 = FAC2*2
                             LAB_2704
00:97FB  0668              :                 ASL     FAC2_3          ; shift FAC2 mantissa3
00:97FD  2667              :                 ROL     FAC2_2          ; shift FAC2 mantissa2
00:97FF  2666              :                 ROL     FAC2_1          ; shift FAC2 mantissa1
00:9801  B0CF              :                 BCS     LAB_26F4        ; loop with no compare

Portable 65xx Assembler [20.01]


00:9803  30BD              :                 BMI     LAB_26E4        ; loop with compare

00:9805  80CB              :                 BRA     LAB_26F4        ; loop always with no compare

                             ; do A<<6, save as FAC1 rounding byte, normalise and return

                             LAB_272B
00:9807  4A                :                 LSR                     ; shift b1 - b0 ..
00:9808  6A                :                 ROR                     ; ..
00:9809  6A                :                 ROR                     ; .. to b7 - b6
00:980A  856B              :                 STA     FAC1_r          ; save FAC1 rounding byte
00:980C  28                :                 PLP                     ; dump FAC2-FAC1 compare status
00:980D  8005              :                 BRA     LAB_273C        ; copy temp to FAC1, normalise and return

                             ; do "Divide by zero" error

                             LAB_2737
00:980F  A214              :                 LDX     #$14            ; error code $14 ("Divide by zero" error)
00:9811  4C3381            :                 JMP     LAB_XERR        ; do error #X, then warm start

                             ; copy temp to FAC1 and normalise

                             LAB_273C
00:9814  A527              :                 LDA     FACt_1          ; get temp mantissa1
00:9816  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:9818  A528              :                 LDA     FACt_2          ; get temp mantissa2
00:981A  8560              :                 STA     FAC1_2          ; save FAC1 mantissa2
00:981C  A529              :                 LDA     FACt_3          ; get temp mantissa3
00:981E  8561              :                 STA     FAC1_3          ; save FAC1 mantissa3
00:9820  4CDD95            :                 JMP     LAB_24D5        ; normalise FAC1 and return

                             ; unpack memory (AY) into FAC1

                             LAB_UFAC
00:9823  8523              :                 STA     ut1_pl          ; save pointer low byte
00:9825  8424              :                 STY     ut1_ph          ; save pointer high byte
00:9827  A003              :                 LDY     #$03            ; 4 bytes to do
00:9829  B123              :                 LDA     (ut1_pl),Y      ; get last byte
00:982B  8561              :                 STA     FAC1_3          ; save FAC1 mantissa3
00:982D  88                :                 DEY                     ; decrement index
00:982E  B123              :                 LDA     (ut1_pl),Y      ; get last-1 byte
00:9830  8560              :                 STA     FAC1_2          ; save FAC1 mantissa2
00:9832  88                :                 DEY                     ; decrement index
00:9833  B123              :                 LDA     (ut1_pl),Y      ; get second byte
00:9835  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
00:9837  0980              :                 ORA     #$80            ; set 1xxx xxxx (add normal bit)
00:9839  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:983B  88                :                 DEY                     ; decrement index
00:983C  B123              :                 LDA     (ut1_pl),Y      ; get first byte (exponent)
00:983E  855E              :                 STA     FAC1_e          ; save FAC1 exponent
00:9840  846B              :                 STY     FAC1_r          ; clear FAC1 rounding byte
00:9842  60                :                 RTS


Portable 65xx Assembler [20.01]

                             ; pack FAC1 into Adatal

                             LAB_276E
00:9843  A256              :                 LDX     #<Adatal        ; set pointer low byte
                             LAB_2770
00:9845  A000              :                 LDY     #>Adatal        ; set pointer high byte
00:9847  F004              :                 BEQ     LAB_2778        ; pack FAC1 into (XY) and return

                             ; pack FAC1 into (Lvarpl)

                             LAB_PFAC
00:9849  A649              :                 LDX     Lvarpl          ; get destination pointer low byte
00:984B  A44A              :                 LDY     Lvarph          ; get destination pointer high byte

                             ; pack FAC1 into (XY)

                             LAB_2778
00:984D  207F98            :                 JSR     LAB_27BA        ; round FAC1
00:9850  8623              :                 STX     ut1_pl          ; save pointer low byte
00:9852  8424              :                 STY     ut1_ph          ; save pointer high byte
00:9854  A003              :                 LDY     #$03            ; set index
00:9856  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:9858  9123              :                 STA     (ut1_pl),Y      ; store in destination
00:985A  88                :                 DEY                     ; decrement index
00:985B  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:985D  9123              :                 STA     (ut1_pl),Y      ; store in destination
00:985F  88                :                 DEY                     ; decrement index
00:9860  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9862  097F              :                 ORA     #$7F            ; set bits x111 1111
00:9864  255F              :                 AND     FAC1_1          ; AND in FAC1 mantissa1
00:9866  9123              :                 STA     (ut1_pl),Y      ; store in destination
00:9868  88                :                 DEY                     ; decrement index
00:9869  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:986B  9123              :                 STA     (ut1_pl),Y      ; store in destination
00:986D  846B              :                 STY     FAC1_r          ; clear FAC1 rounding byte
00:986F  60                :                 RTS

                             ; round and copy FAC1 to FAC2

                             LAB_27AB
00:9870  207F98            :                 JSR     LAB_27BA        ; round FAC1

                             ; copy FAC1 to FAC2

                             LAB_27AE
00:9873  A205              :                 LDX     #$05            ; 5 bytes to copy
                             LAB_27B0
00:9875  B55D              :                 LDA     FAC1_e-1,X      ; get byte from FAC1,X
00:9877  9564              :                 STA     FAC1_o,X        ; save byte at FAC2,X
00:9879  CA                :                 DEX                     ; decrement count
00:987A  D0F9              :                 BNE     LAB_27B0        ; loop if not all done

00:987C  866B              :                 STX     FAC1_r          ; clear FAC1 rounding byte
                             LAB_27B9

Portable 65xx Assembler [20.01]

00:987E  60                :                 RTS

                             ; round FAC1

                             LAB_27BA
00:987F  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9881  F0FB              :                 BEQ     LAB_27B9        ; exit if zero

00:9883  066B              :                 ASL     FAC1_r          ; shift FAC1 rounding byte
00:9885  90F7              :                 BCC     LAB_27B9        ; exit if no overflow

                             ; round FAC1 (no check)

                             LAB_27C2
00:9887  206196            :                 JSR     LAB_2559        ; increment FAC1 mantissa
00:988A  D0F2              :                 BNE     LAB_27B9        ; branch if no overflow

00:988C  4C3296            :                 JMP     LAB_252A        ; normalise FAC1 for C=1 and return

                             ; get FAC1 sign
                             ; return A=FF,C=1/-ve A=01,C=0/+ve

                             LAB_27CA
00:988F  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9891  F009              :                 BEQ     LAB_27D7        ; exit if zero (already correct SGN(0)=0)

                             ; return A=FF,C=1/-ve A=01,C=0/+ve
                             ; no = 0 check

                             LAB_27CE
00:9893  A562              :                 LDA     FAC1_s          ; else get FAC1 sign (b7)

                             ; return A=FF,C=1/-ve A=01,C=0/+ve
                             ; no = 0 check, sign in A

                             LAB_27D0
00:9895  2A                :                 ROL                     ; move sign bit to carry
00:9896  A9FF              :                 LDA     #$FF            ; set byte for -ve result
00:9898  B002              :                 BCS     LAB_27D7        ; return if sign was set (-ve)

00:989A  A901              :                 LDA     #$01            ; else set byte for +ve result
                             LAB_27D7
00:989C  60                :                 RTS

                             ; perform SGN()

                             LAB_SGN
00:989D  208F98            :                 JSR     LAB_27CA        ; get FAC1 sign
                             ; return A=$FF/-ve A=$01/+ve
                             ; save A as integer byte

                             LAB_27DB
00:98A0  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:98A2  6460              :                 STZ     FAC1_2          ; clear FAC1 mantissa2

Portable 65xx Assembler [20.01]

00:98A4  A288              :                 LDX     #$88            ; set exponent

                             ; set exp=X, clearFAC1 mantissa3 and normalise

                             LAB_27E3
00:98A6  A55F              :                 LDA     FAC1_1          ; get FAC1 mantissa1
00:98A8  49FF              :                 EOR     #$FF            ; complement it
00:98AA  2A                :                 ROL                     ; sign bit into carry

                             ; set exp=X, clearFAC1 mantissa3 and normalise

                             LAB_STFA
00:98AB  6461              :                 STZ     FAC1_3          ; clear FAC1 mantissa3
00:98AD  865E              :                 STX     FAC1_e          ; set FAC1 exponent
00:98AF  646B              :                 STZ     FAC1_r          ; clear FAC1 rounding byte
00:98B1  6462              :                 STZ     FAC1_s          ; clear FAC1 sign (b7)
00:98B3  4CD895            :                 JMP     LAB_24D0        ; do ABS and normalise FAC1

                             ; perform ABS()

                             LAB_ABS
00:98B6  4662              :                 LSR     FAC1_s          ; clear FAC1 sign (put zero in b7)
00:98B8  60                :                 RTS

                             ; compare FAC1 with (AY)
                             ; returns A=$00 if FAC1 = (AY)
                             ; returns A=$01 if FAC1 > (AY)
                             ; returns A=$FF if FAC1 < (AY)

                             LAB_27F8
00:98B9  8525              :                 STA     ut2_pl          ; save pointer low byte
                             LAB_27FA
00:98BB  8426              :                 STY     ut2_ph          ; save pointer high byte
00:98BD  A000              :                 LDY     #$00            ; clear index
00:98BF  B125              :                 LDA     (ut2_pl),Y      ; get exponent
00:98C1  C8                :                 INY                     ; increment index
00:98C2  AA                :                 TAX                     ; copy (AY) exponent to X
00:98C3  F0CA              :                 BEQ     LAB_27CA        ; branch if (AY) exponent=0 and get FAC1 sign
                             ; A=FF,C=1/-ve A=01,C=0/+ve

00:98C5  B125              :                 LDA     (ut2_pl),Y      ; get (AY) mantissa1 (with sign)
00:98C7  4562              :                 EOR     FAC1_s          ; EOR FAC1 sign (b7)
00:98C9  30C8              :                 BMI     LAB_27CE        ; if signs <> do return A=FF,C=1/-ve
                             ; A=01,C=0/+ve and return

00:98CB  E45E              :                 CPX     FAC1_e          ; compare (AY) exponent with FAC1 exponent
00:98CD  D01A              :                 BNE     LAB_2828        ; branch if different

00:98CF  B125              :                 LDA     (ut2_pl),Y      ; get (AY) mantissa1 (with sign)
00:98D1  0980              :                 ORA     #$80            ; normalise top bit
00:98D3  C55F              :                 CMP     FAC1_1          ; compare with FAC1 mantissa1
00:98D5  D012              :                 BNE     LAB_2828        ; branch if different

00:98D7  C8                :                 INY                     ; increment index

Portable 65xx Assembler [20.01]

00:98D8  B125              :                 LDA     (ut2_pl),Y      ; get mantissa2
00:98DA  C560              :                 CMP     FAC1_2          ; compare with FAC1 mantissa2
00:98DC  D00B              :                 BNE     LAB_2828        ; branch if different

00:98DE  C8                :                 INY                     ; increment index
00:98DF  A97F              :                 LDA     #$7F            ; set for 1/2 value rounding byte
00:98E1  C56B              :                 CMP     FAC1_r          ; compare with FAC1 rounding byte (set carry)
00:98E3  B125              :                 LDA     (ut2_pl),Y      ; get mantissa3
00:98E5  E561              :                 SBC     FAC1_3          ; subtract FAC1 mantissa3
00:98E7  F027              :                 BEQ     LAB_2850        ; exit if mantissa3 equal

                             ; gets here if number <> FAC1

                             LAB_2828
00:98E9  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:98EB  9002              :                 BCC     LAB_282E        ; branch if FAC1 > (AY)

00:98ED  49FF              :                 EOR     #$FF            ; else toggle FAC1 sign
                             LAB_282E
00:98EF  80A4              :                 BRA     LAB_27D0        ; return A=FF,C=1/-ve A=01,C=0/+ve

                             ; convert FAC1 floating-to-fixed

                             LAB_2831
00:98F1  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:98F3  F04A              :                 BEQ     LAB_287F        ; if zero go clear FAC1 and return

00:98F5  38                :                 SEC                     ; set carry for subtract
00:98F6  E998              :                 SBC     #$98            ; subtract maximum integer range exponent
00:98F8  2462              :                 BIT     FAC1_s          ; test FAC1 sign (b7)
00:98FA  1009              :                 BPL     LAB_2845        ; branch if FAC1 +ve

                             ; FAC1 was -ve
00:98FC  AA                :                 TAX                     ; copy subtracted exponent
00:98FD  A9FF              :                 LDA     #$FF            ; overflow for -ve number
00:98FF  8564              :                 STA     FAC1_o          ; set FAC1 overflow byte
00:9901  204596            :                 JSR     LAB_253D        ; twos complement FAC1 mantissa
00:9904  8A                :                 TXA                     ; restore subtracted exponent
                             LAB_2845
00:9905  A25E              :                 LDX     #FAC1_e         ; set index to FAC1
00:9907  C9F9              :                 CMP     #$F9            ; compare exponent result
00:9909  1006              :                 BPL     LAB_2851        ; if < 8 shifts shift FAC1 A times right and return

00:990B  208396            :                 JSR     LAB_257B        ; shift FAC1 A times right (> 8 shifts)
00:990E  8464              :                 STY     FAC1_o          ; clear FAC1 overflow byte
                             LAB_2850
00:9910  60                :                 RTS

                             ; shift FAC1 A times right

                             LAB_2851
00:9911  A8                :                 TAY                     ; copy shift count
00:9912  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9914  2980              :                 AND     #$80            ; mask sign bit only (x000 0000)

Portable 65xx Assembler [20.01]

00:9916  465F              :                 LSR     FAC1_1          ; shift FAC1 mantissa1
00:9918  055F              :                 ORA     FAC1_1          ; OR sign in b7 FAC1 mantissa1
00:991A  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:991C  209A96            :                 JSR     LAB_2592        ; shift FAC1 Y times right
00:991F  8464              :                 STY     FAC1_o          ; clear FAC1 overflow byte
00:9921  60                :                 RTS

                             ; perform INT()

                             LAB_INT
00:9922  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9924  C998              :                 CMP     #$98            ; compare with max int
00:9926  B01E              :                 BCS     LAB_2886        ; exit if >= (already int, too big for fractional part!)

00:9928  20F198            :                 JSR     LAB_2831        ; convert FAC1 floating-to-fixed
00:992B  846B              :                 STY     FAC1_r          ; save FAC1 rounding byte
00:992D  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:992F  8462              :                 STY     FAC1_s          ; save FAC1 sign (b7)
00:9931  4980              :                 EOR     #$80            ; toggle FAC1 sign
00:9933  2A                :                 ROL                     ; shift into carry
00:9934  A998              :                 LDA     #$98            ; set new exponent
00:9936  855E              :                 STA     FAC1_e          ; save FAC1 exponent
00:9938  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:993A  850D              :                 STA     Temp3           ; save for EXP() function
00:993C  4CD895            :                 JMP     LAB_24D0        ; do ABS and normalise FAC1

                             ; clear FAC1 and return

                             LAB_287F
00:993F  855F              :                 STA     FAC1_1          ; clear FAC1 mantissa1
00:9941  8560              :                 STA     FAC1_2          ; clear FAC1 mantissa2
00:9943  8561              :                 STA     FAC1_3          ; clear FAC1 mantissa3
00:9945  A8                :                 TAY                     ; clear Y
                             LAB_2886
00:9946  60                :                 RTS

                             ; get FAC1 from string
                             ; this routine now handles hex and binary values from strings
                             ; starting with "$" and "%" respectively

                             LAB_2887
00:9947  6411              :                 STZ     Dtypef          ; clear data type flag, $FF=string, $00=numeric
00:9949  A209              :                 LDX     #$09            ; set index
                             LAB_288B
00:994B  745A              :                 STZ     numexp,X        ; clear byte
00:994D  CA                :                 DEX                     ; decrement index
00:994E  10FB              :                 BPL     LAB_288B        ; loop until numexp to negnum (and FAC1) = $00

00:9950  907E              :                 BCC     LAB_28FE        ; branch if 1st character numeric

                             ; get FAC1 from string .. first character wasn't numeric

00:9952  C92D              :                 CMP     #'-'            ; else compare with "-"
00:9954  D004              :                 BNE     LAB_289A        ; branch if not "-"

Portable 65xx Assembler [20.01]


00:9956  8663              :                 STX     negnum          ; set flag for -ve number (X = $FF)
00:9958  8004              :                 BRA     LAB_289C        ; branch always (go scan and check for hex/bin)

                             ; get FAC1 from string .. first character wasn't numeric or -

                             LAB_289A
00:995A  C92B              :                 CMP     #'+'            ; else compare with "+"
00:995C  D005              :                 BNE     LAB_289D        ; branch if not "+" (go check for hex/bin)

                             ; was "+" or "-" to start, so get next character

                             LAB_289C
00:995E  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:9961  906D              :                 BCC     LAB_28FE        ; branch if numeric character

                             ; code here for hex and binary numbers

                             LAB_289D
00:9963  C924              :                 CMP     #'$'            ; else compare with "$"
00:9965  D003              :                 BNE     LAB_NHEX        ; branch if not "$"

00:9967  4C019E            :                 JMP     LAB_CHEX        ; branch if "$"

                             LAB_NHEX
00:996A  C925              :                 CMP     #'%'            ; else compare with "%"
00:996C  D008              :                 BNE     LAB_28A3        ; branch if not "%" (continue original code)

00:996E  4C2F9E            :                 JMP     LAB_CBIN        ; branch if "%"

                             LAB_289E
00:9971  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory (ignore + or get next number)
                             LAB_28A1
00:9974  905A              :                 BCC     LAB_28FE        ; branch if numeric character

                             ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary

                             LAB_28A3
00:9976  C92E              :                 CMP     #'.'            ; else compare with "."
00:9978  F02D              :                 BEQ     LAB_28D5        ; branch if "."

                             ; get FAC1 from string .. character wasn't numeric, -, + or .

00:997A  C945              :                 CMP     #'E'            ; else compare with "E"
00:997C  D02F              :                 BNE     LAB_28DB        ; branch if not "E"

                             ; was "E" so evaluate exponential part
00:997E  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:9981  9017              :                 BCC     LAB_28C7        ; branch if numeric character

00:9983  C9B3              :                 CMP     #TK_MINUS       ; else compare with token for -
00:9985  F00E              :                 BEQ     LAB_28C2        ; branch if token for -

00:9987  C92D              :                 CMP     #'-'            ; else compare with "-"

Portable 65xx Assembler [20.01]

00:9989  F00A              :                 BEQ     LAB_28C2        ; branch if "-"

00:998B  C9B2              :                 CMP     #TK_PLUS        ; else compare with token for +
00:998D  F008              :                 BEQ     LAB_28C4        ; branch if token for +

00:998F  C92B              :                 CMP     #'+'            ; else compare with "+"
00:9991  F004              :                 BEQ     LAB_28C4        ; branch if "+"

00:9993  8007              :                 BRA     LAB_28C9        ; branch always

                             LAB_28C2
00:9995  665D              :                 ROR     expneg          ; set exponent -ve flag (C, which=1, into b7)
                             LAB_28C4
00:9997  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
                             LAB_28C7
00:999A  9059              :                 BCC     LAB_2925        ; branch if numeric character

                             LAB_28C9
00:999C  245D              :                 BIT     expneg          ; test exponent -ve flag
00:999E  100D              :                 BPL     LAB_28DB        ; if +ve go evaluate exponent

                             ; else do exponent = -exponent
00:99A0  A900              :                 LDA     #$00            ; clear result
00:99A2  38                :                 SEC                     ; set carry for subtract
00:99A3  E55B              :                 SBC     expcnt          ; subtract exponent byte
00:99A5  8008              :                 BRA     LAB_28DD        ; go evaluate exponent

                             LAB_28D5
00:99A7  665C              :                 ROR     numdpf          ; set decimal point flag
00:99A9  245C              :                 BIT     numdpf          ; test decimal point flag
00:99AB  50C4              :                 BVC     LAB_289E        ; branch if only one decimal point so far

                             ; evaluate exponent
                             LAB_28DB
00:99AD  A55B              :                 LDA     expcnt          ; get exponent count byte
                             LAB_28DD
00:99AF  38                :                 SEC                     ; set carry for subtract
00:99B0  E55A              :                 SBC     numexp          ; subtract numerator exponent
00:99B2  855B              :                 STA     expcnt          ; save exponent count byte
00:99B4  F012              :                 BEQ     LAB_28F6        ; branch if no adjustment

00:99B6  1009              :                 BPL     LAB_28EF        ; else if +ve go do FAC1*10^expcnt

                             ; else go do FAC1/10^(0-expcnt)
                             LAB_28E6
00:99B8  209897            :                 JSR     LAB_26B9        ; divide by 10
00:99BB  E65B              :                 INC     expcnt          ; increment exponent count byte
00:99BD  D0F9              :                 BNE     LAB_28E6        ; loop until all done

00:99BF  8007              :                 BRA     LAB_28F6        ; branch always

                             LAB_28EF
00:99C1  207F97            :                 JSR     LAB_269E        ; multiply by 10
00:99C4  C65B              :                 DEC     expcnt          ; decrement exponent count byte

Portable 65xx Assembler [20.01]

00:99C6  D0F9              :                 BNE     LAB_28EF        ; loop until all done

                             LAB_28F6
00:99C8  A563              :                 LDA     negnum          ; get -ve flag
00:99CA  3001              :                 BMI     LAB_28FB        ; if -ve do - FAC1 and return
00:99CC  60                :                 RTS

                             ; do - FAC1 and return

                             LAB_28FB
00:99CD  4C8E9B            :                 JMP     LAB_GTHAN       ; do - FAC1 and return

                             ; do unsigned FAC1*10+number

                             LAB_28FE
00:99D0  48                :                 PHA                     ; save character
00:99D1  245C              :                 BIT     numdpf          ; test decimal point flag
00:99D3  1002              :                 BPL     LAB_2905        ; skip exponent increment if not set

00:99D5  E65A              :                 INC     numexp          ; else increment number exponent
                             LAB_2905
00:99D7  207F97            :                 JSR     LAB_269E        ; multiply FAC1 by 10
00:99DA  68                :                 PLA                     ; restore character
00:99DB  290F              :                 AND     #$0F            ; convert to binary
00:99DD  20E299            :                 JSR     LAB_2912        ; evaluate new ASCII digit
00:99E0  808F              :                 BRA     LAB_289E        ; go do next character

                             ; evaluate new ASCII digit

                             LAB_2912
00:99E2  48                :                 PHA                     ; save digit
00:99E3  207098            :                 JSR     LAB_27AB        ; round and copy FAC1 to FAC2
00:99E6  68                :                 PLA                     ; restore digit
00:99E7  20A098            :                 JSR     LAB_27DB        ; save A as integer byte
00:99EA  A569              :                 LDA     FAC2_s          ; get FAC2 sign (b7)
00:99EC  4562              :                 EOR     FAC1_s          ; toggle with FAC1 sign (b7)
00:99EE  856A              :                 STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00:99F0  A65E              :                 LDX     FAC1_e          ; get FAC1 exponent
00:99F2  4C6E95            :                 JMP     LAB_ADD         ; add FAC2 to FAC1 and return

                             ; evaluate next character of exponential part of number

                             LAB_2925
00:99F5  A55B              :                 LDA     expcnt          ; get exponent count byte
00:99F7  C90A              :                 CMP     #$0A            ; compare with 10 decimal
00:99F9  9009              :                 BCC     LAB_2934        ; branch if less

00:99FB  A964              :                 LDA     #$64            ; make all -ve exponents = -100 decimal (causes underflow)
00:99FD  245D              :                 BIT     expneg          ; test exponent -ve flag
00:99FF  300C              :                 BMI     LAB_2942        ; branch if -ve

00:9A01  4C6C96            :                 JMP     LAB_2564        ; else do overflow error

                             LAB_2934

Portable 65xx Assembler [20.01]

00:9A04  0A                :                 ASL                     ; * 2
00:9A05  0A                :                 ASL                     ; * 4
00:9A06  655B              :                 ADC     expcnt          ; * 5
00:9A08  0A                :                 ASL                     ; * 10
00:9A09  726E              :                 ADC     (Bpntrl)        ; add character (will be $30 too much!)
00:9A0B  E92F              :                 SBC     #'0'-1          ; convert character to binary
                             LAB_2942
00:9A0D  855B              :                 STA     expcnt          ; save exponent count byte
00:9A0F  8086              :                 BRA     LAB_28C4        ; go get next character

                             ; print " in line [LINE #]"

                             LAB_2953
00:9A11  A997              :                 LDA     #<LAB_LMSG      ; point to " in line " message low byte
00:9A13  A0A6              :                 LDY     #>LAB_LMSG      ; point to " in line " message high byte
00:9A15  20A088            :                 JSR     LAB_18C3        ; print null terminated string from memory

                             ; print Basic line #
00:9A18  A53A              :                 LDA     Clineh          ; get current line high byte
00:9A1A  A639              :                 LDX     Clinel          ; get current line low byte

                             ; print XA as unsigned integer

                             LAB_295E
00:9A1C  855F              :                 STA     FAC1_1          ; save low byte as FAC1 mantissa1
00:9A1E  8660              :                 STX     FAC1_2          ; save high byte as FAC1 mantissa2
00:9A20  A290              :                 LDX     #$90            ; set exponent to 16d bits
00:9A22  38                :                 SEC                     ; set integer is +ve flag
00:9A23  20AB98            :                 JSR     LAB_STFA        ; set exp=X, clearFAC1 mantissa3 and normalise
00:9A26  A000              :                 LDY     #$00            ; clear index
00:9A28  98                :                 TYA                     ; clear A
00:9A29  203C9A            :                 JSR     LAB_297B        ; convert FAC1 to string, skip sign character save
00:9A2C  4CA088            :                 JMP     LAB_18C3        ; print null terminated string from memory and return

                             ; convert FAC1 to ASCII string result in (AY)
                             ; not any more, moved scratchpad to page 0

                             LAB_296E
00:9A2F  A001              :                 LDY     #$01            ; set index = 1
00:9A31  A920              :                 LDA     #$20            ; character = " " (assume +ve)
00:9A33  2462              :                 BIT     FAC1_s          ; test FAC1 sign (b7)
00:9A35  1002              :                 BPL     LAB_2978        ; branch if +ve

00:9A37  A92D              :                 LDA     #$2D            ; else character = "-"
                             LAB_2978
00:9A39  997400            :                 STA     Decss,Y         ; save leading character (" " or "-")
                             LAB_297B
00:9A3C  8562              :                 STA     FAC1_s          ; clear FAC1 sign (b7)
00:9A3E  846C              :                 STY     Sendl           ; save index
00:9A40  C8                :                 INY                     ; increment index
00:9A41  A65E              :                 LDX     FAC1_e          ; get FAC1 exponent
00:9A43  D005              :                 BNE     LAB_2989        ; branch if FAC1<>0

                             ; exponent was $00 so FAC1 is 0

Portable 65xx Assembler [20.01]

00:9A45  A930              :                 LDA     #'0'            ; set character = "0"
00:9A47  4C489B            :                 JMP     LAB_2A89        ; save last character, [EOT] and exit

                             ; FAC1 is some non zero value
                             LAB_2989
00:9A4A  A900              :                 LDA     #$00            ; clear (number exponent count)
00:9A4C  E081              :                 CPX     #$81            ; compare FAC1 exponent with $81 (>1.00000)

00:9A4E  B009              :                 BCS     LAB_299A        ; branch if FAC1=>1

                             ; FAC1<1
00:9A50  A952              :                 LDA     #<LAB_294F      ; set pointer low byte to 1,000,000
00:9A52  A0A0              :                 LDY     #>LAB_294F      ; set pointer high byte to 1,000,000
00:9A54  20E296            :                 JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
00:9A57  A9FA              :                 LDA     #$FA            ; set number exponent count (-6)
                             LAB_299A
00:9A59  855A              :                 STA     numexp          ; save number exponent count
                             LAB_299C
00:9A5B  A94E              :                 LDA     #<LAB_294B      ; set pointer low byte to 999999.4375 (max before sci note)
00:9A5D  A0A0              :                 LDY     #>LAB_294B      ; set pointer high byte to 999999.4375
00:9A5F  20B998            :                 JSR     LAB_27F8        ; compare FAC1 with (AY)
00:9A62  F01E              :                 BEQ     LAB_29C3        ; exit if FAC1 = (AY)

00:9A64  1012              :                 BPL     LAB_29B9        ; go do /10 if FAC1 > (AY)

                             ; FAC1 < (AY)
                             LAB_29A7
00:9A66  A94A              :                 LDA     #<LAB_2947      ; set pointer low byte to 99999.9375
00:9A68  A0A0              :                 LDY     #>LAB_2947      ; set pointer high byte to 99999.9375
00:9A6A  20B998            :                 JSR     LAB_27F8        ; compare FAC1 with (AY)
00:9A6D  F002              :                 BEQ     LAB_29B2        ; branch if FAC1 = (AY) (allow decimal places)

00:9A6F  100E              :                 BPL     LAB_29C0        ; branch if FAC1 > (AY) (no decimal places)

                             ; FAC1 <= (AY)
                             LAB_29B2
00:9A71  207F97            :                 JSR     LAB_269E        ; multiply by 10
00:9A74  C65A              :                 DEC     numexp          ; decrement number exponent count
00:9A76  80EE              :                 BRA     LAB_29A7        ; go test again (branch always)

                             LAB_29B9
00:9A78  209897            :                 JSR     LAB_26B9        ; divide by 10
00:9A7B  E65A              :                 INC     numexp          ; increment number exponent count
00:9A7D  80DC              :                 BRA     LAB_299C        ; go test again (branch always)

                             ; now we have just the digits to do

                             LAB_29C0
00:9A7F  206795            :                 JSR     LAB_244E        ; add 0.5 to FAC1 (round FAC1)
                             LAB_29C3
00:9A82  20F198            :                 JSR     LAB_2831        ; convert FAC1 floating-to-fixed
00:9A85  A201              :                 LDX     #$01            ; set default digits before dp = 1
00:9A87  A55A              :                 LDA     numexp          ; get number exponent count
00:9A89  18                :                 CLC                     ; clear carry for add

Portable 65xx Assembler [20.01]

00:9A8A  6907              :                 ADC     #$07            ; up to 6 digits before point
00:9A8C  3009              :                 BMI     LAB_29D8        ; if -ve then 1 digit before dp

00:9A8E  C908              :                 CMP     #$08            ; A>=8 if n>=1E6
00:9A90  B006              :                 BCS     LAB_29D9        ; branch if >= $08

                             ; carry is clear
00:9A92  69FF              :                 ADC     #$FF            ; take 1 from digit count
00:9A94  AA                :                 TAX                     ; copy to A
00:9A95  A902              :                 LDA     #$02            ;.set exponent adjust
                             LAB_29D8
00:9A97  38                :                 SEC                     ; set carry for subtract
                             LAB_29D9
00:9A98  E902              :                 SBC     #$02            ; -2
00:9A9A  855B              :                 STA     expcnt          ; save exponent adjust
00:9A9C  865A              :                 STX     numexp          ; save digits before dp count
00:9A9E  8A                :                 TXA                     ; copy to A
00:9A9F  F002              :                 BEQ     LAB_29E4        ; branch if no digits before dp

00:9AA1  1013              :                 BPL     LAB_29F7        ; branch if digits before dp

                             LAB_29E4
00:9AA3  A46C              :                 LDY     Sendl           ; get output string index
00:9AA5  A92E              :                 LDA     #$2E            ; character "."
00:9AA7  C8                :                 INY                     ; increment index
00:9AA8  997400            :                 STA     Decss,Y         ; save to output string
00:9AAB  8A                :                 TXA                     ;
00:9AAC  F006              :                 BEQ     LAB_29F5        ;

00:9AAE  A930              :                 LDA     #'0'            ; character "0"
00:9AB0  C8                :                 INY                     ; increment index
00:9AB1  997400            :                 STA     Decss,Y         ; save to output string
                             LAB_29F5
00:9AB4  846C              :                 STY     Sendl           ; save output string index
                             LAB_29F7
00:9AB6  A000              :                 LDY     #$00            ; clear index (point to 100,000)
00:9AB8  A280              :                 LDX     #$80            ;
                             LAB_29FB
00:9ABA  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:9ABC  18                :                 CLC                     ; clear carry for add
00:9ABD  79C8A0            :                 ADC     LAB_2A9C,Y      ; add -ve LSB
00:9AC0  8561              :                 STA     FAC1_3          ; save FAC1 mantissa3
00:9AC2  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:9AC4  79C7A0            :                 ADC     LAB_2A9B,Y      ; add -ve NMSB
00:9AC7  8560              :                 STA     FAC1_2          ; save FAC1 mantissa2
00:9AC9  A55F              :                 LDA     FAC1_1          ; get FAC1 mantissa1
00:9ACB  79C6A0            :                 ADC     LAB_2A9A,Y      ; add -ve MSB
00:9ACE  855F              :                 STA     FAC1_1          ; save FAC1 mantissa1
00:9AD0  E8                :                 INX                     ;
00:9AD1  B004              :                 BCS     LAB_2A18        ;

00:9AD3  10E5              :                 BPL     LAB_29FB        ; not -ve so try again

00:9AD5  3002              :                 BMI     LAB_2A1A        ;

Portable 65xx Assembler [20.01]


                             LAB_2A18
00:9AD7  30E1              :                 BMI     LAB_29FB        ;

                             LAB_2A1A
00:9AD9  8A                :                 TXA                     ;
00:9ADA  9004              :                 BCC     LAB_2A21        ;

00:9ADC  49FF              :                 EOR     #$FF            ;
00:9ADE  690A              :                 ADC     #$0A            ;
                             LAB_2A21
00:9AE0  692F              :                 ADC     #'0'-1          ; add "0"-1 to result
00:9AE2  C8                :                 INY                     ; increment index ..
00:9AE3  C8                :                 INY                     ; .. to next less ..
00:9AE4  C8                :                 INY                     ; .. power of ten
00:9AE5  8447              :                 STY     Cvaral          ; save as current var address low byte
00:9AE7  A46C              :                 LDY     Sendl           ; get output string index
00:9AE9  C8                :                 INY                     ; increment output string index
00:9AEA  AA                :                 TAX                     ; copy character to X
00:9AEB  297F              :                 AND     #$7F            ; mask out top bit
00:9AED  997400            :                 STA     Decss,Y         ; save to output string
00:9AF0  C65A              :                 DEC     numexp          ; decrement # of characters before the dp
00:9AF2  D006              :                 BNE     LAB_2A3B        ; branch if still characters to do

                             ; else output the point
00:9AF4  A92E              :                 LDA     #$2E            ; character "."
00:9AF6  C8                :                 INY                     ; increment output string index
00:9AF7  997400            :                 STA     Decss,Y         ; save to output string
                             LAB_2A3B
00:9AFA  846C              :                 STY     Sendl           ; save output string index
00:9AFC  A447              :                 LDY     Cvaral          ; get current var address low byte
00:9AFE  8A                :                 TXA                     ; get character back
00:9AFF  49FF              :                 EOR     #$FF            ;
00:9B01  2980              :                 AND     #$80            ;
00:9B03  AA                :                 TAX                     ;
00:9B04  C012              :                 CPY     #$12            ; compare index with max
00:9B06  D0B2              :                 BNE     LAB_29FB        ; loop if not max

                             ; now remove trailing zeroes
00:9B08  A46C              :                 LDY     Sendl           ; get output string index
                             LAB_2A4B
00:9B0A  B97400            :                 LDA     Decss,Y         ; get character from output string
00:9B0D  88                :                 DEY                     ; decrement output string index
00:9B0E  C930              :                 CMP     #'0'            ; compare with "0"
00:9B10  F0F8              :                 BEQ     LAB_2A4B        ; loop until non "0" character found

00:9B12  C92E              :                 CMP     #'.'            ; compare with "."
00:9B14  F001              :                 BEQ     LAB_2A58        ; branch if was dp

                             ; restore last character
00:9B16  C8                :                 INY                     ; increment output string index
                             LAB_2A58
00:9B17  A92B              :                 LDA     #$2B            ; character "+"
00:9B19  A65B              :                 LDX     expcnt          ; get exponent count

Portable 65xx Assembler [20.01]

00:9B1B  F02E              :                 BEQ     LAB_2A8C        ; if zero go set null terminator and exit

                             ; exponent isn't zero so write exponent
00:9B1D  1008              :                 BPL     LAB_2A68        ; branch if exponent count +ve

00:9B1F  A900              :                 LDA     #$00            ; clear A
00:9B21  38                :                 SEC                     ; set carry for subtract
00:9B22  E55B              :                 SBC     expcnt          ; subtract exponent count adjust (convert -ve to +ve)
00:9B24  AA                :                 TAX                     ; copy exponent count to X
00:9B25  A92D              :                 LDA     #'-'            ; character "-"
                             LAB_2A68
00:9B27  997600            :                 STA     Decss+2,Y       ; save to output string
00:9B2A  A945              :                 LDA     #$45            ; character "E"
00:9B2C  997500            :                 STA     Decss+1,Y       ; save exponent sign to output string
00:9B2F  8A                :                 TXA                     ; get exponent count back
00:9B30  A22F              :                 LDX     #'0'-1          ; one less than "0" character
00:9B32  38                :                 SEC                     ; set carry for subtract
                             LAB_2A74
00:9B33  E8                :                 INX                     ; increment 10's character
00:9B34  E90A              :                 SBC     #$0A            ; subtract 10 from exponent count
00:9B36  B0FB              :                 BCS     LAB_2A74        ; loop while still >= 0

00:9B38  693A              :                 ADC     #':'            ; add character ":" ($30+$0A, result is 10 less that value)
00:9B3A  997800            :                 STA     Decss+4,Y       ; save to output string
00:9B3D  8A                :                 TXA                     ; copy 10's character
00:9B3E  997700            :                 STA     Decss+3,Y       ; save to output string
00:9B41  A900              :                 LDA     #$00            ; set null terminator
00:9B43  997900            :                 STA     Decss+5,Y       ; save to output string
00:9B46  8008              :                 BRA     LAB_2A91        ; go set string pointer (AY) and exit (branch always)

                             ; save last character, [EOT] and exit
                             LAB_2A89
00:9B48  997400            :                 STA     Decss,Y         ; save last character to output string

                             ; set null terminator and exit
                             LAB_2A8C
00:9B4B  A900              :                 LDA     #$00            ; set null terminator
00:9B4D  997500            :                 STA     Decss+1,Y       ; save after last character

                             ; set string pointer (AY) and exit
                             LAB_2A91
00:9B50  A975              :                 LDA     #<Decssp1       ; set result string low pointer
00:9B52  A000              :                 LDY     #>Decssp1       ; set result string high pointer
00:9B54  60                :                 RTS

                             ; perform power function

                             LAB_POWER
00:9B55  F042              :                 BEQ     LAB_EXP         ; go do  EXP()

00:9B57  A565              :                 LDA     FAC2_e          ; get FAC2 exponent
00:9B59  D003              :                 BNE     LAB_2ABF        ; branch if FAC2<>0

00:9B5B  4CFB95            :                 JMP     LAB_24F3        ; clear FAC1 exponent and sign and return

Portable 65xx Assembler [20.01]


                             LAB_2ABF
00:9B5E  A24E              :                 LDX     #<func_l        ; set destination pointer low byte
00:9B60  A000              :                 LDY     #>func_l        ; set destination pointer high byte
00:9B62  204D98            :                 JSR     LAB_2778        ; pack FAC1 into (XY)
00:9B65  A569              :                 LDA     FAC2_s          ; get FAC2 sign (b7)
00:9B67  100F              :                 BPL     LAB_2AD9        ; branch if FAC2>0

                             ; else FAC2 is -ve and can only be raised to an
                             ; integer power which gives an x +j0 result
00:9B69  202299            :                 JSR     LAB_INT         ; perform INT
00:9B6C  A94E              :                 LDA     #<func_l        ; set source pointer low byte
00:9B6E  A000              :                 LDY     #>func_l        ; set source pointer high byte
00:9B70  20B998            :                 JSR     LAB_27F8        ; compare FAC1 with (AY)
00:9B73  D003              :                 BNE     LAB_2AD9        ; branch if FAC1 <> (AY) to allow Function Call error
                             ; this will leave FAC1 -ve and cause a Function Call
                             ; error when LOG() is called

00:9B75  98                :                 TYA                     ; clear sign b7
00:9B76  A40D              :                 LDY     Temp3           ; save mantissa 3 from INT() function as sign in Y
                             ; for possible later negation, b0
                             LAB_2AD9
00:9B78  207295            :                 JSR     LAB_279D        ; save FAC1 sign and copy ABS(FAC2) to FAC1
00:9B7B  98                :                 TYA                     ; copy sign back ..
00:9B7C  48                :                 PHA                     ; .. and save it
00:9B7D  20A496            :                 JSR     LAB_LOG         ; do LOG(n)
00:9B80  A94E              :                 LDA     #<garb_l        ; set pointer low byte
00:9B82  A000              :                 LDY     #>garb_l        ; set pointer high byte
00:9B84  20E296            :                 JSR     LAB_25FB        ; do convert AY, FCA1*(AY) (square the value)
00:9B87  20999B            :                 JSR     LAB_EXP         ; go do EXP(n)
00:9B8A  68                :                 PLA                     ; pull sign from stack
00:9B8B  4A                :                 LSR                     ; b0 is to be tested, shift to Cb
00:9B8C  900A              :                 BCC     LAB_2AF9        ; if no bit then exit

                             ; Perform negation
                             ; do - FAC1

                             LAB_GTHAN
00:9B8E  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9B90  F006              :                 BEQ     LAB_2AF9        ; exit if FAC1_e = $00

00:9B92  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9B94  49FF              :                 EOR     #$FF            ; complement it
00:9B96  8562              :                 STA     FAC1_s          ; save FAC1 sign (b7)
                             LAB_2AF9
00:9B98  60                :                 RTS

                             ; perform EXP()   (x^e)

                             LAB_EXP
00:9B99  A956              :                 LDA     #<LAB_2AFA      ; set 1.443 pointer low byte
00:9B9B  A0A0              :                 LDY     #>LAB_2AFA      ; set 1.443 pointer high byte
00:9B9D  20E296            :                 JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
00:9BA0  A56B              :                 LDA     FAC1_r          ; get FAC1 rounding byte

Portable 65xx Assembler [20.01]

00:9BA2  6950              :                 ADC     #$50            ; +$50/$100
00:9BA4  9003              :                 BCC     LAB_2B2B        ; skip rounding if no carry

00:9BA6  208798            :                 JSR     LAB_27C2        ; round FAC1 (no check)
                             LAB_2B2B
00:9BA9  8555              :                 STA     FAC2_r          ; save FAC2 rounding byte
00:9BAB  207398            :                 JSR     LAB_27AE        ; copy FAC1 to FAC2
00:9BAE  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9BB0  C988              :                 CMP     #$88            ; compare with EXP limit (256d)
00:9BB2  9003              :                 BCC     LAB_2B39        ; branch if less

                             LAB_2B36
00:9BB4  207697            :                 JSR     LAB_2690        ; handle overflow and underflow
                             LAB_2B39
00:9BB7  202299            :                 JSR     LAB_INT         ; perform INT
00:9BBA  A50D              :                 LDA     Temp3           ; get mantissa 3 from INT() function
00:9BBC  18                :                 CLC                     ; clear carry for add
00:9BBD  6981              :                 ADC     #$81            ; normalise +1
00:9BBF  F0F3              :                 BEQ     LAB_2B36        ; if $00 go handle overflow

00:9BC1  38                :                 SEC                     ; set carry for subtract
00:9BC2  E901              :                 SBC     #$01            ; now correct for exponent
00:9BC4  48                :                 PHA                     ; save FAC2 exponent

                             ; swap FAC1 and FAC2
00:9BC5  A204              :                 LDX     #$04            ; 4 bytes to do
                             LAB_2B49
00:9BC7  B565              :                 LDA     FAC2_e,X        ; get FAC2,X
00:9BC9  B45E              :                 LDY     FAC1_e,X        ; get FAC1,X
00:9BCB  955E              :                 STA     FAC1_e,X        ; save FAC1,X
00:9BCD  9465              :                 STY     FAC2_e,X        ; save FAC2,X
00:9BCF  CA                :                 DEX                     ; decrement count/index
00:9BD0  10F5              :                 BPL     LAB_2B49        ; loop if not all done

00:9BD2  A555              :                 LDA     FAC2_r          ; get FAC2 rounding byte
00:9BD4  856B              :                 STA     FAC1_r          ; save as FAC1 rounding byte
00:9BD6  205495            :                 JSR     LAB_SUBTRACT    ; perform subtraction, FAC2 from FAC1
00:9BD9  208E9B            :                 JSR     LAB_GTHAN       ; do - FAC1
00:9BDC  A95A              :                 LDA     #<LAB_2AFE      ; set counter pointer low byte
00:9BDE  A0A0              :                 LDY     #>LAB_2AFE      ; set counter pointer high byte
00:9BE0  20FF9B            :                 JSR     LAB_2B84        ; go do series evaluation
00:9BE3  646A              :                 STZ     FAC_sc          ; clear sign compare (FAC1 EOR FAC2)
00:9BE5  68                :                 PLA                     ;.get saved FAC2 exponent
00:9BE6  4C5A97            :                 JMP     LAB_2675        ; test and adjust accumulators and return

                             ; ^2 then series evaluation

                             LAB_2B6E
00:9BE9  856C              :                 STA     Cptrl           ; save count pointer low byte
00:9BEB  846D              :                 STY     Cptrh           ; save count pointer high byte
00:9BED  204398            :                 JSR     LAB_276E        ; pack FAC1 into Adatal
00:9BF0  A956              :                 LDA     #<Adatal        ; set pointer low byte (Y already $00)
00:9BF2  20E296            :                 JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
00:9BF5  20039C            :                 JSR     LAB_2B88        ; go do series evaluation

Portable 65xx Assembler [20.01]

00:9BF8  A956              :                 LDA     #<Adatal        ; pointer to original # low byte
00:9BFA  A000              :                 LDY     #>Adatal        ; pointer to original # high byte
00:9BFC  4CE296            :                 JMP     LAB_25FB        ; do convert AY, FCA1*(AY) and return

                             ; series evaluation

                             LAB_2B84
00:9BFF  856C              :                 STA     Cptrl           ; save count pointer low byte
00:9C01  846D              :                 STY     Cptrh           ; save count pointer high byte
                             LAB_2B88
00:9C03  A25A              :                 LDX     #<numexp        ; set pointer low byte
00:9C05  204598            :                 JSR     LAB_2770        ; set pointer high byte and pack FAC1 into numexp
00:9C08  B16C              :                 LDA     (Cptrl),Y       ; get constants count
00:9C0A  8563              :                 STA     numcon          ; save constants count
00:9C0C  A46C              :                 LDY     Cptrl           ; get count pointer low byte
00:9C0E  C8                :                 INY                     ; increment it (now constants pointer)
00:9C0F  98                :                 TYA                     ; copy it
00:9C10  D002              :                 BNE     LAB_2B97        ; skip next if no overflow

00:9C12  E66D              :                 INC     Cptrh           ; else increment high byte
                             LAB_2B97
00:9C14  856C              :                 STA     Cptrl           ; save low byte
00:9C16  A46D              :                 LDY     Cptrh           ; get high byte
                             LAB_2B9B
00:9C18  20E296            :                 JSR     LAB_25FB        ; do convert AY, FCA1*(AY)
00:9C1B  A56C              :                 LDA     Cptrl           ; get constants pointer low byte
00:9C1D  A46D              :                 LDY     Cptrh           ; get constants pointer high byte
00:9C1F  18                :                 CLC                     ; clear carry for add
00:9C20  6904              :                 ADC     #$04            ; +4 to  low pointer (4 bytes per constant)
00:9C22  9001              :                 BCC     LAB_2BA8        ; skip next if no overflow

00:9C24  C8                :                 INY                     ; increment high byte
                             LAB_2BA8
00:9C25  856C              :                 STA     Cptrl           ; save pointer low byte
00:9C27  846D              :                 STY     Cptrh           ; save pointer high byte
00:9C29  206B95            :                 JSR     LAB_246C        ; add (AY) to FAC1
00:9C2C  A95A              :                 LDA     #<numexp        ; set pointer low byte to partial @ numexp
00:9C2E  A000              :                 LDY     #>numexp        ; set pointer high byte to partial @ numexp
00:9C30  C663              :                 DEC     numcon          ; decrement constants count
00:9C32  D0E4              :                 BNE     LAB_2B9B        ; loop until all done
00:9C34  60                :                 RTS

                             ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
                             ; to get 19th next number in sequence after seed n. This version of the PRNG uses
                             ; the Galois method and a sample of 65536 bytes produced gives the following values.

                             ; Entropy = 7.997442 bits per byte
                             ; Optimum compression would reduce these 65536 bytes by 0 percent

                             ; Chi square distribution for 65536 samples is 232.01, and
                             ; randomly would exceed this value 75.00 percent of the time

                             ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
                             ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent

Portable 65xx Assembler [20.01]

                             ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0

                             LAB_RND
00:9C35  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9C37  F007              :                 BEQ     NextPRN         ; do next random # if zero

                             ; else get seed into random number store
00:9C39  A270              :                 LDX     #Rbyte4         ; set PRNG pointer low byte
00:9C3B  A000              :                 LDY     #$00            ; set PRNG pointer high byte
00:9C3D  204D98            :                 JSR     LAB_2778        ; pack FAC1 into (XY)
                             NextPRN
00:9C40  A2AF              :                 LDX     #$AF            ; set EOR byte
00:9C42  A013              :                 LDY     #$13            ; do this nineteen times
                             LoopPRN
00:9C44  0671              :                 ASL     Rbyte1          ; shift PRNG most significant byte
00:9C46  2672              :                 ROL     Rbyte2          ; shift PRNG middle byte
00:9C48  2673              :                 ROL     Rbyte3          ; shift PRNG least significant byte
00:9C4A  2670              :                 ROL     Rbyte4          ; shift PRNG extra byte
00:9C4C  9005              :                 BCC     Ninc1           ; branch if bit 32 clear

00:9C4E  8A                :                 TXA                     ; set EOR byte
00:9C4F  4571              :                 EOR     Rbyte1          ; EOR PRNG extra byte
00:9C51  8571              :                 STA     Rbyte1          ; save new PRNG extra byte
                             Ninc1
00:9C53  88                :                 DEY                     ; decrement loop count
00:9C54  D0EE              :                 BNE     LoopPRN         ; loop if not all done

00:9C56  A202              :                 LDX     #$02            ; three bytes to copy
                             CopyPRNG
00:9C58  B571              :                 LDA     Rbyte1,X        ; get PRNG byte
00:9C5A  955F              :                 STA     FAC1_1,X        ; save FAC1 byte
00:9C5C  CA                :                 DEX
00:9C5D  10F9              :                 BPL     CopyPRNG        ; loop if not complete

00:9C5F  A980              :                 LDA     #$80            ; set the exponent
00:9C61  855E              :                 STA     FAC1_e          ; save FAC1 exponent

00:9C63  0A                :                 ASL                     ; clear A
00:9C64  8562              :                 STA     FAC1_s          ; save FAC1 sign

00:9C66  4CDD95            :                 JMP     LAB_24D5        ; normalise FAC1 and return

                             ; perform COS()

                             LAB_COS
00:9C69  A977              :                 LDA     #<LAB_2C78      ; set (pi/2) pointer low byte
00:9C6B  A0A0              :                 LDY     #>LAB_2C78      ; set (pi/2) pointer high byte
00:9C6D  206B95            :                 JSR     LAB_246C        ; add (AY) to FAC1

                             ; perform SIN()

                             LAB_SIN
00:9C70  207098            :                 JSR     LAB_27AB        ; round and copy FAC1 to FAC2
00:9C73  A98C              :                 LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte

Portable 65xx Assembler [20.01]

00:9C75  A0A0              :                 LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
00:9C77  A669              :                 LDX     FAC2_s          ; get FAC2 sign (b7)
00:9C79  20A197            :                 JSR     LAB_26C2        ; divide by (AY) (X=sign)
00:9C7C  207098            :                 JSR     LAB_27AB        ; round and copy FAC1 to FAC2
00:9C7F  202299            :                 JSR     LAB_INT         ; perform INT
00:9C82  646A              :                 STZ     FAC_sc          ; clear sign compare (FAC1 EOR FAC2)
00:9C84  205495            :                 JSR     LAB_SUBTRACT    ; perform subtraction, FAC2 from FAC1
00:9C87  A9BE              :                 LDA     #<LAB_2C80      ; set 0.25 pointer low byte
00:9C89  A0A0              :                 LDY     #>LAB_2C80      ; set 0.25 pointer high byte
00:9C8B  205195            :                 JSR     LAB_2455        ; perform subtraction, (AY) from FAC1
00:9C8E  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9C90  48                :                 PHA                     ; save FAC1 sign
00:9C91  100D              :                 BPL     LAB_2C35        ; branch if +ve

                             ; FAC1 sign was -ve
00:9C93  206795            :                 JSR     LAB_244E        ; add 0.5 to FAC1
00:9C96  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9C98  3009              :                 BMI     LAB_2C38        ; branch if -ve

00:9C9A  A515              :                 LDA     Cflag           ; get comparison evaluation flag
00:9C9C  49FF              :                 EOR     #$FF            ; toggle flag
00:9C9E  8515              :                 STA     Cflag           ; save comparison evaluation flag
                             LAB_2C35
00:9CA0  208E9B            :                 JSR     LAB_GTHAN       ; do - FAC1
                             LAB_2C38
00:9CA3  A9BE              :                 LDA     #<LAB_2C80      ; set 0.25 pointer low byte
00:9CA5  A0A0              :                 LDY     #>LAB_2C80      ; set 0.25 pointer high byte
00:9CA7  206B95            :                 JSR     LAB_246C        ; add (AY) to FAC1
00:9CAA  68                :                 PLA                     ; restore FAC1 sign
00:9CAB  1003              :                 BPL     LAB_2C45        ; branch if was +ve

                             ; else correct FAC1
00:9CAD  208E9B            :                 JSR     LAB_GTHAN       ; do - FAC1
                             LAB_2C45
00:9CB0  A97B              :                 LDA     #<LAB_2C84      ; set pointer low byte to counter
00:9CB2  A0A0              :                 LDY     #>LAB_2C84      ; set pointer high byte to counter
00:9CB4  4CE99B            :                 JMP     LAB_2B6E        ; ^2 then series evaluation and return

                             ; perform TAN()

                             LAB_TAN
00:9CB7  204398            :                 JSR     LAB_276E        ; pack FAC1 into Adatal
00:9CBA  6415              :                 STZ     Cflag           ; clear comparison evaluation flag
00:9CBC  20709C            :                 JSR     LAB_SIN         ; go do SIN(n)
00:9CBF  A24E              :                 LDX     #<func_l        ; set sin(n) pointer low byte
00:9CC1  A000              :                 LDY     #>func_l        ; set sin(n) pointer high byte
00:9CC3  204D98            :                 JSR     LAB_2778        ; pack FAC1 into (XY)
00:9CC6  A956              :                 LDA     #<Adatal        ; set n pointer low addr
00:9CC8  A000              :                 LDY     #>Adatal        ; set n pointer high addr
00:9CCA  202398            :                 JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00:9CCD  6462              :                 STZ     FAC1_s          ; clear FAC1 sign (b7)
00:9CCF  A515              :                 LDA     Cflag           ; get comparison evaluation flag
00:9CD1  20DB9C            :                 JSR     LAB_2C74        ; save flag and go do series evaluation


Portable 65xx Assembler [20.01]

00:9CD4  A94E              :                 LDA     #<func_l        ; set sin(n) pointer low byte
00:9CD6  A000              :                 LDY     #>func_l        ; set sin(n) pointer high byte
00:9CD8  4CA897            :                 JMP     LAB_26CA        ; convert AY and do (AY)/FAC1

                             LAB_2C74
00:9CDB  48                :                 PHA                     ; save comparison evaluation flag
00:9CDC  80C2              :                 BRA     LAB_2C35        ; go do series evaluation

                             ; perform USR()

                             LAB_USR
00:9CDE  200300            :                 JSR     Usrjmp          ; call user code
00:9CE1  4CB78B            :                 JMP     LAB_1BFB        ; scan for ")", else do syntax error then warm start

                             ; perform ATN()

                             LAB_ATN
00:9CE4  A562              :                 LDA     FAC1_s          ; get FAC1 sign (b7)
00:9CE6  48                :                 PHA                     ; save sign
00:9CE7  1003              :                 BPL     LAB_2CA1        ; branch if +ve

00:9CE9  208E9B            :                 JSR     LAB_GTHAN       ; else do - FAC1
                             LAB_2CA1
00:9CEC  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9CEE  48                :                 PHA                     ; push exponent
00:9CEF  C981              :                 CMP     #$81            ; compare with 1
00:9CF1  9007              :                 BCC     LAB_2CAF        ; branch if FAC1<1

00:9CF3  A9B1              :                 LDA     #<LAB_259C      ; set 1 pointer low byte
00:9CF5  A0A0              :                 LDY     #>LAB_259C      ; set 1 pointer high byte
00:9CF7  20A897            :                 JSR     LAB_26CA        ; convert AY and do (AY)/FAC1
                             LAB_2CAF
00:9CFA  A990              :                 LDA     #<LAB_2CC9      ; set pointer low byte to counter
00:9CFC  A0A0              :                 LDY     #>LAB_2CC9      ; set pointer high byte to counter
00:9CFE  20E99B            :                 JSR     LAB_2B6E        ; ^2 then series evaluation
00:9D01  68                :                 PLA                     ; restore old FAC1 exponent
00:9D02  C981              :                 CMP     #$81            ; compare with 1
00:9D04  9007              :                 BCC     LAB_2CC2        ; branch if FAC1<1

00:9D06  A977              :                 LDA     #<LAB_2C78      ; set (pi/2) pointer low byte
00:9D08  A0A0              :                 LDY     #>LAB_2C78      ; set (pi/2) pointer high byte
00:9D0A  205195            :                 JSR     LAB_2455        ; perform subtraction, (AY) from FAC1
                             LAB_2CC2
00:9D0D  68                :                 PLA                     ; restore FAC1 sign
00:9D0E  1016              :                 BPL     LAB_2D04        ; exit if was +ve

00:9D10  4C8E9B            :                 JMP     LAB_GTHAN       ; else do - FAC1 and return

                             ; perform BITSET

                             LAB_BITSET
00:9D13  208694            :                 JSR     LAB_GADB        ; get two parameters for POKE or WAIT
00:9D16  E008              :                 CPX     #$08            ; only 0 to 7 are allowed
00:9D18  B020              :                 BCS     FCError         ; branch if > 7

Portable 65xx Assembler [20.01]


00:9D1A  A900              :                 LDA     #$00            ; clear A
00:9D1C  38                :                 SEC                     ; set the carry
                             S_Bits
00:9D1D  2A                :                 ROL                     ; shift bit
00:9D1E  CA                :                 DEX                     ; decrement bit number
00:9D1F  10FC              :                 BPL     S_Bits          ; loop if still +ve

00:9D21  E8                :                 INX                     ; make X = $00
00:9D22  010A              :                 ORA     (Itempl,X)      ; or with byte via temporary integer (addr)
00:9D24  810A              :                 STA     (Itempl,X)      ; save byte via temporary integer (addr)
                             LAB_2D04
00:9D26  60                :                 RTS

                             ; perform BITCLR

                             LAB_BITCLR
00:9D27  208694            :                 JSR     LAB_GADB        ; get two parameters for POKE or WAIT
00:9D2A  E008              :                 CPX     #$08            ; only 0 to 7 are allowed
00:9D2C  B00C              :                 BCS     FCError         ; branch if > 7

00:9D2E  A9FF              :                 LDA     #$FF            ; set A
                             S_Bitc
00:9D30  2A                :                 ROL                     ; shift bit
00:9D31  CA                :                 DEX                     ; decrement bit number
00:9D32  10FC              :                 BPL     S_Bitc          ; loop if still +ve

00:9D34  E8                :                 INX                     ; make X = $00
00:9D35  210A              :                 AND     (Itempl,X)      ; and with byte via temporary integer (addr)
00:9D37  810A              :                 STA     (Itempl,X)      ; save byte via temporary integer (addr)
00:9D39  60                :                 RTS

                             FCError
00:9D3A  4CE68E            :                 JMP     LAB_FCER        ; do function call error then warm start

                             ; perform BITTST()

                             LAB_BTST
00:9D3D  20D89F            :                 JSR     LAB_IGBY        ; increment BASIC pointer
00:9D40  208694            :                 JSR     LAB_GADB        ; get two parameters for POKE or WAIT
00:9D43  E008              :                 CPX     #$08            ; only 0 to 7 are allowed
00:9D45  B0F3              :                 BCS     FCError         ; branch if > 7

00:9D47  20DE9F            :                 JSR     LAB_GBYT        ; get next BASIC byte
00:9D4A  C929              :                 CMP     #')'            ; is next character ")"
00:9D4C  F003              :                 BEQ     TST_OK          ; if ")" go do rest of function

00:9D4E  4CC88B            :                 JMP     LAB_SNER        ; do syntax error then warm start

                             TST_OK
00:9D51  20D89F            :                 JSR     LAB_IGBY        ; update BASIC execute pointer (to character past ")")
00:9D54  A900              :                 LDA     #$00            ; clear A
00:9D56  38                :                 SEC                     ; set the carry
                             T_Bits

Portable 65xx Assembler [20.01]

00:9D57  2A                :                 ROL                     ; shift bit
00:9D58  CA                :                 DEX                     ; decrement bit number
00:9D59  10FC              :                 BPL     T_Bits          ; loop if still +ve

00:9D5B  E8                :                 INX                     ; make X = $00
00:9D5C  210A              :                 AND     (Itempl,X)      ; AND with byte via temporary integer (addr)
00:9D5E  F002              :                 BEQ     LAB_NOTT        ; branch if zero (already correct)

00:9D60  A9FF              :                 LDA     #$FF            ; set for -1 result
                             LAB_NOTT
00:9D62  4CA098            :                 JMP     LAB_27DB        ; go do SGN tail

                             ; perform BIN$()

                             LAB_BINS
00:9D65  E019              :                 CPX     #$19            ; max + 1
00:9D67  B048              :                 BCS     BinFErr         ; exit if too big ( > or = )

00:9D69  862A              :                 STX     TempB           ; save # of characters ($00 = leading zero remove)
00:9D6B  A918              :                 LDA     #$18            ; need A byte long space
00:9D6D  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long
00:9D70  A017              :                 LDY     #$17            ; set index
00:9D72  A218              :                 LDX     #$18            ; character count
                             NextB1
00:9D74  460A              :                 LSR     nums_1          ; shift highest byte
00:9D76  660B              :                 ROR     nums_2          ; shift middle byte
00:9D78  660C              :                 ROR     nums_3          ; shift lowest byte bit 0 to carry
00:9D7A  8A                :                 TXA                     ; load with "0"/2
00:9D7B  2A                :                 ROL                     ; shift in carry
00:9D7C  915F              :                 STA     (str_pl),Y      ; save to temp string + index
00:9D7E  88                :                 DEY                     ; decrement index
00:9D7F  10F3              :                 BPL     NextB1          ; loop if not done

00:9D81  A52A              :                 LDA     TempB           ; get # of characters
00:9D83  F00A              :                 BEQ     EndBHS          ; branch if truncate

00:9D85  AA                :                 TAX                     ; copy length to X
00:9D86  38                :                 SEC                     ; set carry for add !
00:9D87  49FF              :                 EOR     #$FF            ; 1's complement
00:9D89  6918              :                 ADC     #$18            ; add 24d
00:9D8B  F01C              :                 BEQ     GoPr2           ; if zero print whole string

00:9D8D  D00F              :                 BNE     GoPr1           ; else go make output string

                             ; this is the exit code and is also used by HEX$()
                             ; truncate string to remove leading "0"s

                             EndBHS
00:9D8F  A8                :                 TAY                     ; clear index (A=0, X=length here)
                             NextB2
00:9D90  B15F              :                 LDA     (str_pl),Y      ; get character from string
00:9D92  C930              :                 CMP     #'0'            ; compare with "0"
00:9D94  D007              :                 BNE     GoPr            ; if not "0" then go print string from here


Portable 65xx Assembler [20.01]

00:9D96  CA                :                 DEX                     ; decrement character count
00:9D97  F003              :                 BEQ     GoPr3           ; if zero then end of string so go print it

00:9D99  C8                :                 INY                     ; else increment index
00:9D9A  80F4              :                 BRA     NextB2          ; loop always

                             ; make fixed length output string - ignore overflows!

                             GoPr3
00:9D9C  E8                :                 INX                     ; need at least 1 character
                             GoPr
00:9D9D  98                :                 TYA                     ; copy result
                             GoPr1
00:9D9E  18                :                 CLC                     ; clear carry for add
00:9D9F  655F              :                 ADC     str_pl          ; add low address
00:9DA1  855F              :                 STA     str_pl          ; save low address
00:9DA3  A900              :                 LDA     #$00            ; do high byte
00:9DA5  6560              :                 ADC     str_ph          ; add high address
00:9DA7  8560              :                 STA     str_ph          ; save high address
                             GoPr2
00:9DA9  865E              :                 STX     str_ln          ; X holds string length
00:9DAB  20D89F            :                 JSR     LAB_IGBY        ; update BASIC execute pointer (to character past ")")
00:9DAE  4C4291            :                 JMP     LAB_RTST        ; check for space on descriptor stack then put address
                             ; and length on descriptor stack and update stack pointers

                             BinFErr
00:9DB1  4CE68E            :                 JMP     LAB_FCER        ; do function call error then warm start

                             ; perform HEX$()

                             LAB_HEXS
00:9DB4  E007              :                 CPX     #$07            ; max + 1
00:9DB6  B0F9              :                 BCS     BinFErr         ; exit if too big ( > or = )

00:9DB8  862A              :                 STX     TempB           ; save # of characters

00:9DBA  A906              :                 LDA     #$06            ; need 6 bytes for string
00:9DBC  20F590            :                 JSR     LAB_MSSP        ; make string space A bytes long
00:9DBF  A005              :                 LDY     #$05            ; set string index

00:9DC1  A50C              :                 LDA     nums_3          ; get lowest byte
00:9DC3  20E09D            :                 JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
00:9DC6  A50B              :                 LDA     nums_2          ; get middle byte
00:9DC8  20E09D            :                 JSR     LAB_A2HX        ; convert A to ASCII hex byte and output
00:9DCB  A50A              :                 LDA     nums_1          ; get highest byte
00:9DCD  20E09D            :                 JSR     LAB_A2HX        ; convert A to ASCII hex byte and output

00:9DD0  A206              :                 LDX     #$06            ; character count
00:9DD2  A52A              :                 LDA     TempB           ; get # of characters
00:9DD4  F0B9              :                 BEQ     EndBHS          ; branch if truncate

00:9DD6  AA                :                 TAX                     ; copy length to X
00:9DD7  38                :                 SEC                     ; set carry for add !
00:9DD8  49FF              :                 EOR     #$FF            ; 1's complement

Portable 65xx Assembler [20.01]

00:9DDA  6906              :                 ADC     #$06            ; add 6d
00:9DDC  F0CB              :                 BEQ     GoPr2           ; if zero print whole string

00:9DDE  80BE              :                 BRA     GoPr1           ; else go make output string (branch always)

                             ; convert A to ASCII hex byte and output .. note set decimal mode before calling

                             LAB_A2HX
00:9DE0  AA                :                 TAX                     ; save byte
00:9DE1  290F              :                 AND     #$0F            ; mask off top bits
00:9DE3  20EB9D            :                 JSR     LAB_AL2X        ; convert low nibble to ASCII and output
00:9DE6  8A                :                 TXA                     ; get byte back
00:9DE7  4A                :                 LSR                     ; /2  shift high nibble to low nibble
00:9DE8  4A                :                 LSR                     ; /4
00:9DE9  4A                :                 LSR                     ; /8
00:9DEA  4A                :                 LSR                     ; /16
                             LAB_AL2X
00:9DEB  C90A              :                 CMP     #$0A            ; set carry for +1 if >9
00:9DED  9002              :                 BCC     LAB_AL20        ; skip adjust if <= 9
00:9DEF  6906              :                 ADC     #$06            ; adjust for A to F
                             LAB_AL20
00:9DF1  6930              :                 ADC     #'0'            ; add ASCII "0"
00:9DF3  915F              :                 STA     (str_pl),Y      ; save to temp string
00:9DF5  88                :                 DEY                     ; decrement counter
00:9DF6  60                :                 RTS

                             LAB_NLTO
00:9DF7  855E              :                 STA     FAC1_e          ; save FAC1 exponent
00:9DF9  A900              :                 LDA     #$00            ; clear sign compare
                             LAB_MLTE
00:9DFB  856A              :                 STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00:9DFD  8A                :                 TXA                     ; restore character
00:9DFE  20E299            :                 JSR     LAB_2912        ; evaluate new ASCII digit

                             ; gets here if the first character was "$" for hex
                             ; get hex number

                             LAB_CHEX
00:9E01  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:9E04  900A              :                 BCC     LAB_ISHN        ; branch if numeric character

00:9E06  0920              :                 ORA     #$20            ; case convert, allow "A" to "F" and "a" to "f"
00:9E08  E961              :                 SBC     #'a'            ; subtract "a" (carry set here)
00:9E0A  C906              :                 CMP     #$06            ; compare normalised with $06 (max+1)
00:9E0C  B02A              :                 BCS     LAB_EXCH        ; exit if >"f" or <"0"

00:9E0E  690A              :                 ADC     #$0A            ; convert to nibble
                             LAB_ISHN
00:9E10  290F              :                 AND     #$0F            ; convert to binary
00:9E12  AA                :                 TAX                     ; save nibble
00:9E13  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9E15  F0E4              :                 BEQ     LAB_MLTE        ; skip multiply if zero

00:9E17  6904              :                 ADC     #$04            ; add four to exponent (*16 - carry clear here)

Portable 65xx Assembler [20.01]

00:9E19  90DC              :                 BCC     LAB_NLTO        ; if no overflow do evaluate digit

                             LAB_MLTO
00:9E1B  4C6C96            :                 JMP     LAB_2564        ; do overflow error and warm start

                             LAB_NXCH
00:9E1E  AA                :                 TAX                     ; save bit
00:9E1F  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9E21  F006              :                 BEQ     LAB_MLBT        ; skip multiply if zero

00:9E23  E65E              :                 INC     FAC1_e          ; increment FAC1 exponent (*2)
00:9E25  F0F4              :                 BEQ     LAB_MLTO        ; do overflow error if = $00

00:9E27  A900              :                 LDA     #$00            ; clear sign compare
                             LAB_MLBT
00:9E29  856A              :                 STA     FAC_sc          ; save sign compare (FAC1 EOR FAC2)
00:9E2B  8A                :                 TXA                     ; restore bit
00:9E2C  20E299            :                 JSR     LAB_2912        ; evaluate new ASCII digit

                             ; gets here if the first character was  "%" for binary
                             ; get binary number

                             LAB_CBIN
00:9E2F  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:9E32  4930              :                 EOR     #'0'            ; convert "0" to 0 etc.
00:9E34  C902              :                 CMP     #$02            ; compare with max+1
00:9E36  90E6              :                 BCC     LAB_NXCH        ; branch exit if < 2

                             LAB_EXCH
00:9E38  4CC899            :                 JMP     LAB_28F6        ; evaluate -ve flag and return

                             ; ctrl-c check routine. includes limited "life" byte save for INGET routine
                             ; now also the code that checks to see if an interrupt has occurred

                             CTRLC
00:9E3B  AD7F04            :                 LDA     ccflag          ; get [CTRL-C] check flag
00:9E3E  D018              :                 BNE     LAB_FBA2        ; exit if inhibited

00:9E40  20F69F            :                 JSR     V_INPT          ; scan input device
00:9E43  900B              :                 BCC     LAB_FBA0        ; exit if buffer empty

00:9E45  8D8004            :                 STA     ccbyte          ; save received byte
00:9E48  A220              :                 LDX     #$20            ; "life" timer for bytes
00:9E4A  8E8104            :                 STX     ccnull          ; set countdown
00:9E4D  4C0785            :                 JMP     LAB_1636        ; return to BASIC

                             LAB_FBA0
00:9E50  AE8104            :                 LDX     ccnull          ; get countdown byte
00:9E53  F003              :                 BEQ     LAB_FBA2        ; exit if finished

00:9E55  CE8104            :                 DEC     ccnull          ; else decrement countdown
                             LAB_FBA2
00:9E58  60                :                 RTS


Portable 65xx Assembler [20.01]

                             INGET
00:9E59  20F69F            :                 JSR     V_INPT          ; call scan input device
00:9E5C  B009              :                 BCS     LAB_FB95        ; if byte go reset timer

00:9E5E  AD8104            :                 LDA     ccnull          ; get countdown
00:9E61  F009              :                 BEQ     LAB_FB96        ; exit if empty

00:9E63  AD8004            :                 LDA     ccbyte          ; get last received byte
00:9E66  38                :                 SEC                     ; flag we got a byte
                             LAB_FB95
00:9E67  A200              :                 LDX     #$00            ; clear X
00:9E69  8E8104            :                 STX     ccnull          ; clear timer because we got a byte
                             LAB_FB96
00:9E6C  60                :                 RTS

                             ; MAX() MIN() pre process

                             LAB_MMPP
00:9E6D  20B48A            :                 JSR     LAB_EVEZ        ; process expression
00:9E70  4C9A8A            :                 JMP     LAB_CTNM        ; check if source is numeric, else do type mismatch

                             ; perform MAX()

                             LAB_MAX
00:9E73  20A19E            :                 JSR     LAB_PHFA        ; push FAC1, evaluate expression,
                             ; pull FAC2 and compare with FAC1
00:9E76  10FB              :                 BPL     LAB_MAX         ; branch if no swap to do

00:9E78  A566              :                 LDA     FAC2_1          ; get FAC2 mantissa1
00:9E7A  0980              :                 ORA     #$80            ; set top bit (clear sign from compare)
00:9E7C  8566              :                 STA     FAC2_1          ; save FAC2 mantissa1
00:9E7E  207095            :                 JSR     LAB_279B        ; copy FAC2 to FAC1
00:9E81  80F0              :                 BRA     LAB_MAX         ; go do next (branch always)

                             ; perform MIN()

                             LAB_MIN
00:9E83  20A19E            :                 JSR     LAB_PHFA        ; push FAC1, evaluate expression,
                             ; pull FAC2 and compare with FAC1
00:9E86  30FB              :                 BMI     LAB_MIN         ; branch if no swap to do

00:9E88  F0F9              :                 BEQ     LAB_MIN         ; branch if no swap to do

00:9E8A  A566              :                 LDA     FAC2_1          ; get FAC2 mantissa1
00:9E8C  0980              :                 ORA     #$80            ; set top bit (clear sign from compare)
00:9E8E  8566              :                 STA     FAC2_1          ; save FAC2 mantissa1
00:9E90  207095            :                 JSR     LAB_279B        ; copy FAC2 to FAC1
00:9E93  80EE              :                 BRA     LAB_MIN         ; go do next (branch always)

                             ; exit routine. don't bother returning to the loop code
                             ; check for correct exit, else so syntax error

                             LAB_MMEC
00:9E95  C929              :                 CMP     #')'            ; is it end of function?

Portable 65xx Assembler [20.01]

00:9E97  D005              :                 BNE     LAB_MMSE        ; if not do MAX MIN syntax error

00:9E99  68                :                 PLA                     ; dump return address low byte
00:9E9A  68                :                 PLA                     ; dump return address high byte
00:9E9B  4CD89F            :                 JMP     LAB_IGBY        ; update BASIC execute pointer (to chr past ")")

                             LAB_MMSE
00:9E9E  4CC88B            :                 JMP     LAB_SNER        ; do syntax error then warm start

                             ; check for next, evaluate and return or exit
                             ; this is the routine that does most of the work

                             LAB_PHFA
00:9EA1  20DE9F            :                 JSR     LAB_GBYT        ; get next BASIC byte
00:9EA4  C92C              :                 CMP     #','            ; is there more ?
00:9EA6  D0ED              :                 BNE     LAB_MMEC        ; if not go do end check

                             ; push FAC1
00:9EA8  207F98            :                 JSR     LAB_27BA        ; round FAC1
00:9EAB  A562              :                 LDA     FAC1_s          ; get FAC1 sign
00:9EAD  097F              :                 ORA     #$7F            ; set all non sign bits
00:9EAF  255F              :                 AND     FAC1_1          ; AND FAC1 mantissa1 (AND in sign bit)
00:9EB1  48                :                 PHA                     ; push on stack
00:9EB2  A560              :                 LDA     FAC1_2          ; get FAC1 mantissa2
00:9EB4  48                :                 PHA                     ; push on stack
00:9EB5  A561              :                 LDA     FAC1_3          ; get FAC1 mantissa3
00:9EB7  48                :                 PHA                     ; push on stack
00:9EB8  A55E              :                 LDA     FAC1_e          ; get FAC1 exponent
00:9EBA  48                :                 PHA                     ; push on stack

00:9EBB  20D89F            :                 JSR     LAB_IGBY        ; scan and get next BASIC byte (after ",")
00:9EBE  20978A            :                 JSR     LAB_EVNM        ; evaluate expression and check is numeric,
                             ; else do type mismatch

                             ; pop FAC2 (MAX/MIN expression so far)
00:9EC1  68                :                 PLA                     ; pop exponent
00:9EC2  8565              :                 STA     FAC2_e          ; save FAC2 exponent
00:9EC4  68                :                 PLA                     ; pop mantissa3
00:9EC5  8568              :                 STA     FAC2_3          ; save FAC2 mantissa3
00:9EC7  68                :                 PLA                     ; pop mantissa1
00:9EC8  8567              :                 STA     FAC2_2          ; save FAC2 mantissa2
00:9ECA  68                :                 PLA                     ; pop sign/mantissa1
00:9ECB  8566              :                 STA     FAC2_1          ; save FAC2 sign/mantissa1
00:9ECD  8569              :                 STA     FAC2_s          ; save FAC2 sign

                             ; compare FAC1 with (packed) FAC2
00:9ECF  A965              :                 LDA     #<FAC2_e        ; set pointer low byte to FAC2
00:9ED1  A000              :                 LDY     #>FAC2_e        ; set pointer high byte to FAC2
00:9ED3  4CB998            :                 JMP     LAB_27F8        ; compare FAC1 with FAC2 (AY) and return
                             ; returns A=$00 if FAC1 = (AY)
                             ; returns A=$01 if FAC1 > (AY)
                             ; returns A=$FF if FAC1 < (AY)

                             ; perform WIDTH

Portable 65xx Assembler [20.01]


                             LAB_WDTH
00:9ED6  C92C              :                 CMP     #','            ; is next byte ","
00:9ED8  F01B              :                 BEQ     LAB_TBSZ        ; if so do tab size

00:9EDA  203D94            :                 JSR     LAB_GTBY        ; get byte parameter
00:9EDD  8A                :                 TXA                     ; copy width to A
00:9EDE  F00A              :                 BEQ     LAB_NSTT        ; branch if set for infinite line

00:9EE0  E010              :                 CPX     #$10            ; else make min width = 16d
00:9EE2  9045              :                 BCC     TabErr          ; if less do function call error and exit

                             ; this next compare ensures that we can't exit WIDTH via an error leaving the
                             ; tab size greater than the line length.

00:9EE4  E416              :                 CPX     TabSiz          ; compare with tab size
00:9EE6  B002              :                 BCS     LAB_NSTT        ; branch if >= tab size

00:9EE8  8616              :                 STX     TabSiz          ; else make tab size = terminal width
                             LAB_NSTT
00:9EEA  8608              :                 STX     TWidth          ; set the terminal width
00:9EEC  20DE9F            :                 JSR     LAB_GBYT        ; get BASIC byte back
00:9EEF  F01A              :                 BEQ     WExit           ; exit if no following

00:9EF1  C92C              :                 CMP     #','            ; else is it ","
00:9EF3  D0A9              :                 BNE     LAB_MMSE        ; if not do syntax error

                             LAB_TBSZ
00:9EF5  203A94            :                 JSR     LAB_SGBY        ; scan and get byte parameter
00:9EF8  8A                :                 TXA                     ; copy TAB size
00:9EF9  302E              :                 BMI     TabErr          ; if >127 do function call error and exit

00:9EFB  E001              :                 CPX     #$01            ; compare with min-1
00:9EFD  902A              :                 BCC     TabErr          ; if <=1 do function call error and exit

00:9EFF  A508              :                 LDA     TWidth          ; set flags for width
00:9F01  F006              :                 BEQ     LAB_SVTB        ; skip check if infinite line

00:9F03  E408              :                 CPX     TWidth          ; compare TAB with width
00:9F05  F002              :                 BEQ     LAB_SVTB        ; ok if =

00:9F07  B020              :                 BCS     TabErr          ; branch if too big

                             LAB_SVTB
00:9F09  8616              :                 STX     TabSiz          ; save TAB size

                             ; calculate tab column limit from TAB size. The Iclim is set to the last tab
                             ; position on a line that still has at least one whole tab width between it
                             ; and the end of the line.

                             WExit
00:9F0B  A508              :                 LDA     TWidth          ; get width
00:9F0D  F006              :                 BEQ     LAB_SULP        ; branch if infinite line


Portable 65xx Assembler [20.01]

00:9F0F  C516              :                 CMP     TabSiz          ; compare with tab size
00:9F11  B003              :                 BCS     LAB_WDLP        ; branch if >= tab size

00:9F13  8516              :                 STA     TabSiz          ; else make tab size = terminal width
                             LAB_SULP
00:9F15  38                :                 SEC                     ; set carry for subtract
                             LAB_WDLP
00:9F16  E516              :                 SBC     TabSiz          ; subtract tab size
00:9F18  B0FC              :                 BCS     LAB_WDLP        ; loop while no borrow

00:9F1A  6516              :                 ADC     TabSiz          ; add tab size back
00:9F1C  18                :                 CLC                     ; clear carry for add
00:9F1D  6516              :                 ADC     TabSiz          ; add tab size back again
00:9F1F  8509              :                 STA     Iclim           ; save for now
00:9F21  A508              :                 LDA     TWidth          ; get width back
00:9F23  38                :                 SEC                     ; set carry for subtract
00:9F24  E509              :                 SBC     Iclim           ; subtract remainder
00:9F26  8509              :                 STA     Iclim           ; save tab column limit
                             LAB_NOSQ
00:9F28  60                :                 RTS

                             TabErr
00:9F29  4CE68E            :                 JMP     LAB_FCER        ; do function call error then warm start

                             ; perform SQR()

                             LAB_SQR
00:9F2C  A562              :                 LDA     FAC1_s          ; get FAC1 sign
00:9F2E  30F9              :                 BMI     TabErr          ; if -ve do function call error

00:9F30  A55E              :                 LDA     FAC1_e          ; get exponent
00:9F32  F0F4              :                 BEQ     LAB_NOSQ        ; if zero just return

                             ; else do root
00:9F34  207098            :                 JSR     LAB_27AB        ; round and copy FAC1 to FAC2

00:9F37  6429              :                 STZ     FACt_3          ; clear remainder
00:9F39  6428              :                 STZ     FACt_2          ; ..
00:9F3B  6427              :                 STZ     FACt_1          ; ..
00:9F3D  642A              :                 STZ     TempB           ; ..

00:9F3F  6461              :                 STZ     FAC1_3          ; clear root
00:9F41  6460              :                 STZ     FAC1_2          ; ..
00:9F43  645F              :                 STZ     FAC1_1          ; ..

00:9F45  A218              :                 LDX     #$18            ; 24 pairs of bits to do
00:9F47  A565              :                 LDA     FAC2_e          ; get exponent
00:9F49  4A                :                 LSR                     ; check odd/even
00:9F4A  B00E              :                 BCS     LAB_SQE2        ; if odd only 1 shift first time

                             LAB_SQE1
00:9F4C  0668              :                 ASL     FAC2_3          ; shift highest bit of number ..
00:9F4E  2667              :                 ROL     FAC2_2          ; ..
00:9F50  2666              :                 ROL     FAC2_1          ; ..

Portable 65xx Assembler [20.01]

00:9F52  2629              :                 ROL     FACt_3          ; .. into remainder
00:9F54  2628              :                 ROL     FACt_2          ; ..
00:9F56  2627              :                 ROL     FACt_1          ; ..
00:9F58  262A              :                 ROL     TempB           ; .. never overflows
                             LAB_SQE2
00:9F5A  0668              :                 ASL     FAC2_3          ; shift highest bit of number ..
00:9F5C  2667              :                 ROL     FAC2_2          ; ..
00:9F5E  2666              :                 ROL     FAC2_1          ; ..
00:9F60  2629              :                 ROL     FACt_3          ; .. into remainder
00:9F62  2628              :                 ROL     FACt_2          ; ..
00:9F64  2627              :                 ROL     FACt_1          ; ..
00:9F66  262A              :                 ROL     TempB           ; .. never overflows

00:9F68  0661              :                 ASL     FAC1_3          ; root = root * 2
00:9F6A  2660              :                 ROL     FAC1_2          ; ..
00:9F6C  265F              :                 ROL     FAC1_1          ; .. never overflows

00:9F6E  A561              :                 LDA     FAC1_3          ; get root low byte
00:9F70  2A                :                 ROL                     ; *2
00:9F71  850D              :                 STA     Temp3           ; save partial low byte
00:9F73  A560              :                 LDA     FAC1_2          ; get root low mid byte
00:9F75  2A                :                 ROL                     ; *2
00:9F76  850E              :                 STA     Temp3+1         ; save partial low mid byte
00:9F78  A55F              :                 LDA     FAC1_1          ; get root high mid byte
00:9F7A  2A                :                 ROL                     ; *2
00:9F7B  850F              :                 STA     Temp3+2         ; save partial high mid byte
00:9F7D  A900              :                 LDA     #$00            ; get root high byte (always $00)
00:9F7F  2A                :                 ROL                     ; *2
00:9F80  8510              :                 STA     Temp3+3         ; save partial high byte

                             ; carry clear for subtract +1
00:9F82  A529              :                 LDA     FACt_3          ; get remainder low byte
00:9F84  E50D              :                 SBC     Temp3           ; subtract partial low byte
00:9F86  850D              :                 STA     Temp3           ; save partial low byte

00:9F88  A528              :                 LDA     FACt_2          ; get remainder low mid byte
00:9F8A  E50E              :                 SBC     Temp3+1         ; subtract partial low mid byte
00:9F8C  850E              :                 STA     Temp3+1         ; save partial low mid byte

00:9F8E  A527              :                 LDA     FACt_1          ; get remainder high mid byte
00:9F90  E50F              :                 SBC     Temp3+2         ; subtract partial high mid byte
00:9F92  A8                :                 TAY                     ; copy partial high mid byte

00:9F93  A52A              :                 LDA     TempB           ; get remainder high byte
00:9F95  E510              :                 SBC     Temp3+3         ; subtract partial high byte
00:9F97  900E              :                 BCC     LAB_SQNS        ; skip sub if remainder smaller

00:9F99  852A              :                 STA     TempB           ; save remainder high byte

00:9F9B  8427              :                 STY     FACt_1          ; save remainder high mid byte

00:9F9D  A50E              :                 LDA     Temp3+1         ; get remainder low mid byte
00:9F9F  8528              :                 STA     FACt_2          ; save remainder low mid byte


Portable 65xx Assembler [20.01]

00:9FA1  A50D              :                 LDA     Temp3           ; get partial low byte
00:9FA3  8529              :                 STA     FACt_3          ; save remainder low byte

00:9FA5  E661              :                 INC     FAC1_3          ; increment root low byte (never any rollover)
                             LAB_SQNS
00:9FA7  CA                :                 DEX                     ; decrement bit pair count
00:9FA8  D0A2              :                 BNE     LAB_SQE1        ; loop if not all done

00:9FAA  38                :                 SEC                     ; set carry for subtract
00:9FAB  A565              :                 LDA     FAC2_e          ; get exponent
00:9FAD  E980              :                 SBC     #$80            ; normalise
00:9FAF  6A                :                 ROR                     ; /2 and re-bias to $80
00:9FB0  6900              :                 ADC     #$00            ; add bit zero back in (allow for half shift)
00:9FB2  855E              :                 STA     FAC1_e          ; save it
00:9FB4  4CDD95            :                 JMP     LAB_24D5        ; normalise FAC1 and return

                             ; perform VARPTR()

                             LAB_VARPTR
00:9FB7  20D89F            :                 JSR     LAB_IGBY        ; increment and scan memory
00:9FBA  206A8D            :                 JSR     LAB_GVAR        ; get var address
00:9FBD  20B78B            :                 JSR     LAB_1BFB        ; scan for ")" , else do syntax error then warm start
00:9FC0  A447              :                 LDY     Cvaral          ; get var address low byte
00:9FC2  A548              :                 LDA     Cvarah          ; get var address high byte
00:9FC4  4C1690            :                 JMP     LAB_AYFC        ; save and convert integer AY to FAC1 and return

                             ; perform PI

                             LAB_PI
00:9FC7  A98C              :                 LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
00:9FC9  A0A0              :                 LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
00:9FCB  202398            :                 JSR     LAB_UFAC        ; unpack memory (AY) into FAC1
00:9FCE  C65E              :                 DEC     FAC1_e          ; make result = PI
00:9FD0  60                :                 RTS

                             ; perform TWOPI

                             LAB_TWOPI
00:9FD1  A98C              :                 LDA     #<LAB_2C7C      ; set (2*pi) pointer low byte
00:9FD3  A0A0              :                 LDY     #>LAB_2C7C      ; set (2*pi) pointer high byte
00:9FD5  4C2398            :                 JMP     LAB_UFAC        ; unpack memory (AY) into FAC1 and return

                             ; character get subroutine - ROM based

                             ; the target address for the LDA at LAB_GBYT is the BASIC execute pointer.
                             ; block is no longer copied to page zero and uses a CMOS instruction/address mode.
                             ; 16-bit pointer is located in page zero.

                             ; increment and scan memory
                             LAB_IGBY
00:9FD8  E66E              :                 INC     Bpntrl          ; increment BASIC execute pointer low byte
00:9FDA  D002              :                 BNE     LAB_GBYT        ; branch if no carry, else
00:9FDC  E66F              :                 INC     Bpntrh          ; increment BASIC execute pointer high byte


Portable 65xx Assembler [20.01]

                             ; scan memory

                             LAB_GBYT
00:9FDE  B26E              :                 LDA     (Bpntrl)        ; get byte to scan (addr set by call routine)
00:9FE0  C9A9              :                 CMP     #TK_ELSE        ; compare with the token for ELSE
00:9FE2  F00E              :                 BEQ     LAB_2D05        ; exit if ELSE, not numeric, carry set

00:9FE4  C93A              :                 CMP     #':'            ; compare with ":"
00:9FE6  B00A              :                 BCS     LAB_2D05        ; exit if >= ":", not numeric, carry set

00:9FE8  C920              :                 CMP     #' '            ; compare with " "
00:9FEA  F0EC              :                 BEQ     LAB_IGBY        ; if " " go do next

00:9FEC  38                :                 SEC                     ; set carry for SBC
00:9FED  E930              :                 SBC     #'0'            ; subtract "0"
00:9FEF  38                :                 SEC                     ; set carry for SBC
00:9FF0  E9D0              :                 SBC     #$D0            ; subtract -"0"
                             ; clear carry if byte = "0"-"9"
                             LAB_2D05
00:9FF2  60                :                 RTS

                             LAB_EXIT
00:9FF3  4C02A0            :                 JMP     V_EXIT          ; exit back to C02 Monitor Warm start soft vector

                             ; system dependant i/o vectors
                             ; these are in RAM and are set by the monitor at start-up

                             V_INPT
00:9FF6  6C8404            :                 JMP     (VEC_IN)        ; non halting scan input device
                             V_OUTP
00:9FF9  6C8604            :                 JMP     (VEC_OUT)       ; send byte to output device
                             V_LOAD
00:9FFC  6C8804            :                 JMP     (VEC_LD)        ; load BASIC program
                             V_SAVE
00:9FFF  6C8A04            :                 JMP     (VEC_SV)        ; save BASIC program
                             V_EXIT
00:A002  6C8C04            :                 JMP     (VEC_EXIT)      ; warm start C02 Monitor

                             ; The rest are tables messages and code for RAM

                             ; the rest of the code is tables and BASIC start-up code
                             ; monitor routines required are added below for initialization

                             PG2_TABS
00:A005  00                :                 .byte   $00             ; ctrl-c flag         -     $00 = enabled
00:A006  00                :                 .byte   $00             ; ctrl-c byte         -     GET needs this
00:A007  00                :                 .byte   $00             ; ctrl-c byte timeout   -           GET needs this
00:A008  3B9E              :                 .word   CTRLC           ; ctrl c check vector
                             ;
00:A00A  0B80              :                 .word   RDBYTE          ; byte in from C02BIOS (no waiting)
00:A00C  1880              :                 .word   WRBYTE          ; byte out from C02BIOS
00:A00E  2580              :                 .word   SYSLOAD         ; null load JMP for EhBASIC
00:A010  2680              :                 .word   SYSSAVE         ; null save JMP for EhBASIC
00:A012  2780              :                 .word   SYSEXIT         ; Warm start JMP for C02 Monitor

Portable 65xx Assembler [20.01]


                             PG2_TABE

                             ; page zero initialisation table $00-$12 inclusive

                             StrTab
00:A014  4C                :                 .byte   $4C             ; JMP opcode
00:A015  2B80              :                 .word   LAB_COLD        ; initial warm start vector (cold start)

00:A017  4C                :                 .byte   $4C             ; JMP opcode
00:A018  E68E              :                 .word   LAB_FCER        ; initial user function vector ("Function call" error)

00:A01A  00                :                 .byte   $00             ; default NULL count
00:A01B  00                :                 .byte   $00             ; clear terminal position
00:A01C  50                :                 .byte   $50             ; default terminal width byte = 80
00:A01D  F2                :                 .byte   $F2             ; default limit for TAB = 14
00:A01E  0008              :                 .word   Ram_base        ; start of user RAM
                             EndTab

                             LAB_SMSG
00:A020  2042797465732066> :                 .byte   " Bytes free",$0D,$00

                             ; numeric constants and series
                             ; cleaned up to removed commented lines which were replaced

                             ; constants and series for LOG(n)
                             LAB_25A0
00:A02D  02                :                 .byte   $02             ; counter
00:A02E  80195662          :                 .byte   $80,$19,$56,$62 ; 0.59898
00:A032  807622F3          :                 .byte   $80,$76,$22,$F3 ; 0.96147
00:A036  8238AA40          :                 .byte   $82,$38,$AA,$40 ; 2.88539

                             LAB_25AD
00:A03A  803504F3          :                 .byte   $80,$35,$04,$F3 ; 0.70711         1/root 2
                             LAB_25B1
00:A03E  813504F3          :                 .byte   $81,$35,$04,$F3 ; 1.41421         root 2
                             LAB_25B5
00:A042  80800000          :                 .byte   $80,$80,$00,$00 ; -0.5
                             LAB_25B9
00:A046  80317218          :                 .byte   $80,$31,$72,$18 ; 0.69315         LOG(2)

                             ; numeric PRINT constants
                             LAB_2947
00:A04A  91434FF8          :                 .byte   $91,$43,$4F,$F8 ; 99999.9375 (max value with at least one decimal)
                             LAB_294B
00:A04E  947423F7          :                 .byte   $94,$74,$23,$F7 ; 999999.4375 (max value before scientific notation)
                             LAB_294F
00:A052  94742400          :                 .byte   $94,$74,$24,$00 ; 1000000

                             ; EXP(n) constants and series
                             LAB_2AFA
00:A056  8138AA3B          :                 .byte   $81,$38,$AA,$3B ; 1.4427          (1/LOG base 2 e)
                             LAB_2AFE
00:A05A  06                :                 .byte   $06             ; counter

Portable 65xx Assembler [20.01]

00:A05B  7463908C          :                 .byte   $74,$63,$90,$8C ; 2.17023e-4
00:A05F  77230CAB          :                 .byte   $77,$23,$0C,$AB ; 0.00124
00:A063  7A1E9400          :                 .byte   $7A,$1E,$94,$00 ; 0.00968
00:A067  7C634280          :                 .byte   $7C,$63,$42,$80 ; 0.05548
00:A06B  7E75FED0          :                 .byte   $7E,$75,$FE,$D0 ; 0.24023
00:A06F  80317215          :                 .byte   $80,$31,$72,$15 ; 0.69315
00:A073  81000000          :                 .byte   $81,$00,$00,$00 ; 1.00000

                             ; trigonometric constants and series
                             LAB_2C78
00:A077  81490FDB          :                 .byte   $81,$49,$0F,$DB ; 1.570796371 (pi/2) as floating #
                             LAB_2C84
00:A07B  04                :                 .byte   $04             ; counter
00:A07C  861ED7FB          :                 .byte   $86,$1E,$D7,$FB ; 39.7109
00:A080  87992665          :                 .byte   $87,$99,$26,$65 ;-76.575
00:A084  87233458          :                 .byte   $87,$23,$34,$58 ; 81.6022
00:A088  86A55DE1          :                 .byte   $86,$A5,$5D,$E1 ;-41.3417
                             LAB_2C7C
00:A08C  83490FDB          :                 .byte   $83,$49,$0F,$DB ; 6.28319 (2*pi) as floating #

                             LAB_2CC9
00:A090  08                :                 .byte   $08             ; counter
00:A091  783AC537          :                 .byte   $78,$3A,$C5,$37 ; 0.00285
00:A095  7B83A25C          :                 .byte   $7B,$83,$A2,$5C ;-0.0160686
00:A099  7C2EDD4D          :                 .byte   $7C,$2E,$DD,$4D ; 0.0426915
00:A09D  7D99B01E          :                 .byte   $7D,$99,$B0,$1E ;-0.0750429
00:A0A1  7D59ED24          :                 .byte   $7D,$59,$ED,$24 ; 0.106409
00:A0A5  7E917200          :                 .byte   $7E,$91,$72,$00 ;-0.142036
00:A0A9  7E4CB973          :                 .byte   $7E,$4C,$B9,$73 ; 0.199926
00:A0AD  7FAAAA53          :                 .byte   $7F,$AA,$AA,$53 ;-0.333331

         0000A0B2          = LAB_1D96        .EQU    *+1             ; $00,$00 used for undefined variables
                             LAB_259C
00:A0B1  81000000          :                 .byte   $81,$00,$00,$00 ; 1.000000, used for INC
                             LAB_2AFD
00:A0B5  81800000          :                 .byte   $81,$80,$00,$00 ; -1.00000, used for DEC. must be on the same page as +1.00

                             ; misc constants
                             LAB_1DF7
00:A0B9  90                :                 .byte   $90             ;-32768 (uses first three bytes from 0.5)
                             LAB_2A96
00:A0BA  80000000          :                 .byte   $80,$00,$00,$00 ; 0.5
                             LAB_2C80
00:A0BE  7F000000          :                 .byte   $7F,$00,$00,$00 ; 0.25
                             LAB_26B5
00:A0C2  84200000          :                 .byte   $84,$20,$00,$00 ; 10.0000 divide by 10 constant

                             ; This table is used in converting numbers to ASCII.

                             LAB_2A9A
         0000A0C7          = LAB_2A9B        .EQU    LAB_2A9A+1
         0000A0C8          = LAB_2A9C        .EQU    LAB_2A9B+1
00:A0C6  FE7960            :                 .byte   $FE,$79,$60     ; -100000
00:A0C9  002710            :                 .byte   $00,$27,$10     ; 10000

Portable 65xx Assembler [20.01]

00:A0CC  FFFC18            :                 .byte   $FF,$FC,$18     ; -1000
00:A0CF  000064            :                 .byte   $00,$00,$64     ; 100
00:A0D2  FFFFF6            :                 .byte   $FF,$FF,$F6     ; -10
00:A0D5  000001            :                 .byte   $00,$00,$01     ; 1

                             LAB_CTBL
00:A0D8  0A85              :                 .word   LAB_END-1       ; END
00:A0DA  4C84              :                 .word   LAB_FOR-1       ; FOR
00:A0DC  2E8A              :                 .word   LAB_NEXT-1      ; NEXT
00:A0DE  6D86              :                 .word   LAB_DATA-1      ; DATA
00:A0E0  1489              :                 .word   LAB_INPUT-1     ; INPUT
00:A0E2  1E8D              :                 .word   LAB_DIM-1       ; DIM
00:A0E4  3389              :                 .word   LAB_READ-1      ; READ
00:A0E6  8887              :                 .word   LAB_LET-1       ; LET
00:A0E8  5A87              :                 .word   LAB_DEC-1       ; DEC           new command
00:A0EA  CC85              :                 .word   LAB_GOTO-1      ; GOTO
00:A0EC  8B85              :                 .word   LAB_RUN-1       ; RUN
00:A0EE  9C86              :                 .word   LAB_IF-1        ; IF
00:A0F0  2B85              :                 .word   LAB_RESTORE-1   ; RESTORE       modified command
00:A0F2  AF85              :                 .word   LAB_GOSUB-1     ; GOSUB
00:A0F4  5886              :                 .word   LAB_RETURN-1    ; RETURN
00:A0F6  0187              :                 .word   LAB_REM-1       ; REM
00:A0F8  0885              :                 .word   LAB_STOP-1      ; STOP
00:A0FA  0A87              :                 .word   LAB_ON-1        ; ON            modified command
00:A0FC  6985              :                 .word   LAB_NULL-1      ; NULL          modified command
00:A0FE  5E87              :                 .word   LAB_INC-1       ; INC           new command
00:A100  3695              :                 .word   LAB_WAIT-1      ; WAIT
00:A102  FB9F              :                 .word   V_LOAD-1        ; LOAD
00:A104  FE9F              :                 .word   V_SAVE-1        ; SAVE
00:A106  3090              :                 .word   LAB_DEF-1       ; DEF
00:A108  BB94              :                 .word   LAB_POKE-1      ; POKE
00:A10A  D794              :                 .word   LAB_DOKE-1      ; DOKE          new command
00:A10C  2495              :                 .word   LAB_CALL-1      ; CALL          new command
00:A10E  9585              :                 .word   LAB_DO-1        ; DO            new command
00:A110  FE85              :                 .word   LAB_LOOP-1      ; LOOP          new command
00:A112  2588              :                 .word   LAB_PRINT-1     ; PRINT
00:A114  6F85              :                 .word   LAB_CONT-1      ; CONT
00:A116  9783              :                 .word   LAB_LIST-1      ; LIST
00:A118  9483              :                 .word   LAB_CLEAR-1     ; CLEAR
00:A11A  4583              :                 .word   LAB_NEW-1       ; NEW
00:A11C  D59E              :                 .word   LAB_WDTH-1      ; WIDTH         new command
00:A11E  F587              :                 .word   LAB_GET-1       ; GET           new command
00:A120  FC94              :                 .word   LAB_SWAP-1      ; SWAP          new command
00:A122  129D              :                 .word   LAB_BITSET-1    ; BITSET        new command
00:A124  269D              :                 .word   LAB_BITCLR-1    ; BITCLR        new command
00:A126  F29F              :                 .word   LAB_EXIT-1      ; EXIT          new command (exits to C02 Monitor)

                             ; function pre process routine table

                             LAB_FTPL
         0000A129          = LAB_FTPM        .EQU    LAB_FTPL+$01
00:A128  298C              :                 .word   LAB_PPFN-1      ; SGN(n)          process numeric expression in ()
00:A12A  298C              :                 .word   LAB_PPFN-1      ; INT(n)                "
00:A12C  298C              :                 .word   LAB_PPFN-1      ; ABS(n)                "

Portable 65xx Assembler [20.01]

00:A12E  B38A              :                 .word   LAB_EVEZ-1      ; USR(x)          process any expression
00:A130  B38B              :                 .word   LAB_1BF7-1      ; FRE(x)                "
00:A132  B38B              :                 .word   LAB_1BF7-1      ; POS(x)                "
00:A134  298C              :                 .word   LAB_PPFN-1      ; SQR(n)          process numeric expression in ()
00:A136  298C              :                 .word   LAB_PPFN-1      ; RND(n)                "
00:A138  298C              :                 .word   LAB_PPFN-1      ; LOG(n)                "
00:A13A  298C              :                 .word   LAB_PPFN-1      ; EXP(n)                "
00:A13C  298C              :                 .word   LAB_PPFN-1      ; COS(n)                "
00:A13E  298C              :                 .word   LAB_PPFN-1      ; SIN(n)                "
00:A140  298C              :                 .word   LAB_PPFN-1      ; TAN(n)                "
00:A142  298C              :                 .word   LAB_PPFN-1      ; ATN(n)                "
00:A144  298C              :                 .word   LAB_PPFN-1      ; PEEK(n)               "
00:A146  298C              :                 .word   LAB_PPFN-1      ; DEEK(n)               "
00:A148  0000              :                 .word   $0000           ; SADD()          none
00:A14A  238C              :                 .word   LAB_PPFS-1      ; LEN($)          process string expression in ()
00:A14C  298C              :                 .word   LAB_PPFN-1      ; STR$(n)         process numeric expression in ()
00:A14E  238C              :                 .word   LAB_PPFS-1      ; VAL($)          process string expression in ()
00:A150  238C              :                 .word   LAB_PPFS-1      ; ASC($)                "
00:A152  238C              :                 .word   LAB_PPFS-1      ; UCASE$($)     "
00:A154  238C              :                 .word   LAB_PPFS-1      ; LCASE$($)     "
00:A156  298C              :                 .word   LAB_PPFN-1      ; CHR$(n)         process numeric expression in ()
00:A158  4C8C              :                 .word   LAB_BHSS-1      ; HEX$(n)               "
00:A15A  4C8C              :                 .word   LAB_BHSS-1      ; BIN$(n)               "
00:A15C  0000              :                 .word   $0000           ; BITTST()  none
00:A15E  6C9E              :                 .word   LAB_MMPP-1      ; MAX()   process numeric expression
00:A160  6C9E              :                 .word   LAB_MMPP-1      ; MIN()         "
00:A162  2F8C              :                 .word   LAB_PPBI-1      ; PI      advance pointer
00:A164  2F8C              :                 .word   LAB_PPBI-1      ; TWOPI         "
00:A166  0000              :                 .word   $0000           ; VARPTR()  none
00:A168  348C              :                 .word   LAB_LRMS-1      ; LEFT$()         process string expression
00:A16A  348C              :                 .word   LAB_LRMS-1      ; RIGHT$()      "
00:A16C  348C              :                 .word   LAB_LRMS-1      ; MID$()                "

                             ; action addresses for functions

                             LAB_FTBL
         0000A16F          = LAB_FTBM        .EQU    LAB_FTBL+$01
00:A16E  9C98              :                 .word   LAB_SGN-1       ; SGN()
00:A170  2199              :                 .word   LAB_INT-1       ; INT()
00:A172  B598              :                 .word   LAB_ABS-1       ; ABS()
00:A174  DD9C              :                 .word   LAB_USR-1       ; USR()
00:A176  0190              :                 .word   LAB_FRE-1       ; FRE()
00:A178  2090              :                 .word   LAB_POS-1       ; POS()
00:A17A  2B9F              :                 .word   LAB_SQR-1       ; SQR()
00:A17C  349C              :                 .word   LAB_RND-1       ; RND()         modified function
00:A17E  A396              :                 .word   LAB_LOG-1       ; LOG()
00:A180  989B              :                 .word   LAB_EXP-1       ; EXP()
00:A182  689C              :                 .word   LAB_COS-1       ; COS()
00:A184  6F9C              :                 .word   LAB_SIN-1       ; SIN()
00:A186  B69C              :                 .word   LAB_TAN-1       ; TAN()
00:A188  E39C              :                 .word   LAB_ATN-1       ; ATN()
00:A18A  B094              :                 .word   LAB_PEEK-1      ; PEEK()
00:A18C  C494              :                 .word   LAB_DEEK-1      ; DEEK()                new function
00:A18E  0794              :                 .word   LAB_SADD-1      ; SADD()                new function

Portable 65xx Assembler [20.01]

00:A190  2094              :                 .word   LAB_LENS-1      ; LEN()
00:A192  E090              :                 .word   LAB_STRS-1      ; STR$()
00:A194  4B94              :                 .word   LAB_VAL-1       ; VAL()
00:A196  2B94              :                 .word   LAB_ASC-1       ; ASC()
00:A198  E593              :                 .word   LAB_UCASE-1     ; UCASE$()      new function
00:A19A  C493              :                 .word   LAB_LCASE-1     ; LCASE$()      new function
00:A19C  3B93              :                 .word   LAB_CHRS-1      ; CHR$()
00:A19E  B39D              :                 .word   LAB_HEXS-1      ; HEX$()                new function
00:A1A0  649D              :                 .word   LAB_BINS-1      ; BIN$()                new function
00:A1A2  3C9D              :                 .word   LAB_BTST-1      ; BITTST()      new function
00:A1A4  729E              :                 .word   LAB_MAX-1       ; MAX()         new function
00:A1A6  829E              :                 .word   LAB_MIN-1       ; MIN()         new function
00:A1A8  C69F              :                 .word   LAB_PI-1        ; PI            new function
00:A1AA  D09F              :                 .word   LAB_TWOPI-1     ; TWOPI         new function
00:A1AC  B69F              :                 .word   LAB_VARPTR-1    ; VARPTR()      new function
00:A1AE  4A93              :                 .word   LAB_LEFT-1      ; LEFT$()
00:A1B0  5393              :                 .word   LAB_RIGHT-1     ; RIGHT$()
00:A1B2  8193              :                 .word   LAB_MIDS-1      ; MID$()

                             ; hierarchy and action addresses for operator

                             LAB_OPPT
00:A1B4  79                :                 .byte   $79             ; +
00:A1B5  6D95              :                 .word   LAB_ADD-1
00:A1B7  79                :                 .byte   $79             ; -
00:A1B8  5395              :                 .word   LAB_SUBTRACT-1
00:A1BA  7B                :                 .byte   $7B             ; *
00:A1BB  E496              :                 .word   LAB_MULTIPLY-1
00:A1BD  7B                :                 .byte   $7B             ; /
00:A1BE  AA97              :                 .word   LAB_DIVIDE-1
00:A1C0  7F                :                 .byte   $7F             ; ^
00:A1C1  549B              :                 .word   LAB_POWER-1
00:A1C3  50                :                 .byte   $50             ; AND
00:A1C4  958C              :                 .word   LAB_AND-1
00:A1C6  46                :                 .byte   $46             ; EOR           new operator
00:A1C7  7B8C              :                 .word   LAB_EOR-1
00:A1C9  46                :                 .byte   $46             ; OR
00:A1CA  888C              :                 .word   LAB_OR-1
00:A1CC  56                :                 .byte   $56             ; >>            new operator
00:A1CD  408D              :                 .word   LAB_RSHIFT-1
00:A1CF  56                :                 .byte   $56             ; <<            new operator
00:A1D0  288D              :                 .word   LAB_LSHIFT-1
00:A1D2  7D                :                 .byte   $7D             ; >
00:A1D3  8D9B              :                 .word   LAB_GTHAN-1
00:A1D5  5A                :                 .byte   $5A             ; =
00:A1D6  DC8B              :                 .word   LAB_EQUAL-1
00:A1D8  64                :                 .byte   $64             ; <
00:A1D9  B68C              :                 .word   LAB_LTHAN-1

                             ; keywords start with ..
                             ; this is the first character table and must be in alphabetic order

                             TAB_1STC
00:A1DB  2A                :                 .byte   "*"

Portable 65xx Assembler [20.01]

00:A1DC  2B                :                 .byte   "+"
00:A1DD  2D                :                 .byte   "-"
00:A1DE  2F                :                 .byte   "/"
00:A1DF  3C                :                 .byte   "<"
00:A1E0  3D                :                 .byte   "="
00:A1E1  3E                :                 .byte   ">"
00:A1E2  3F                :                 .byte   "?"
00:A1E3  41                :                 .byte   "A"
00:A1E4  42                :                 .byte   "B"
00:A1E5  43                :                 .byte   "C"
00:A1E6  44                :                 .byte   "D"
00:A1E7  45                :                 .byte   "E"
00:A1E8  46                :                 .byte   "F"
00:A1E9  47                :                 .byte   "G"
00:A1EA  48                :                 .byte   "H"
00:A1EB  49                :                 .byte   "I"
00:A1EC  4C                :                 .byte   "L"
00:A1ED  4D                :                 .byte   "M"
00:A1EE  4E                :                 .byte   "N"
00:A1EF  4F                :                 .byte   "O"
00:A1F0  50                :                 .byte   "P"
00:A1F1  52                :                 .byte   "R"
00:A1F2  53                :                 .byte   "S"
00:A1F3  54                :                 .byte   "T"
00:A1F4  55                :                 .byte   "U"
00:A1F5  56                :                 .byte   "V"
00:A1F6  57                :                 .byte   "W"
00:A1F7  5E                :                 .byte   "^"
00:A1F8  00                :                 .byte   $00             ; table terminator

                             ; pointers to keyword tables

                             TAB_CHRT
00:A1F9  33A2              :                 .word   TAB_STAR        ; table for "*"
00:A1FB  35A2              :                 .word   TAB_PLUS        ; table for "+"
00:A1FD  37A2              :                 .word   TAB_MNUS        ; table for "-"
00:A1FF  39A2              :                 .word   TAB_SLAS        ; table for "/"
00:A201  3BA2              :                 .word   TAB_LESS        ; table for "<"
00:A203  3FA2              :                 .word   TAB_EQUL        ; table for "="
00:A205  41A2              :                 .word   TAB_MORE        ; table for ">"
00:A207  45A2              :                 .word   TAB_QEST        ; table for "?"
00:A209  47A2              :                 .word   TAB_ASCA        ; table for "A"
00:A20B  57A2              :                 .word   TAB_ASCB        ; table for "B"
00:A20D  70A2              :                 .word   TAB_ASCC        ; table for "C"
00:A20F  87A2              :                 .word   TAB_ASCD        ; table for "D"
00:A211  A0A2              :                 .word   TAB_ASCE        ; table for "E"
00:A213  B3A2              :                 .word   TAB_ASCF        ; table for "F"
00:A215  BDA2              :                 .word   TAB_ASCG        ; table for "G"
00:A217  CAA2              :                 .word   TAB_ASCH        ; table for "H"
00:A219  D0A2              :                 .word   TAB_ASCI        ; table for "I"
00:A21B  DFA2              :                 .word   TAB_ASCL        ; table for "L"
00:A21D  04A3              :                 .word   TAB_ASCM        ; table for "M"
00:A21F  12A3              :                 .word   TAB_ASCN        ; table for "N"
00:A221  21A3              :                 .word   TAB_ASCO        ; table for "O"

Portable 65xx Assembler [20.01]

00:A223  26A3              :                 .word   TAB_ASCP        ; table for "P"
00:A225  3BA3              :                 .word   TAB_ASCR        ; table for "R"
00:A227  5EA3              :                 .word   TAB_ASCS        ; table for "S"
00:A229  89A3              :                 .word   TAB_ASCT        ; table for "T"
00:A22B  9DA3              :                 .word   TAB_ASCU        ; table for "U"
00:A22D  AEA3              :                 .word   TAB_ASCV        ; table for "V"
00:A22F  BAA3              :                 .word   TAB_ASCW        ; table for "W"
00:A231  C9A3              :                 .word   TAB_POWR        ; table for "^"

                             ; tables for each start character, note if a longer keyword with the same start
                             ; letters as a shorter one exists then it must come first, else the list is in
                             ; alphabetical order as follows ..

                             ; [keyword,token
                             ; [keyword,token]]
                             ; end marker (#$00)

                             TAB_STAR
00:A233  B400              :                 .byte   TK_MUL,$00      ; *
                             TAB_PLUS
00:A235  B200              :                 .byte   TK_PLUS,$00     ; +
                             TAB_MNUS
00:A237  B300              :                 .byte   TK_MINUS,$00    ; -
                             TAB_SLAS
00:A239  B500              :                 .byte   TK_DIV,$00      ; /
                             TAB_LESS
                             LBB_LSHIFT
00:A23B  3CBB              :                 .byte   "<",TK_LSHIFT   ; <<  note - "<<" must come before "<"
00:A23D  BE                :                 .byte   TK_LT           ; <
00:A23E  00                :                 .byte   $00
                             TAB_EQUL
00:A23F  BD00              :                 .byte   TK_EQUAL,$00    ; =
                             TAB_MORE
                             LBB_RSHIFT
00:A241  3EBA              :                 .byte   ">",TK_RSHIFT   ; >>  note - ">>" must come before ">"
00:A243  BC                :                 .byte   TK_GT           ; >
00:A244  00                :                 .byte   $00
                             TAB_QEST
00:A245  9D00              :                 .byte   TK_PRINT,$00    ; ?
                             TAB_ASCA
                             LBB_ABS
00:A247  425328C1          :                 .byte   "BS(",TK_ABS    ; ABS(
                             LBB_AND
00:A24B  4E44B7            :                 .byte   "ND",TK_AND     ; AND
                             LBB_ASC
00:A24E  534328D3          :                 .byte   "SC(",TK_ASC    ; ASC(
                             LBB_ATN
00:A252  544E28CC          :                 .byte   "TN(",TK_ATN    ; ATN(
00:A256  00                :                 .byte   $00
                             TAB_ASCB
                             LBB_BINS
00:A257  494E2428D8        :                 .byte   "IN$(",TK_BINS  ; BIN$(
                             LBB_BITCLR
00:A25C  4954434C52A6      :                 .byte   "ITCLR",TK_BITCLR ; BITCLR

Portable 65xx Assembler [20.01]

                             LBB_BITSET
00:A262  4954534554A5      :                 .byte   "ITSET",TK_BITSET ; BITSET
                             LBB_BITTST
00:A268  495454535428D9    :                 .byte   "ITTST(",TK_BITTST
                             ; BITTST(
00:A26F  00                :                 .byte   $00
                             TAB_ASCC
                             LBB_CALL
00:A270  414C4C9A          :                 .byte   "ALL",TK_CALL   ; CALL
                             LBB_CHRS
00:A274  48522428D6        :                 .byte   "HR$(",TK_CHRS  ; CHR$(
                             LBB_CLEAR
00:A279  4C454152A0        :                 .byte   "LEAR",TK_CLEAR ; CLEAR
                             LBB_CONT
00:A27E  4F4E549E          :                 .byte   "ONT",TK_CONT   ; CONT
                             LBB_COS
00:A282  4F5328C9          :                 .byte   "OS(",TK_COS    ; COS(
00:A286  00                :                 .byte   $00
                             TAB_ASCD
                             LBB_DATA
00:A287  41544183          :                 .byte   "ATA",TK_DATA   ; DATA
                             LBB_DEC
00:A28B  454388            :                 .byte   "EC",TK_DEC     ; DEC
                             LBB_DEEK
00:A28E  45454B28CE        :                 .byte   "EEK(",TK_DEEK  ; DEEK(
                             LBB_DEF
00:A293  454697            :                 .byte   "EF",TK_DEF     ; DEF
                             LBB_DIM
00:A296  494D85            :                 .byte   "IM",TK_DIM     ; DIM
                             LBB_DOKE
00:A299  4F4B4599          :                 .byte   "OKE",TK_DOKE   ; DOKE note - "DOKE" must come before "DO"
                             LBB_DO
00:A29D  4F9B              :                 .byte   "O",TK_DO       ; DO
00:A29F  00                :                 .byte   $00
                             TAB_ASCE
                             LBB_ELSE
00:A2A0  4C5345A9          :                 .byte   "LSE",TK_ELSE   ; ELSE
                             LBB_END
00:A2A4  4E4480            :                 .byte   "ND",TK_END     ; END
                             LBB_EOR
00:A2A7  4F52B8            :                 .byte   "OR",TK_EOR     ; EOR
                             LBB_EXP
00:A2AA  585028C8          :                 .byte   "XP(",TK_EXP    ; EXP(
                             LBB_EXIT
00:A2AE  584954A7          :                 .byte   "XIT",TK_EXIT   ; EXIT
00:A2B2  00                :                 .byte   $00
                             TAB_ASCF
                             LBB_FN
00:A2B3  4EAB              :                 .byte   "N",TK_FN       ; FN
                             LBB_FOR
00:A2B5  4F5281            :                 .byte   "OR",TK_FOR     ; FOR
                             LBB_FRE
00:A2B8  524528C3          :                 .byte   "RE(",TK_FRE    ; FRE(
00:A2BC  00                :                 .byte   $00

Portable 65xx Assembler [20.01]

                             TAB_ASCG
                             LBB_GET
00:A2BD  4554A3            :                 .byte   "ET",TK_GET     ; GET
                             LBB_GOSUB
00:A2C0  4F5355428D        :                 .byte   "OSUB",TK_GOSUB ; GOSUB
                             LBB_GOTO
00:A2C5  4F544F89          :                 .byte   "OTO",TK_GOTO   ; GOTO
00:A2C9  00                :                 .byte   $00
                             TAB_ASCH
                             LBB_HEXS
00:A2CA  45582428D7        :                 .byte   "EX$(",TK_HEXS  ; HEX$(
00:A2CF  00                :                 .byte   $00
                             TAB_ASCI
                             LBB_IF
00:A2D0  468B              :                 .byte   "F",TK_IF       ; IF
                             LBB_INC
00:A2D2  4E4393            :                 .byte   "NC",TK_INC     ; INC
                             LBB_INPUT
00:A2D5  4E50555484        :                 .byte   "NPUT",TK_INPUT ; INPUT
                             LBB_INT
00:A2DA  4E5428C0          :                 .byte   "NT(",TK_INT    ; INT(
00:A2DE  00                :                 .byte   $00
                             TAB_ASCL
                             LBB_LCASES
00:A2DF  434153452428D5    :                 .byte   "CASE$(",TK_LCASES
                             ; LCASE$(
                             LBB_LEFTS
00:A2E6  4546542428DF      :                 .byte   "EFT$(",TK_LEFTS ; LEFT$(
                             LBB_LEN
00:A2EC  454E28D0          :                 .byte   "EN(",TK_LEN    ; LEN(
                             LBB_LET
00:A2F0  455487            :                 .byte   "ET",TK_LET     ; LET
                             LBB_LIST
00:A2F3  4953549F          :                 .byte   "IST",TK_LIST   ; LIST
                             LBB_LOAD
00:A2F7  4F414495          :                 .byte   "OAD",TK_LOAD   ; LOAD
                             LBB_LOG
00:A2FB  4F4728C7          :                 .byte   "OG(",TK_LOG    ; LOG(
                             LBB_LOOP
00:A2FF  4F4F509C          :                 .byte   "OOP",TK_LOOP   ; LOOP
00:A303  00                :                 .byte   $00
                             TAB_ASCM
                             LBB_MAX
00:A304  415828DA          :                 .byte   "AX(",TK_MAX    ; MAX(
                             LBB_MIDS
00:A308  49442428E1        :                 .byte   "ID$(",TK_MIDS  ; MID$(
                             LBB_MIN
00:A30D  494E28DB          :                 .byte   "IN(",TK_MIN    ; MIN(
00:A311  00                :                 .byte   $00
                             TAB_ASCN
                             LBB_NEW
00:A312  4557A1            :                 .byte   "EW",TK_NEW     ; NEW
                             LBB_NEXT
00:A315  45585482          :                 .byte   "EXT",TK_NEXT   ; NEXT

Portable 65xx Assembler [20.01]

                             LBB_NOT
00:A319  4F54AE            :                 .byte   "OT",TK_NOT     ; NOT
                             LBB_NULL
00:A31C  554C4C92          :                 .byte   "ULL",TK_NULL   ; NULL
00:A320  00                :                 .byte   $00
                             TAB_ASCO
                             LBB_ON
00:A321  4E91              :                 .byte   "N",TK_ON       ; ON
                             LBB_OR
00:A323  52B9              :                 .byte   "R",TK_OR       ; OR
00:A325  00                :                 .byte   $00
                             TAB_ASCP
                             LBB_PEEK
00:A326  45454B28CD        :                 .byte   "EEK(",TK_PEEK  ; PEEK(
                             LBB_PI
00:A32B  49DC              :                 .byte   "I",TK_PI       ; PI
                             LBB_POKE
00:A32D  4F4B4598          :                 .byte   "OKE",TK_POKE   ; POKE
                             LBB_POS
00:A331  4F5328C4          :                 .byte   "OS(",TK_POS    ; POS(
                             LBB_PRINT
00:A335  52494E549D        :                 .byte   "RINT",TK_PRINT ; PRINT
00:A33A  00                :                 .byte   $00
                             TAB_ASCR
                             LBB_READ
00:A33B  45414486          :                 .byte   "EAD",TK_READ   ; READ
                             LBB_REM
00:A33F  454D8F            :                 .byte   "EM",TK_REM     ; REM
                             LBB_RESTORE
00:A342  4553544F52458C    :                 .byte   "ESTORE",TK_RESTORE
                             ; RESTORE
                             LBB_RETURN
00:A349  455455524E8E      :                 .byte   "ETURN",TK_RETURN ; RETURN
                             LBB_RIGHTS
00:A34F  494748542428E0    :                 .byte   "IGHT$(",TK_RIGHTS
                             ; RIGHT$(
                             LBB_RND
00:A356  4E4428C6          :                 .byte   "ND(",TK_RND    ; RND(
                             LBB_RUN
00:A35A  554E8A            :                 .byte   "UN",TK_RUN     ; RUN
00:A35D  00                :                 .byte   $00
                             TAB_ASCS
                             LBB_SADD
00:A35E  41444428CF        :                 .byte   "ADD(",TK_SADD  ; SADD(
                             LBB_SAVE
00:A363  41564596          :                 .byte   "AVE",TK_SAVE   ; SAVE
                             LBB_SGN
00:A367  474E28BF          :                 .byte   "GN(",TK_SGN    ; SGN(
                             LBB_SIN
00:A36B  494E28CA          :                 .byte   "IN(",TK_SIN    ; SIN(
                             LBB_SPC
00:A36F  504328AC          :                 .byte   "PC(",TK_SPC    ; SPC(
                             LBB_SQR
00:A373  515228C5          :                 .byte   "QR(",TK_SQR    ; SQR(

Portable 65xx Assembler [20.01]

                             LBB_STEP
00:A377  544550AF          :                 .byte   "TEP",TK_STEP   ; STEP
                             LBB_STOP
00:A37B  544F5090          :                 .byte   "TOP",TK_STOP   ; STOP
                             LBB_STRS
00:A37F  54522428D1        :                 .byte   "TR$(",TK_STRS  ; STR$(
                             LBB_SWAP
00:A384  574150A4          :                 .byte   "WAP",TK_SWAP   ; SWAP
00:A388  00                :                 .byte   $00
                             TAB_ASCT
                             LBB_TAB
00:A389  414228A8          :                 .byte   "AB(",TK_TAB    ; TAB(
                             LBB_TAN
00:A38D  414E28CB          :                 .byte   "AN(",TK_TAN    ; TAN(
                             LBB_THEN
00:A391  48454EAD          :                 .byte   "HEN",TK_THEN   ; THEN
                             LBB_TO
00:A395  4FAA              :                 .byte   "O",TK_TO       ; TO
                             LBB_TWOPI
00:A397  574F5049DD        :                 .byte   "WOPI",TK_TWOPI ; TWOPI
00:A39C  00                :                 .byte   $00
                             TAB_ASCU
                             LBB_UCASES
00:A39D  434153452428D4    :                 .byte   "CASE$(",TK_UCASES
                             ; UCASE$(
                             LBB_UNTIL
00:A3A4  4E54494CB0        :                 .byte   "NTIL",TK_UNTIL ; UNTIL
                             LBB_USR
00:A3A9  535228C2          :                 .byte   "SR(",TK_USR    ; USR(
00:A3AD  00                :                 .byte   $00
                             TAB_ASCV
                             LBB_VAL
00:A3AE  414C28D2          :                 .byte   "AL(",TK_VAL    ; VAL(
                             LBB_VPTR
00:A3B2  415250545228DE    :                 .byte   "ARPTR(",TK_VPTR ; VARPTR(
00:A3B9  00                :                 .byte   $00
                             TAB_ASCW
                             LBB_WAIT
00:A3BA  41495494          :                 .byte   "AIT",TK_WAIT   ; WAIT
                             LBB_WHILE
00:A3BE  48494C45B1        :                 .byte   "HILE",TK_WHILE ; WHILE
                             LBB_WIDTH
00:A3C3  49445448A2        :                 .byte   "IDTH",TK_WIDTH ; WIDTH
00:A3C8  00                :                 .byte   $00
                             TAB_POWR
00:A3C9  B600              :                 .byte   TK_POWER,$00    ; ^

                             ; new decode table for LIST
                             ; Table is ..
                             ; byte - keyword length, keyword first character
                             ; word - pointer to rest of keyword from dictionary

                             ; note if length is 1 then the pointer is ignored


Portable 65xx Assembler [20.01]

                             LAB_KEYT
00:A3CB  0345              :                 .byte   3,'E'
00:A3CD  A4A2              :                 .word   LBB_END         ; END
00:A3CF  0346              :                 .byte   3,'F'
00:A3D1  B5A2              :                 .word   LBB_FOR         ; FOR
00:A3D3  044E              :                 .byte   4,'N'
00:A3D5  15A3              :                 .word   LBB_NEXT        ; NEXT
00:A3D7  0444              :                 .byte   4,'D'
00:A3D9  87A2              :                 .word   LBB_DATA        ; DATA
00:A3DB  0549              :                 .byte   5,'I'
00:A3DD  D5A2              :                 .word   LBB_INPUT       ; INPUT
00:A3DF  0344              :                 .byte   3,'D'
00:A3E1  96A2              :                 .word   LBB_DIM         ; DIM
00:A3E3  0452              :                 .byte   4,'R'
00:A3E5  3BA3              :                 .word   LBB_READ        ; READ
00:A3E7  034C              :                 .byte   3,'L'
00:A3E9  F0A2              :                 .word   LBB_LET         ; LET
00:A3EB  0344              :                 .byte   3,'D'
00:A3ED  8BA2              :                 .word   LBB_DEC         ; DEC
00:A3EF  0447              :                 .byte   4,'G'
00:A3F1  C5A2              :                 .word   LBB_GOTO        ; GOTO
00:A3F3  0352              :                 .byte   3,'R'
00:A3F5  5AA3              :                 .word   LBB_RUN         ; RUN
00:A3F7  0249              :                 .byte   2,'I'
00:A3F9  D0A2              :                 .word   LBB_IF          ; IF
00:A3FB  0752              :                 .byte   7,'R'
00:A3FD  42A3              :                 .word   LBB_RESTORE     ; RESTORE
00:A3FF  0547              :                 .byte   5,'G'
00:A401  C0A2              :                 .word   LBB_GOSUB       ; GOSUB
00:A403  0652              :                 .byte   6,'R'
00:A405  49A3              :                 .word   LBB_RETURN      ; RETURN
00:A407  0352              :                 .byte   3,'R'
00:A409  3FA3              :                 .word   LBB_REM         ; REM
00:A40B  0453              :                 .byte   4,'S'
00:A40D  7BA3              :                 .word   LBB_STOP        ; STOP
00:A40F  024F              :                 .byte   2,'O'
00:A411  21A3              :                 .word   LBB_ON          ; ON
00:A413  044E              :                 .byte   4,'N'
00:A415  1CA3              :                 .word   LBB_NULL        ; NULL
00:A417  0349              :                 .byte   3,'I'
00:A419  D2A2              :                 .word   LBB_INC         ; INC
00:A41B  0457              :                 .byte   4,'W'
00:A41D  BAA3              :                 .word   LBB_WAIT        ; WAIT
00:A41F  044C              :                 .byte   4,'L'
00:A421  F7A2              :                 .word   LBB_LOAD        ; LOAD
00:A423  0453              :                 .byte   4,'S'
00:A425  63A3              :                 .word   LBB_SAVE        ; SAVE
00:A427  0344              :                 .byte   3,'D'
00:A429  93A2              :                 .word   LBB_DEF         ; DEF
00:A42B  0450              :                 .byte   4,'P'
00:A42D  2DA3              :                 .word   LBB_POKE        ; POKE
00:A42F  0444              :                 .byte   4,'D'
00:A431  99A2              :                 .word   LBB_DOKE        ; DOKE
00:A433  0443              :                 .byte   4,'C'

Portable 65xx Assembler [20.01]

00:A435  70A2              :                 .word   LBB_CALL        ; CALL
00:A437  0244              :                 .byte   2,'D'
00:A439  9DA2              :                 .word   LBB_DO          ; DO
00:A43B  044C              :                 .byte   4,'L'
00:A43D  FFA2              :                 .word   LBB_LOOP        ; LOOP
00:A43F  0550              :                 .byte   5,'P'
00:A441  35A3              :                 .word   LBB_PRINT       ; PRINT
00:A443  0443              :                 .byte   4,'C'
00:A445  7EA2              :                 .word   LBB_CONT        ; CONT
00:A447  044C              :                 .byte   4,'L'
00:A449  F3A2              :                 .word   LBB_LIST        ; LIST
00:A44B  0543              :                 .byte   5,'C'
00:A44D  79A2              :                 .word   LBB_CLEAR       ; CLEAR
00:A44F  034E              :                 .byte   3,'N'
00:A451  12A3              :                 .word   LBB_NEW         ; NEW
00:A453  0557              :                 .byte   5,'W'
00:A455  C3A3              :                 .word   LBB_WIDTH       ; WIDTH
00:A457  0347              :                 .byte   3,'G'
00:A459  BDA2              :                 .word   LBB_GET         ; GET
00:A45B  0453              :                 .byte   4,'S'
00:A45D  84A3              :                 .word   LBB_SWAP        ; SWAP
00:A45F  0642              :                 .byte   6,'B'
00:A461  62A2              :                 .word   LBB_BITSET      ; BITSET
00:A463  0642              :                 .byte   6,'B'
00:A465  5CA2              :                 .word   LBB_BITCLR      ; BITCLR
00:A467  0445              :                 .byte   4,"E"
00:A469  AEA2              :                 .word   LBB_EXIT        ; EXIT

                             ; secondary commands (can't start a statement)

00:A46B  0454              :                 .byte   4,'T'
00:A46D  89A3              :                 .word   LBB_TAB         ; TAB
00:A46F  0445              :                 .byte   4,'E'
00:A471  A0A2              :                 .word   LBB_ELSE        ; ELSE
00:A473  0254              :                 .byte   2,'T'
00:A475  95A3              :                 .word   LBB_TO          ; TO
00:A477  0246              :                 .byte   2,'F'
00:A479  B3A2              :                 .word   LBB_FN          ; FN
00:A47B  0453              :                 .byte   4,'S'
00:A47D  6FA3              :                 .word   LBB_SPC         ; SPC
00:A47F  0454              :                 .byte   4,'T'
00:A481  91A3              :                 .word   LBB_THEN        ; THEN
00:A483  034E              :                 .byte   3,'N'
00:A485  19A3              :                 .word   LBB_NOT         ; NOT
00:A487  0453              :                 .byte   4,'S'
00:A489  77A3              :                 .word   LBB_STEP        ; STEP
00:A48B  0555              :                 .byte   5,'U'
00:A48D  A4A3              :                 .word   LBB_UNTIL       ; UNTIL
00:A48F  0557              :                 .byte   5,'W'
00:A491  BEA3              :                 .word   LBB_WHILE       ; WHILE

                             ; opperators

00:A493  012B              :                 .byte   1,'+'

Portable 65xx Assembler [20.01]

00:A495  0000              :                 .word   $0000           ; +
00:A497  012D              :                 .byte   1,'-'
00:A499  0000              :                 .word   $0000           ; -
00:A49B  012A              :                 .byte   1,'*'
00:A49D  0000              :                 .word   $0000           ; *
00:A49F  012F              :                 .byte   1,'/'
00:A4A1  0000              :                 .word   $0000           ; /
00:A4A3  015E              :                 .byte   1,'^'
00:A4A5  0000              :                 .word   $0000           ; ^
00:A4A7  0341              :                 .byte   3,'A'
00:A4A9  4BA2              :                 .word   LBB_AND         ; AND
00:A4AB  0345              :                 .byte   3,'E'
00:A4AD  A7A2              :                 .word   LBB_EOR         ; EOR
00:A4AF  024F              :                 .byte   2,'O'
00:A4B1  23A3              :                 .word   LBB_OR          ; OR
00:A4B3  023E              :                 .byte   2,'>'
00:A4B5  41A2              :                 .word   LBB_RSHIFT      ; >>
00:A4B7  023C              :                 .byte   2,'<'
00:A4B9  3BA2              :                 .word   LBB_LSHIFT      ; <<
00:A4BB  013E              :                 .byte   1,'>'
00:A4BD  0000              :                 .word   $0000           ; >
00:A4BF  013D              :                 .byte   1,'='
00:A4C1  0000              :                 .word   $0000           ; =
00:A4C3  013C              :                 .byte   1,'<'
00:A4C5  0000              :                 .word   $0000           ; <

                             ; functions

00:A4C7  0453              :                 .byte   4,'S'           ;
00:A4C9  67A3              :                 .word   LBB_SGN         ; SGN
00:A4CB  0449              :                 .byte   4,'I'           ;
00:A4CD  DAA2              :                 .word   LBB_INT         ; INT
00:A4CF  0441              :                 .byte   4,'A'           ;
00:A4D1  47A2              :                 .word   LBB_ABS         ; ABS
00:A4D3  0455              :                 .byte   4,'U'           ;
00:A4D5  A9A3              :                 .word   LBB_USR         ; USR
00:A4D7  0446              :                 .byte   4,'F'           ;
00:A4D9  B8A2              :                 .word   LBB_FRE         ; FRE
00:A4DB  0450              :                 .byte   4,'P'           ;
00:A4DD  31A3              :                 .word   LBB_POS         ; POS
00:A4DF  0453              :                 .byte   4,'S'           ;
00:A4E1  73A3              :                 .word   LBB_SQR         ; SQR
00:A4E3  0452              :                 .byte   4,'R'           ;
00:A4E5  56A3              :                 .word   LBB_RND         ; RND
00:A4E7  044C              :                 .byte   4,'L'           ;
00:A4E9  FBA2              :                 .word   LBB_LOG         ; LOG
00:A4EB  0445              :                 .byte   4,'E'           ;
00:A4ED  AAA2              :                 .word   LBB_EXP         ; EXP
00:A4EF  0443              :                 .byte   4,'C'           ;
00:A4F1  82A2              :                 .word   LBB_COS         ; COS
00:A4F3  0453              :                 .byte   4,'S'           ;
00:A4F5  6BA3              :                 .word   LBB_SIN         ; SIN
00:A4F7  0454              :                 .byte   4,'T'           ;
00:A4F9  8DA3              :                 .word   LBB_TAN         ; TAN

Portable 65xx Assembler [20.01]

00:A4FB  0441              :                 .byte   4,'A'           ;
00:A4FD  52A2              :                 .word   LBB_ATN         ; ATN
00:A4FF  0550              :                 .byte   5,'P'           ;
00:A501  26A3              :                 .word   LBB_PEEK        ; PEEK
00:A503  0544              :                 .byte   5,'D'           ;
00:A505  8EA2              :                 .word   LBB_DEEK        ; DEEK
00:A507  0553              :                 .byte   5,'S'           ;
00:A509  5EA3              :                 .word   LBB_SADD        ; SADD
00:A50B  044C              :                 .byte   4,'L'           ;
00:A50D  ECA2              :                 .word   LBB_LEN         ; LEN
00:A50F  0553              :                 .byte   5,'S'           ;
00:A511  7FA3              :                 .word   LBB_STRS        ; STR$
00:A513  0456              :                 .byte   4,'V'           ;
00:A515  AEA3              :                 .word   LBB_VAL         ; VAL
00:A517  0441              :                 .byte   4,'A'           ;
00:A519  4EA2              :                 .word   LBB_ASC         ; ASC
00:A51B  0755              :                 .byte   7,'U'           ;
00:A51D  9DA3              :                 .word   LBB_UCASES      ; UCASE$
00:A51F  074C              :                 .byte   7,'L'           ;
00:A521  DFA2              :                 .word   LBB_LCASES      ; LCASE$
00:A523  0543              :                 .byte   5,'C'           ;
00:A525  74A2              :                 .word   LBB_CHRS        ; CHR$
00:A527  0548              :                 .byte   5,'H'           ;
00:A529  CAA2              :                 .word   LBB_HEXS        ; HEX$
00:A52B  0542              :                 .byte   5,'B'           ;
00:A52D  57A2              :                 .word   LBB_BINS        ; BIN$
00:A52F  0742              :                 .byte   7,'B'           ;
00:A531  68A2              :                 .word   LBB_BITTST      ; BITTST
00:A533  044D              :                 .byte   4,'M'           ;
00:A535  04A3              :                 .word   LBB_MAX         ; MAX
00:A537  044D              :                 .byte   4,'M'           ;
00:A539  0DA3              :                 .word   LBB_MIN         ; MIN
00:A53B  0250              :                 .byte   2,'P'           ;
00:A53D  2BA3              :                 .word   LBB_PI          ; PI
00:A53F  0554              :                 .byte   5,'T'           ;
00:A541  97A3              :                 .word   LBB_TWOPI       ; TWOPI
00:A543  0756              :                 .byte   7,'V'           ;
00:A545  B2A3              :                 .word   LBB_VPTR        ; VARPTR
00:A547  064C              :                 .byte   6,'L'           ;
00:A549  E6A2              :                 .word   LBB_LEFTS       ; LEFT$
00:A54B  0752              :                 .byte   7,'R'           ;
00:A54D  4FA3              :                 .word   LBB_RIGHTS      ; RIGHT$
00:A54F  054D              :                 .byte   5,'M'           ;
00:A551  08A3              :                 .word   LBB_MIDS        ; MID$

                             ; BASIC messages, mostly error messages

                             LAB_BAER
00:A553  77A5              :                 .word   ERR_NF          ;$00 NEXT without FOR
00:A555  88A5              :                 .word   ERR_SN          ;$02 syntax
00:A557  8FA5              :                 .word   ERR_RG          ;$04 RETURN without GOSUB
00:A559  A4A5              :                 .word   ERR_OD          ;$06 out of data
00:A55B  B0A5              :                 .word   ERR_FC          ;$08 function call
00:A55D  BEA5              :                 .word   ERR_OV          ;$0A overflow

Portable 65xx Assembler [20.01]

00:A55F  C7A5              :                 .word   ERR_OM          ;$0C out of memory
00:A561  D5A5              :                 .word   ERR_US          ;$0E undefined statement
00:A563  E9A5              :                 .word   ERR_BS          ;$10 array bounds
00:A565  F6A5              :                 .word   ERR_DD          ;$12 double dimension array
00:A567  07A6              :                 .word   ERR_D0          ;$14 divide by 0
00:A569  16A6              :                 .word   ERR_ID          ;$16 illegal direct
00:A56B  25A6              :                 .word   ERR_TM          ;$18 type mismatch
00:A56D  33A6              :                 .word   ERR_LS          ;$1A long string
00:A56F  43A6              :                 .word   ERR_ST          ;$1C string too complex
00:A571  56A6              :                 .word   ERR_CN          ;$1E continue error
00:A573  65A6              :                 .word   ERR_UF          ;$20 undefined function
00:A575  78A6              :                 .word   ERR_LD          ;$22 LOOP without DO

                             ; I may implement these two errors to force definition of variables and
                             ; dimensioning of arrays before use.

                             ;     .word ERR_UV            ;$24 undefined variable

                             ; the above error has been tested and works (see code and comments below LAB_1D8B)

                             ;     .word ERR_UA            ;$26 undimensioned array

00:A577  4E45585420776974> : ERR_NF          .byte   "NEXT without FOR",$00
00:A588  53796E74617800    : ERR_SN          .byte   "Syntax",$00
00:A58F  52455455524E2077> : ERR_RG          .byte   "RETURN without GOSUB",$00
00:A5A4  4F7574206F662044> : ERR_OD          .byte   "Out of DATA",$00
00:A5B0  46756E6374696F6E> : ERR_FC          .byte   "Function call",$00
00:A5BE  4F766572666C6F77> : ERR_OV          .byte   "Overflow",$00
00:A5C7  4F7574206F66206D> : ERR_OM          .byte   "Out of memory",$00
00:A5D5  556E646566696E65> : ERR_US          .byte   "Undefined statement",$00
00:A5E9  417272617920626F> : ERR_BS          .byte   "Array bounds",$00
00:A5F6  446F75626C652064> : ERR_DD          .byte   "Double dimension",$00
00:A607  4469766964652062> : ERR_D0          .byte   "Divide by zero",$00
00:A616  496C6C6567616C20> : ERR_ID          .byte   "Illegal direct",$00
00:A625  54797065206D6973> : ERR_TM          .byte   "Type mismatch",$00
00:A633  537472696E672074> : ERR_LS          .byte   "String too long",$00
00:A643  537472696E672074> : ERR_ST          .byte   "String too complex",$00
00:A656  43616E277420636F> : ERR_CN          .byte   "Can't continue",$00
00:A665  556E646566696E65> : ERR_UF          .byte   "Undefined function",$00
00:A678  4C4F4F5020776974> : ERR_LD          .byte   "LOOP without DO",$00

                             ;ERR_UV     .byte "Undefined variable",$00

                             ; the above error has been tested and works (see code and comments below LAB_1D8B)

                             ;ERR_UA     .byte "Undimensioned array",$00

00:A688  0D0A427265616B00  : LAB_BMSG        .byte   $0D,$0A,"Break",$00
00:A690  204572726F7200    : LAB_EMSG        .byte   " Error",$00
00:A697  20696E206C696E65> : LAB_LMSG        .byte   " in line ",$00
00:A6A1  0D0A52656164790D> : LAB_RMSG        .byte   $0D,$0A,"Ready",$0D,$0A,$00

00:A6AB  2045787472612069> : LAB_IMSG        .byte   " Extra ignored",$0D,$0A,$00
00:A6BC  205265646F206672> : LAB_REDO        .byte   " Redo from start",$0D,$0A,$00

Portable 65xx Assembler [20.01]


                             AA_end_basic

                                             .END


Portable 65xx Assembler [20.01]

Symbol Table

AA_end_basic                     0000A6CF  | LAB_WARM                         00000000
ACSR0                            0000DF70  | PLUS_0                           00000000
ACSR1                            0000DF72  | ZPSTART                          00000000
ACSR2                            0000DF74  | __6501__                         00000000
ACSR3                            0000DF76  | __6502__                         00000000
ARTD0                            0000DF71  | __65816__                        00000000
ARTD1                            0000DF73  | __65832__                        00000000
ARTD2                            0000DF75  | __65SC02__                       00000000
ARTD3                            0000DF77  | C_FLAG                           00000001
Adatah                           00000057  | PLUS_1                           00000001
Adatal                           00000056  | Wrmjpl                           00000001
Aspth                            0000006D  | __65C02__                        00000001
Asptl                            0000006C  | PLUS_2                           00000002
Asrch                            0000000E  | Wrmjph                           00000002
Astrth                           0000005D  | Z_FLAG                           00000002
Astrtl                           0000005C  | PLUS_3                           00000003
BCR                              0000DF40  | Usrjmp                           00000003
BOOT_ENTRY                       00C00000  | I_FLAG                           00000004
B_FLAG                           00000010  | Usrjpl                           00000004
Baslnh                           0000005D  | Usrjph                           00000005
Baslnl                           0000005C  | Nullct                           00000006
BinFErr                          00009DB1  | TPos                             00000007
Blineh                           0000003C  | D_FLAG                           00000008
Blinel                           0000003B  | TWidth                           00000008
Bpntrh                           0000006F  | Iclim                            00000009
Bpntrl                           0000006E  | Itempl                           0000000A
Btmph                            0000006D  | TK_GT_PLUS                       0000000A
Btmpl                            0000006C  | nums_1                           0000000A
CLK_FREQ                         00008000  | Itemph                           0000000B
CTRLC                            00009E3B  | TK_EQUAL_PLUS                    0000000B
C_FLAG                           00000001  | nums_2                           0000000B
CallExit                         00009534  | TK_LT_PLUS                       0000000C
Cflag                            00000015  | nums_3                           0000000C
Clineh                           0000003A  | Srchc                            0000000D
Clinel                           00000039  | Temp3                            0000000D
CopyPRNG                         00009C58  | XOAw_l                           0000000D
Cpntrh                           0000003E  | Asrch                            0000000E
Cpntrl                           0000003D  | Scnquo                           0000000E
Cptrh                            0000006D  | XOAw_h                           0000000E
Cptrl                            0000006C  | Dimcnt                           0000000F
Cvarah                           00000048  | Ibptr                            0000000F
Cvaral                           00000047  | Tindx                            0000000F
D_FLAG                           00000008  | B_FLAG                           00000010
Decss                            00000074  | Defdim                           00000010
Decssp1                          00000075  | X_FLAG                           00000010
Deekh                            000094D3  | Dtypef                           00000011
Defdim                           00000010  | Gclctd                           00000012
Dimcnt                           0000000F  | Oquote                           00000012
Dlineh                           00000040  | Sufnxf                           00000013
Dlinel                           0000003F  | Imode                            00000014
DoCmp                            00008629  | Cflag                            00000015
DoRest                           0000861B  | TabSiz                           00000016

Portable 65xx Assembler [20.01]

Dokeh                            000094F6  | next_s                           00000017
Dptrh                            00000042  | last_sl                          00000018
Dptrl                            00000041  | last_sh                          00000019
Dtypef                           00000011  | des_sk                           0000001A
EIER                             0000DF47  | M_FLAG                           00000020
EIFR                             0000DF45  | STACK_RES                        00000020
ERR_BS                           0000A5E9  | Temp_2                           00000023
ERR_CN                           0000A656  | ut1_pl                           00000023
ERR_D0                           0000A607  | ut1_ph                           00000024
ERR_DD                           0000A5F6  | ut2_pl                           00000025
ERR_FC                           0000A5B0  | ut2_ph                           00000026
ERR_ID                           0000A616  | FACt_1                           00000027
ERR_LD                           0000A678  | FACt_2                           00000028
ERR_LS                           0000A633  | dims_l                           00000028
ERR_NF                           0000A577  | FACt_3                           00000029
ERR_OD                           0000A5A4  | dims_h                           00000029
ERR_OM                           0000A5C7  | TempB                            0000002A
ERR_OV                           0000A5BE  | Smeml                            0000002B
ERR_RG                           0000A58F  | Smemh                            0000002C
ERR_SN                           0000A588  | Svarl                            0000002D
ERR_ST                           0000A643  | Svarh                            0000002E
ERR_TM                           0000A625  | Sarryl                           0000002F
ERR_UF                           0000A665  | Sarryh                           00000030
ERR_US                           0000A5D5  | Earryl                           00000031
Earryh                           00000032  | Earryh                           00000032
Earryl                           00000031  | Sstorl                           00000033
Ememh                            00000038  | Sstorh                           00000034
Ememl                            00000037  | Sutill                           00000035
EndBHS                           00009D8F  | Sutilh                           00000036
EndTab                           0000A020  | Ememl                            00000037
FAC1_1                           0000005F  | Ememh                            00000038
FAC1_2                           00000060  | Clinel                           00000039
FAC1_3                           00000061  | Clineh                           0000003A
FAC1_e                           0000005E  | Blinel                           0000003B
FAC1_o                           00000064  | Blineh                           0000003C
FAC1_r                           0000006B  | Cpntrl                           0000003D
FAC1_s                           00000062  | Cpntrh                           0000003E
FAC2_1                           00000066  | Dlinel                           0000003F
FAC2_2                           00000067  | Dlineh                           00000040
FAC2_3                           00000068  | V_FLAG                           00000040
FAC2_e                           00000065  | Dptrl                            00000041
FAC2_r                           00000055  | Dptrh                            00000042
FAC2_s                           00000069  | Rdptrl                           00000043
FAC_sc                           0000006A  | Rdptrh                           00000044
FACt_1                           00000027  | Varnm1                           00000045
FACt_2                           00000028  | Varnm2                           00000046
FACt_3                           00000029  | Cvaral                           00000047
FCError                          00009D3A  | Cvarah                           00000048
Fnxjmp                           00000053  | Frnxtl                           00000049
Fnxjph                           00000055  | Lvarpl                           00000049
Fnxjpl                           00000054  | Tidx1                            00000049
Frnxth                           0000004A  | Frnxth                           0000004A
Frnxtl                           00000049  | Lvarph                           0000004A
Fvar_h                           0000005D  | prstk                            0000004B

Portable 65xx Assembler [20.01]

Fvar_l                           0000005C  | comp_f                           0000004D
Gclctd                           00000012  | func_l                           0000004E
GetFirst                         00008CA3  | garb_l                           0000004E
GetPair                          00008D5F  | func_h                           0000004F
GoPr                             00009D9D  | garb_h                           0000004F
GoPr1                            00009D9E  | des_2l                           00000050
GoPr2                            00009DA9  | des_2h                           00000051
GoPr3                            00009D9C  | g_step                           00000052
Histrh                           0000005D  | Fnxjmp                           00000053
Histrl                           0000005C  | Fnxjpl                           00000054
INGET                            00009E59  | g_indx                           00000054
I_FLAG                           00000004  | FAC2_r                           00000055
Ibptr                            0000000F  | Fnxjph                           00000055
Ibuffe                           0000047E  | Adatal                           00000056
Ibuffs                           00000400  | Nbendl                           00000056
Iclim                            00000009  | Adatah                           00000057
Imode                            00000014  | Nbendh                           00000057
IncrErr                          00008786  | Obendl                           00000058
Itemph                           0000000B  | Obendh                           00000059
Itempl                           0000000A  | numbit                           0000005A
LAB_11A1                         00008A01  | numexp                           0000005A
LAB_11A6                         00008A06  | expcnt                           0000005B
LAB_11BB                         00008A1B  | Astrtl                           0000005C
LAB_11C7                         00008A27  | Baslnl                           0000005C
LAB_11CE                         00008A2E  | Fvar_l                           0000005C
LAB_11CF                         000080B6  | Histrl                           0000005C
LAB_11D6                         000080BD  | Ostrtl                           0000005C
LAB_11F3                         000080D8  | Vrschl                           0000005C
LAB_11FF                         000080E5  | numdpf                           0000005C
LAB_1203                         000080E9  | Astrth                           0000005D
LAB_120A                         000080F0  | Baslnh                           0000005D
LAB_1212                         000080F8  | Fvar_h                           0000005D
LAB_121F                         00008103  | Histrh                           0000005D
LAB_1229                         0000810D  | Ostrth                           0000005D
LAB_122D                         00008111  | Vrschh                           0000005D
LAB_1238                         0000811C  | expneg                           0000005D
LAB_124B                         00008130  | FAC1_e                           0000005E
LAB_1269                         00008146  | str_ln                           0000005E
LAB_1274                         00008151  | FAC1_1                           0000005F
LAB_127D                         00008158  | str_pl                           0000005F
LAB_1280                         0000815B  | FAC1_2                           00000060
LAB_1295                         00008170  | des_pl                           00000060
LAB_12D0                         000081AB  | str_ph                           00000060
LAB_12D8                         000081B3  | FAC1_3                           00000061
LAB_12E6                         000081C1  | des_ph                           00000061
LAB_1301                         000081DB  | mids_l                           00000061
LAB_1311                         000081ED  | FAC1_s                           00000062
LAB_1319                         00008205  | negnum                           00000063
LAB_1325                         0000820E  | numcon                           00000063
LAB_1330                         00008218  | FAC1_o                           00000064
LAB_133E                         0000822E  | FAC2_e                           00000065
LAB_134B                         00008239  | FAC2_1                           00000066
LAB_1357                         0000823F  | FAC2_2                           00000067
LAB_1359                         00008241  | FAC2_3                           00000068

Portable 65xx Assembler [20.01]

LAB_1374                         00008258  | FAC2_s                           00000069
LAB_1378                         0000825C  | FAC_sc                           0000006A
LAB_137F                         00008264  | sdescr                           0000006A
LAB_1384                         00008269  | ssptr_l                          0000006A
LAB_138E                         0000826C  | FAC1_r                           0000006B
LAB_13A6                         00008270  | ssptr_h                          0000006B
LAB_13AC                         0000827A  | Asptl                            0000006C
LAB_13CC                         00008295  | Btmpl                            0000006C
LAB_13D0                         000082A7  | Cptrl                            0000006C
LAB_13D1                         000082B0  | Sendl                            0000006C
LAB_13D6                         000082C1  | csidx                            0000006C
LAB_13D8                         000082C4  | Aspth                            0000006D
LAB_13EA                         000082CE  | Btmph                            0000006D
LAB_13EC                         000082D0  | Cptrh                            0000006D
LAB_13FF                         000082E1  | Sendh                            0000006D
LAB_1401                         000082E3  | Bpntrl                           0000006E
LAB_1408                         000082E9  | Bpntrh                           0000006F
LAB_1410                         000082F2  | Rbyte4                           00000070
LAB_1417                         000082F9  | Rbyte1                           00000071
LAB_141B                         000082FB  | Rbyte2                           00000072
LAB_142A                         0000830B  | Rbyte3                           00000073
LAB_142P                         00008319  | Decss                            00000074
LAB_1455                         00008337  | Decssp1                          00000075
LAB_1456                         00008339  | N_FLAG                           00000080
LAB_145E                         00008342  | TK_END                           00000080
LAB_145F                         00008344  | TK_FOR                           00000081
LAB_1460                         00008345  | TK_NEXT                          00000082
LAB_1463                         00008348  | TK_DATA                          00000083
LAB_1477                         0000835D  | TK_INPUT                         00000084
LAB_147A                         0000836A  | TK_DIM                           00000085
LAB_1491                         00008381  | ZPLastByte                       00000085
LAB_14A6                         00008394  | TK_READ                          00000086
LAB_14BD                         000083A0  | TK_LET                           00000087
LAB_14D4                         000083B7  | TK_DEC                           00000088
LAB_14E2                         000083C3  | TK_GOTO                          00000089
LAB_14FF                         000083E0  | TK_RUN                           0000008A
LAB_1501                         000083E2  | TK_IF                            0000008B
LAB_1508                         000083E9  | TK_RESTORE                       0000008C
LAB_150C                         000083ED  | TK_GOSUB                         0000008D
LAB_1519                         000083FA  | TK_RETURN                        0000008E
LAB_152B                         0000840C  | TK_REM                           0000008F
LAB_152E                         0000840D  | TK_STOP                          00000090
LAB_152F                         0000841B  | TK_ON                            00000091
LAB_1530                         00008420  | TK_NULL                          00000092
LAB_1540                         00008442  | TK_INC                           00000093
LAB_159F                         0000848C  | TK_WAIT                          00000094
LAB_15B3                         000084A0  | TK_LOAD                          00000095
LAB_15C2                         000084B1  | TK_SAVE                          00000096
LAB_15D1                         000084BF  | TK_DEF                           00000097
LAB_15D9                         000084C7  | TK_POKE                          00000098
LAB_15DC                         000084CA  | TK_DOKE                          00000099
LAB_15F6                         000084E4  | TK_CALL                          0000009A
LAB_15F9                         000084E7  | TK_DO                            0000009B
LAB_15FC                         000084EA  | TK_LOOP                          0000009C

Portable 65xx Assembler [20.01]

LAB_15FF                         000084EC  | TK_PRINT                         0000009D
LAB_1602                         000084EE  | TK_CONT                          0000009E
LAB_1609                         000084F4  | TK_LIST                          0000009F
LAB_161A                         0000852E  | TK_CLEAR                         000000A0
LAB_1624                         00008538  | TK_NEW                           000000A1
LAB_1628                         0000853C  | TK_WIDTH                         000000A2
LAB_1629                         00008504  | TK_GET                           000000A3
LAB_1636                         00008507  | TK_SWAP                          000000A4
LAB_163B                         0000850C  | TK_BITSET                        000000A5
LAB_1647                         00008516  | TK_BITCLR                        000000A6
LAB_164F                         0000851E  | TK_EXIT                          000000A7
LAB_1651                         00008520  | TK_TAB                           000000A8
LAB_165E                         00008529  | TK_ELSE                          000000A9
LAB_166C                         0000857D  | TK_TO                            000000AA
LAB_167A                         0000856F  | TK_FN                            000000AB
LAB_1696                         00008591  | TK_SPC                           000000AC
LAB_16B0                         000085C4  | TK_THEN                          000000AD
LAB_16D0                         000085E4  | TK_NOT                           000000AE
LAB_16D4                         000085E8  | TK_STEP                          000000AF
LAB_16E5                         000085F9  | TK_UNTIL                         000000B0
LAB_16E8                         0000865B  | TK_WHILE                         000000B1
LAB_16F4                         00008650  | TK_PLUS                          000000B2
LAB_16F7                         00008654  | TK_MINUS                         000000B3
LAB_16F7b                        00008656  | TK_MUL                           000000B4
LAB_16FC                         0000867C  | TK_DIV                           000000B5
LAB_16FD                         00008708  | TK_POWER                         000000B6
LAB_16FF                         00008662  | TK_AND                           000000B7
LAB_170F                         00008671  | TK_EOR                           000000B8
LAB_1719                         0000867B  | TK_OR                            000000B9
LAB_1725                         00008689  | TK_RSHIFT                        000000BA
LAB_172D                         0000868E  | TK_LSHIFT                        000000BB
LAB_174B                         000086B8  | TK_GT                            000000BC
LAB_174C                         000086C1  | TK_EQUAL                         000000BD
LAB_174D                         000086C4  | TK_LT                            000000BE
LAB_174E                         000086D8  | TK_SGN                           000000BF
LAB_1750                         000086DC  | TK_INT                           000000C0
LAB_1752                         000086E8  | TK_ABS                           000000C1
LAB_1753                         000086F0  | TK_USR                           000000C2
LAB_1754                         000086FA  | TK_FRE                           000000C3
LAB_1767                         00008715  | TK_POS                           000000C4
LAB_176B                         00008717  | TK_SQR                           000000C5
LAB_1773                         0000871F  | TK_RND                           000000C6
LAB_177E                         00008729  | TK_LOG                           000000C7
LAB_177F                         0000872A  | TK_EXP                           000000C8
LAB_1785                         0000872F  | TK_COS                           000000C9
LAB_17B3                         00008756  | TK_SIN                           000000CA
LAB_17B5                         00008761  | TK_TAN                           000000CB
LAB_17B7                         00008762  | TK_ATN                           000000CC
LAB_17D5                         000087A5  | TK_PEEK                          000000CD
LAB_17E6                         000087B6  | TK_DEEK                          000000CE
LAB_17F4                         000087C4  | TK_SADD                          000000CF
LAB_17FB                         000087CA  | TK_LEN                           000000D0
LAB_1811                         000087DE  | TK_STRS                          000000D1
LAB_1829                         00008820  | TK_VAL                           000000D2

Portable 65xx Assembler [20.01]

LAB_182C                         00008823  | TK_ASC                           000000D3
LAB_1831                         00008828  | TK_UCASES                        000000D4
LAB_185E                         00008853  | TK_LCASES                        000000D5
LAB_1866                         00008858  | TK_CHRS                          000000D6
LAB_1880                         000088E7  | TK_HEXS                          000000D7
LAB_1886                         000088EF  | TK_BINS                          000000D8
LAB_188A                         000088F3  | TK_BITTST                        000000D9
LAB_188B                         00008868  | TK_MAX                           000000DA
LAB_188C                         000088F5  | TK_MIN                           000000DB
LAB_1897                         00008873  | TK_PI                            000000DC
LAB_1898                         00008874  | TK_TWOPI                         000000DD
LAB_18A2                         0000887E  | TK_VPTR                          000000DE
LAB_18B6                         00008890  | TK_LEFTS                         000000DF
LAB_18B7                         00008891  | TK_RIGHTS                        000000E0
LAB_18BA                         00008894  | TK_MIDS                          000000E1
LAB_18BD                         0000889A  | LAB_STAK                         00000100
LAB_18C3                         000088A0  | LAB_SKFE                         000001FE
LAB_18C6                         000088A3  | LAB_SKFF                         000001FF
LAB_18CD                         000088AB  | Ibuffs                           00000400
LAB_18E0                         000088B5  | Ibuffe                           0000047E
LAB_18E3                         000088B9  | ccflag                           0000047F
LAB_18F0                         000088CE  | ccbyte                           00000480
LAB_18F7                         000088D5  | ccnull                           00000481
LAB_18F9                         000088D8  | VEC_CC                           00000482
LAB_1904                         000088F6  | VEC_IN                           00000484
LAB_1910                         00008902  | VEC_OUT                          00000486
LAB_1913                         00008905  | VEC_LD                           00000488
LAB_1934                         00008924  | VEC_SV                           0000048A
LAB_1953                         0000893A  | VEC_EXIT                         0000048C
LAB_195B                         00008940  | Ram_base                         00000800
LAB_1985                         0000896A  | CLK_FREQ                         00008000
LAB_1988                         0000896D  | Ram_top                          00008000
LAB_1999                         0000897E  | RDBYTE                           0000800B
LAB_19A4                         00008989  | RDBYTE.DONE                      00008017
LAB_19B0                         00008994  | WRBYTE                           00008018
LAB_19B6                         0000899A  | WRBYTE.WAIT                      00008019
LAB_19C2                         000089A6  | SYSLOAD                          00008025
LAB_19C5                         000089A9  | SYSSAVE                          00008026
LAB_19DD                         000089C4  | SYSEXIT                          00008027
LAB_19F6                         000089DD  | LAB_COLD                         0000802B
LAB_1A03                         000089EA  | LAB_2D13                         0000802D
LAB_1A0E                         000089F5  | LAB_GMEM                         0000803F
LAB_1A1B                         000089FA  | TabLoop                          00008041
LAB_1A46                         00008A35  | LAB_2D93                         00008059
LAB_1A49                         00008A38  | LAB_2D99                         00008069
LAB_1A54                         00008A43  | LAB_2DB6                         00008078
LAB_1A56                         00008A45  | MEM_OK                           0000807C
LAB_1A98                         00008A82  | LAB_2E05                         00008091
LAB_1A9B                         00008A85  | LAB_11CF                         000080B6
LAB_1AB9                         00008AA4  | LAB_11D6                         000080BD
LAB_1ABA                         00008AA5  | LAB_11F3                         000080D8
LAB_1ABC                         00008AA7  | LAB_11FF                         000080E5
LAB_1ABE                         00008AA9  | LAB_1203                         000080E9
LAB_1AC7                         00008AB2  | LAB_120A                         000080F0

Portable 65xx Assembler [20.01]

LAB_1ACC                         00008AB6  | LAB_1212                         000080F8
LAB_1ADB                         00008AC1  | LAB_121F                         00008103
LAB_1ADE                         00008AC4  | LAB_1229                         0000810D
LAB_1AFA                         00008ADF  | LAB_122D                         00008111
LAB_1B0B                         00008AF2  | LAB_1238                         0000811C
LAB_1B13                         00008AF8  | LAB_124B                         00008130
LAB_1B1C                         00008B01  | LAB_OMER                         00008131
LAB_1B1D                         00008B02  | LAB_XERR                         00008133
LAB_1B2A                         00008B0F  | LAB_1269                         00008146
LAB_1B34                         00008B1B  | LAB_1274                         00008151
LAB_1B3C                         00008B23  | LAB_127D                         00008158
LAB_1B43                         00008B2A  | LAB_1280                         0000815B
LAB_1B53                         00008B3E  | LAB_1295                         00008170
LAB_1B5B                         00008B41  | LAB_12D0                         000081AB
LAB_1B66                         00008B4C  | LAB_12D8                         000081B3
LAB_1B78                         00008B5E  | LAB_12E6                         000081C1
LAB_1B7B                         00008B61  | LAB_1301                         000081DB
LAB_1B7D                         00008B63  | LAB_1311                         000081ED
LAB_1B84                         00008B6A  | LAB_1319                         00008205
LAB_1B86                         00008B6C  | LAB_1325                         0000820E
LAB_1B9D                         00008B83  | LAB_1330                         00008218
LAB_1BA9                         00008B9A  | LAB_133E                         0000822E
LAB_1BAC                         00008B9D  | LAB_INLN                         00008231
LAB_1BC1                         00008B86  | LAB_134B                         00008239
LAB_1BCA                         00008B8F  | LAB_1357                         0000823F
LAB_1BD0                         00008BCD  | LAB_1359                         00008241
LAB_1BE7                         00008BEC  | LAB_1374                         00008258
LAB_1BEE                         00008BF3  | LAB_1378                         0000825C
LAB_1BF7                         00008BB4  | LAB_137F                         00008264
LAB_1BFB                         00008BB7  | LAB_1384                         00008269
LAB_1BFE                         00008BC0  | LAB_138E                         0000826C
LAB_1C01                         00008BC4  | LAB_13A6                         00008270
LAB_1C11                         00008BF9  | LAB_13AC                         0000827A
LAB_1C13                         00008BFB  | LAB_13CC                         00008295
LAB_1C18                         00008C00  | LAB_13D0                         000082A7
LAB_1C18p2                       00008C02  | LAB_13D1                         000082B0
LAB_1C24                         00008C0B  | LAB_13D6                         000082C1
LAB_1C25                         00008C0E  | LAB_13D8                         000082C4
LAB_1C27                         00008C0F  | LAB_13EA                         000082CE
LAB_1C54                         00008C78  | LAB_13EC                         000082D0
LAB_1C56                         00008C23  | LAB_13FF                         000082E1
LAB_1C95                         00008CB6  | LAB_1401                         000082E3
LAB_1CAE                         00008CCE  | LAB_1408                         000082E9
LAB_1CD6                         00008CF4  | LAB_1410                         000082F2
LAB_1CDB                         00008CF9  | LAB_1417                         000082F9
LAB_1CE1                         00008CFF  | LAB_141B                         000082FB
LAB_1CE6                         00008D04  | LAB_142A                         0000830B
LAB_1CF2                         00008D10  | LAB_142P                         00008319
LAB_1CFB                         00008D19  | LAB_SSLN                         0000831C
LAB_1CFE                         00008D1C  | LAB_SHLN                         00008320
LAB_1D10                         00008D6F  | LAB_1455                         00008337
LAB_1D12                         00008D71  | LAB_1456                         00008339
LAB_1D1F                         00008D7D  | LAB_145E                         00008342
LAB_1D2D                         00008D8B  | LAB_145F                         00008344

Portable 65xx Assembler [20.01]

LAB_1D2E                         00008D8C  | LAB_1460                         00008345
LAB_1D38                         00008D96  | LAB_NEW                          00008346
LAB_1D47                         00008DA5  | LAB_1463                         00008348
LAB_1D53                         00008DB0  | LAB_1477                         0000835D
LAB_1D5D                         00008DB8  | LAB_147A                         0000836A
LAB_1D5F                         00008DBA  | LAB_1491                         00008381
LAB_1D69                         00008DC4  | LAB_14A6                         00008394
LAB_1D77                         00008DD2  | LAB_CLEAR                        00008395
LAB_1D82                         00008DE0  | LAB_LIST                         00008398
LAB_1D83                         00008DEA  | LAB_14BD                         000083A0
LAB_1D8A                         00008DE9  | LAB_14D4                         000083B7
LAB_1D8B                         00008DF0  | LAB_14E2                         000083C3
LAB_1D96                         0000A0B2  | LAB_14FF                         000083E0
LAB_1D98                         00008DFB  | LAB_1501                         000083E2
LAB_1DAE                         00008E11  | LAB_1508                         000083E9
LAB_1DD7                         00008E3A  | LAB_150C                         000083ED
LAB_1DE1                         00008E44  | LAB_1519                         000083FA
LAB_1DE6                         00008E49  | LAB_152B                         0000840C
LAB_1DF2                         00008E55  | LAB_152E                         0000840D
LAB_1DF7                         0000A0B9  | LAB_152F                         0000841B
LAB_1E12                         00008E71  | LAB_1530                         00008420
LAB_1E14                         00008E73  | LAB_1540                         00008442
LAB_1E17                         00008E76  | LAB_FOR                          0000844D
LAB_1E1F                         00008E7E  | LAB_159F                         0000848C
LAB_1E5C                         00008EB9  | LAB_15B3                         000084A0
LAB_1E68                         00008EC5  | LAB_15C2                         000084B1
LAB_1E77                         00008ED4  | LAB_15D1                         000084BF
LAB_1E85                         00008EE2  | LAB_15D9                         000084C7
LAB_1E8A                         00008EE8  | LAB_15DC                         000084CA
LAB_1E8D                         00008EEB  | LAB_15F6                         000084E4
LAB_1EA1                         00008EFF  | LAB_15F9                         000084E7
LAB_1EC0                         00008F1B  | LAB_15FC                         000084EA
LAB_1ED0                         00008F2A  | LAB_15FF                         000084EC
LAB_1EF3                         00008F4D  | LAB_1602                         000084EE
LAB_1F02                         00008F5C  | LAB_1609                         000084F4
LAB_1F07                         00008F61  | LAB_1629                         00008504
LAB_1F24                         00008F7E  | LAB_1636                         00008507
LAB_1F28                         00008F82  | LAB_STOP                         00008509
LAB_1F2C                         00008F86  | LAB_END                          0000850B
LAB_1F42                         00008F9C  | LAB_163B                         0000850C
LAB_1F45                         00008F9F  | LAB_1647                         00008516
LAB_1F48                         00008FA2  | LAB_164F                         0000851E
LAB_1F49                         00008FA3  | LAB_1651                         00008520
LAB_1F5A                         00008FB3  | LAB_165E                         00008529
LAB_1F7B                         00008FD0  | LAB_RESTORE                      0000852C
LAB_1F7C                         00008FD1  | LAB_161A                         0000852E
LAB_1F8F                         00008FE4  | LAB_uflow                        00008537
LAB_1FA8                         00008FFD  | LAB_1624                         00008538
LAB_1FB4                         00009009  | LAB_1628                         0000853C
LAB_1FD0                         00009023  | LAB_RESTOREn                     0000853D
LAB_1FD9                         0000902C  | LAB_reset_search                 00008554
LAB_1FDB                         0000902E  | LAB_go_search                    00008558
LAB_200B                         00009061  | LAB_line_found                   00008560
LAB_201E                         00009070  | LAB_NULL                         0000856A

Portable 65xx Assembler [20.01]

LAB_2043                         00009098  | LAB_167A                         0000856F
LAB_2074                         000090C9  | LAB_CONT                         00008570
LAB_207A                         000090CF  | LAB_166C                         0000857D
LAB_209C                         000090ED  | LAB_RUN                          0000858C
LAB_20AE                         000090FF  | LAB_1696                         00008591
LAB_20B4                         00009105  | LAB_DO                           00008596
LAB_20BE                         0000910F  | LAB_GOSUB                        000085B0
LAB_20CB                         0000911C  | LAB_16B0                         000085C4
LAB_20CF                         00009120  | LAB_GOTO                         000085CD
LAB_20D0                         00009121  | LAB_16D0                         000085E4
LAB_20DC                         0000912D  | LAB_16D4                         000085E8
LAB_20F5                         0000914A  | LAB_16E5                         000085F9
LAB_20F8                         0000914D  | LAB_DONOK                        000085FA
LAB_2115                         00009169  | LAB_LOOP                         000085FF
LAB_2117                         0000916B  | DoRest                           0000861B
LAB_2122                         00009176  | DoCmp                            00008629
LAB_212C                         00009180  | LoopAlways                       0000862E
LAB_2137                         0000918B  | LoopDone                         00008648
LAB_214B                         0000919F  | LAB_16F4                         00008650
LAB_2161                         000091B3  | LAB_16F7                         00008654
LAB_216A                         000091BC  | LAB_16F7b                        00008656
LAB_2176                         000091C6  | LAB_RETURN                       00008659
LAB_217E                         000091CE  | LAB_16E8                         0000865B
LAB_2183                         000091D3  | LAB_16FF                         00008662
LAB_218B                         000091DB  | LAB_DATA                         0000866E
LAB_218F                         000091DF  | LAB_170F                         00008671
LAB_219A                         000091E7  | LAB_1719                         0000867B
LAB_21C4                         0000920A  | LAB_16FC                         0000867C
LAB_21CC                         00009212  | LAB_SNBS                         0000867F
LAB_21D1                         00009217  | LAB_SNBL                         00008683
LAB_21D7                         0000921D  | LAB_SNBLb                        00008685
LAB_21EC                         00009232  | LAB_1725                         00008689
LAB_21F6                         0000923C  | LAB_172D                         0000868E
LAB_2206                         0000924C  | LAB_IF                           0000869D
LAB_2207                         0000924D  | LAB_174B                         000086B8
LAB_2208                         0000924F  | LAB_174C                         000086C1
LAB_2211                         00009257  | LAB_174D                         000086C4
LAB_2216                         0000925C  | LAB_no_ELSE                      000086D5
LAB_224D                         0000928E  | LAB_174E                         000086D8
LAB_226D                         000092AC  | LAB_1750                         000086DC
LAB_228A                         000092C9  | LAB_1752                         000086E8
LAB_2298                         000092D7  | LAB_1753                         000086F0
LAB_229C                         000092DB  | LAB_1754                         000086FA
LAB_22A0                         000092E0  | LAB_REM                          00008702
LAB_22A9                         000092E9  | LAB_16FD                         00008708
LAB_22B2                         000092F2  | LAB_ON                           0000870B
LAB_22B6                         000092F6  | LAB_1767                         00008715
LAB_22BA                         000092FA  | LAB_176B                         00008717
LAB_22E5                         00009325  | LAB_1773                         0000871F
LAB_22E6                         00009326  | LAB_177E                         00008729
LAB_22EB                         0000932B  | LAB_177F                         0000872A
LAB_22FB                         0000933B  | LAB_GFPN                         0000872B
LAB_2316                         0000935D  | LAB_1785                         0000872F
LAB_231C                         00009363  | LAB_17B3                         00008756

Portable 65xx Assembler [20.01]

LAB_231D                         00009364  | LAB_DEC                          0000875B
LAB_231E                         00009365  | LAB_INC                          0000875F
LAB_2335                         0000937B  | LAB_17B5                         00008761
LAB_2358                         00009394  | LAB_17B7                         00008762
LAB_236F                         000093AB  | IncrErr                          00008786
LAB_23A8                         00009437  | LAB_LET                          00008789
LAB_23C5                         00009454  | LAB_17D5                         000087A5
LAB_23F3                         0000947D  | LAB_17E6                         000087B6
LAB_2441                         00009546  | LAB_17F4                         000087C4
LAB_2445                         00009548  | LAB_17FB                         000087CA
LAB_244D                         00009550  | LAB_1811                         000087DE
LAB_244E                         00009567  | LAB_GET                          000087F6
LAB_2455                         00009551  | LAB_GETS                         0000880B
LAB_2467                         00009562  | LAB_IsByte                       00008811
LAB_246C                         0000956B  | LAB_NoSt                         0000881B
LAB_2474                         00009580  | LAB_1829                         00008820
LAB_247C                         00009588  | LAB_182C                         00008823
LAB_2498                         000095A2  | LAB_PRINT                        00008826
LAB_249C                         000095A4  | LAB_1831                         00008828
LAB_24A8                         000095B0  | LAB_185E                         00008853
LAB_24B4                         000095BC  | LAB_1866                         00008858
LAB_24D0                         000095D8  | LAB_CRLF                         0000885F
LAB_24D5                         000095DD  | LAB_188B                         00008868
LAB_24D9                         000095E1  | LAB_1897                         00008873
LAB_24F1                         000095F9  | LAB_1898                         00008874
LAB_24F3                         000095FB  | LAB_18A2                         0000887E
LAB_24F5                         000095FD  | LAB_18B6                         00008890
LAB_24F8                         00009600  | LAB_18B7                         00008891
LAB_2511                         00009619  | LAB_18BA                         00008894
LAB_251B                         00009623  | LAB_18BD                         0000889A
LAB_2528                         00009630  | LAB_18C3                         000088A0
LAB_252A                         00009632  | LAB_18C6                         000088A3
LAB_2536                         0000963E  | LAB_18CD                         000088AB
LAB_2537                         0000963F  | LAB_18E0                         000088B5
LAB_253D                         00009645  | LAB_18E3                         000088B9
LAB_2559                         00009661  | LAB_PRNA                         000088BB
LAB_2563                         0000966B  | LAB_18F0                         000088CE
LAB_2564                         0000966C  | LAB_18F7                         000088D5
LAB_2569                         00009671  | LAB_18F9                         000088D8
LAB_256B                         00009673  | LAB_1880                         000088E7
LAB_257B                         00009683  | LAB_1886                         000088EF
LAB_2588                         00009690  | LAB_188A                         000088F3
LAB_258E                         00009696  | LAB_188C                         000088F5
LAB_2592                         0000969A  | LAB_1904                         000088F6
LAB_259A                         000096A2  | LAB_1910                         00008902
LAB_259C                         0000A0B1  | LAB_1913                         00008905
LAB_25A0                         0000A02D  | LAB_INPUT                        00008915
LAB_25AD                         0000A03A  | LAB_1934                         00008924
LAB_25B1                         0000A03E  | LAB_READ                         00008934
LAB_25B5                         0000A042  | LAB_1953                         0000893A
LAB_25B9                         0000A046  | LAB_195B                         00008940
LAB_25C4                         000096AB  | LAB_1985                         0000896A
LAB_25C7                         000096AE  | LAB_1988                         0000896D
LAB_25FB                         000096E2  | LAB_1999                         0000897E

Portable 65xx Assembler [20.01]

LAB_2622                         00009707  | LAB_19A4                         00008989
LAB_2627                         0000970C  | LAB_19B0                         00008994
LAB_262A                         0000970F  | LAB_19B6                         0000899A
LAB_2640                         00009725  | LAB_19C2                         000089A6
LAB_264C                         00009731  | LAB_19C5                         000089A9
LAB_264D                         00009732  | LAB_19DD                         000089C4
LAB_2673                         00009758  | LAB_19F6                         000089DD
LAB_2675                         0000975A  | LAB_1A03                         000089EA
LAB_2680                         00009766  | LAB_1A0E                         000089F5
LAB_2680b                        00009768  | LAB_1A1B                         000089FA
LAB_268B                         00009771  | LAB_11A1                         00008A01
LAB_268F                         00009775  | LAB_11A6                         00008A06
LAB_2690                         00009776  | LAB_11BB                         00008A1B
LAB_2696                         0000977A  | LAB_11C7                         00008A27
LAB_269B                         00009795  | LAB_11CE                         00008A2E
LAB_269E                         0000977F  | LAB_NEXT                         00008A2F
LAB_26B5                         0000A0C2  | LAB_1A46                         00008A35
LAB_26B9                         00009798  | LAB_1A49                         00008A38
LAB_26C2                         000097A1  | LAB_1A54                         00008A43
LAB_26CA                         000097A8  | LAB_1A56                         00008A45
LAB_26E4                         000097C2  | LAB_1A98                         00008A82
LAB_26F4                         000097D2  | LAB_1A9B                         00008A85
LAB_2701                         000097E1  | LAB_EVNM                         00008A97
LAB_2702                         000097E4  | LAB_CTNM                         00008A9A
LAB_2704                         000097FB  | LAB_CTST                         00008A9D
LAB_272B                         00009807  | LAB_CKTM                         00008A9E
LAB_2737                         0000980F  | LAB_1AB9                         00008AA4
LAB_273C                         00009814  | LAB_1ABA                         00008AA5
LAB_276E                         00009843  | LAB_1ABC                         00008AA7
LAB_2770                         00009845  | LAB_1ABE                         00008AA9
LAB_2778                         0000984D  | LAB_EVEX                         00008AAC
LAB_279B                         00009570  | LAB_1AC7                         00008AB2
LAB_279D                         00009572  | LAB_EVEZ                         00008AB4
LAB_27A1                         00009576  | LAB_1ACC                         00008AB6
LAB_27AB                         00009870  | LAB_1ADB                         00008AC1
LAB_27AE                         00009873  | LAB_1ADE                         00008AC4
LAB_27B0                         00009875  | LAB_1AFA                         00008ADF
LAB_27B9                         0000987E  | LAB_1B0B                         00008AF2
LAB_27BA                         0000987F  | LAB_1B13                         00008AF8
LAB_27C2                         00009887  | LAB_1B1C                         00008B01
LAB_27CA                         0000988F  | LAB_1B1D                         00008B02
LAB_27CE                         00009893  | LAB_1B2A                         00008B0F
LAB_27D0                         00009895  | LAB_1B34                         00008B1B
LAB_27D7                         0000989C  | LAB_1B3C                         00008B23
LAB_27DB                         000098A0  | LAB_1B43                         00008B2A
LAB_27E3                         000098A6  | LAB_1B53                         00008B3E
LAB_27F8                         000098B9  | LAB_1B5B                         00008B41
LAB_27FA                         000098BB  | LAB_1B66                         00008B4C
LAB_2828                         000098E9  | LAB_1B78                         00008B5E
LAB_282E                         000098EF  | LAB_1B7B                         00008B61
LAB_2831                         000098F1  | LAB_1B7D                         00008B63
LAB_2845                         00009905  | LAB_1B84                         00008B6A
LAB_2850                         00009910  | LAB_1B86                         00008B6C
LAB_2851                         00009911  | LAB_1B9D                         00008B83

Portable 65xx Assembler [20.01]

LAB_287F                         0000993F  | LAB_1BC1                         00008B86
LAB_2886                         00009946  | LAB_1BCA                         00008B8F
LAB_2887                         00009947  | LAB_GVAL                         00008B95
LAB_288B                         0000994B  | LAB_1BA9                         00008B9A
LAB_289A                         0000995A  | LAB_1BAC                         00008B9D
LAB_289C                         0000995E  | LAB_1BF7                         00008BB4
LAB_289D                         00009963  | LAB_1BFB                         00008BB7
LAB_289E                         00009971  | LAB_SCCA                         00008BB9
LAB_28A1                         00009974  | LAB_1BFE                         00008BC0
LAB_28A3                         00009976  | LAB_1C01                         00008BC4
LAB_28C2                         00009995  | LAB_SNER                         00008BC8
LAB_28C4                         00009997  | LAB_1BD0                         00008BCD
LAB_28C7                         0000999A  | LAB_EQUAL                        00008BDD
LAB_28C9                         0000999C  | LAB_1BE7                         00008BEC
LAB_28D5                         000099A7  | LAB_1BEE                         00008BF3
LAB_28DB                         000099AD  | LAB_1C11                         00008BF9
LAB_28DD                         000099AF  | LAB_1C13                         00008BFB
LAB_28E6                         000099B8  | LAB_1C18                         00008C00
LAB_28EF                         000099C1  | LAB_1C18p2                       00008C02
LAB_28F6                         000099C8  | LAB_1C24                         00008C0B
LAB_28FB                         000099CD  | LAB_1C25                         00008C0E
LAB_28FE                         000099D0  | LAB_1C27                         00008C0F
LAB_2905                         000099D7  | LAB_1C56                         00008C23
LAB_2912                         000099E2  | LAB_PPFS                         00008C24
LAB_2925                         000099F5  | LAB_PPFN                         00008C2A
LAB_2934                         00009A04  | LAB_PPBI                         00008C30
LAB_2942                         00009A0D  | LAB_LRMS                         00008C35
LAB_2947                         0000A04A  | LAB_BHSS                         00008C4D
LAB_294B                         0000A04E  | LAB_CFAC                         00008C5E
LAB_294F                         0000A052  | LAB_1C54                         00008C78
LAB_2953                         00009A11  | LAB_BHER                         00008C79
LAB_295E                         00009A1C  | LAB_EOR                          00008C7C
LAB_296E                         00009A2F  | LAB_OR                           00008C89
LAB_2978                         00009A39  | LAB_AND                          00008C96
LAB_297B                         00009A3C  | GetFirst                         00008CA3
LAB_2989                         00009A4A  | LAB_1C95                         00008CB6
LAB_299A                         00009A59  | LAB_LTHAN                        00008CB7
LAB_299C                         00009A5B  | LAB_1CAE                         00008CCE
LAB_29A7                         00009A66  | LAB_1CD6                         00008CF4
LAB_29B2                         00009A71  | LAB_1CDB                         00008CF9
LAB_29B9                         00009A78  | LAB_1CE1                         00008CFF
LAB_29C0                         00009A7F  | LAB_1CE6                         00008D04
LAB_29C3                         00009A82  | LAB_1CF2                         00008D10
LAB_29D8                         00009A97  | LAB_1CFB                         00008D19
LAB_29D9                         00009A98  | LAB_1CFE                         00008D1C
LAB_29E4                         00009AA3  | LAB_DIM                          00008D1F
LAB_29F5                         00009AB4  | LAB_LSHIFT                       00008D29
LAB_29F7                         00009AB6  | Ls_loop                          00008D36
LAB_29FB                         00009ABA  | LAB_RSHIFT                       00008D41
LAB_2A18                         00009AD7  | Rs_loop                          00008D4E
LAB_2A1A                         00009AD9  | NoShift                          00008D54
LAB_2A21                         00009AE0  | TooBig                           00008D59
LAB_2A3B                         00009AFA  | GetPair                          00008D5F
LAB_2A4B                         00009B0A  | LAB_GVAR                         00008D6A

Portable 65xx Assembler [20.01]

LAB_2A58                         00009B17  | LAB_1D10                         00008D6F
LAB_2A68                         00009B27  | LAB_1D12                         00008D71
LAB_2A74                         00009B33  | LAB_1D1F                         00008D7D
LAB_2A89                         00009B48  | LAB_1D2D                         00008D8B
LAB_2A8C                         00009B4B  | LAB_1D2E                         00008D8C
LAB_2A91                         00009B50  | LAB_1D38                         00008D96
LAB_2A96                         0000A0BA  | LAB_1D47                         00008DA5
LAB_2A9A                         0000A0C6  | LAB_1D53                         00008DB0
LAB_2A9B                         0000A0C7  | LAB_1D5D                         00008DB8
LAB_2A9C                         0000A0C8  | LAB_1D5F                         00008DBA
LAB_2ABF                         00009B5E  | LAB_1D69                         00008DC4
LAB_2AD9                         00009B78  | LAB_1D77                         00008DD2
LAB_2AF9                         00009B98  | LAB_CASC                         00008DDC
LAB_2AFA                         0000A056  | LAB_1D82                         00008DE0
LAB_2AFD                         0000A0B5  | LAB_1D8A                         00008DE9
LAB_2AFE                         0000A05A  | LAB_1D83                         00008DEA
LAB_2B2B                         00009BA9  | LAB_1D8B                         00008DF0
LAB_2B36                         00009BB4  | LAB_1D98                         00008DFB
LAB_2B39                         00009BB7  | LAB_1DAE                         00008E11
LAB_2B49                         00009BC7  | LAB_1DD7                         00008E3A
LAB_2B6E                         00009BE9  | LAB_1DE1                         00008E44
LAB_2B84                         00009BFF  | LAB_1DE6                         00008E49
LAB_2B88                         00009C03  | LAB_1DF2                         00008E55
LAB_2B97                         00009C14  | LAB_EVIN                         00008E5A
LAB_2B9B                         00009C18  | LAB_EVPI                         00008E60
LAB_2BA8                         00009C25  | LAB_EVIR                         00008E64
LAB_2C35                         00009CA0  | LAB_1E12                         00008E71
LAB_2C38                         00009CA3  | LAB_1E14                         00008E73
LAB_2C45                         00009CB0  | LAB_1E17                         00008E76
LAB_2C74                         00009CDB  | LAB_1E1F                         00008E7E
LAB_2C78                         0000A077  | LAB_1E5C                         00008EB9
LAB_2C7C                         0000A08C  | LAB_1E68                         00008EC5
LAB_2C80                         0000A0BE  | LAB_1E77                         00008ED4
LAB_2C84                         0000A07B  | LAB_1E85                         00008EE2
LAB_2CA1                         00009CEC  | LAB_FCER                         00008EE6
LAB_2CAF                         00009CFA  | LAB_1E8A                         00008EE8
LAB_2CC2                         00009D0D  | LAB_1E8D                         00008EEB
LAB_2CC9                         0000A090  | LAB_1EA1                         00008EFF
LAB_2D04                         00009D26  | LAB_1EC0                         00008F1B
LAB_2D05                         00009FF2  | LAB_1ED0                         00008F2A
LAB_2D13                         0000802D  | LAB_1EF3                         00008F4D
LAB_2D93                         00008059  | LAB_1F02                         00008F5C
LAB_2D99                         00008069  | LAB_1F07                         00008F61
LAB_2DB6                         00008078  | LAB_1F24                         00008F7E
LAB_2E05                         00008091  | LAB_1F28                         00008F82
LAB_A2HX                         00009DE0  | LAB_1F2C                         00008F86
LAB_ABS                          000098B6  | LAB_1F42                         00008F9C
LAB_ADD                          0000956E  | LAB_1F45                         00008F9F
LAB_AL20                         00009DF1  | LAB_1F48                         00008FA2
LAB_AL2X                         00009DEB  | LAB_1F49                         00008FA3
LAB_AND                          00008C96  | LAB_1F5A                         00008FB3
LAB_ASC                          0000942C  | LAB_1F7B                         00008FD0
LAB_ATN                          00009CE4  | LAB_1F7C                         00008FD1
LAB_AYFC                         00009016  | LAB_1F8F                         00008FE4

Portable 65xx Assembler [20.01]

LAB_BAER                         0000A553  | LAB_1FA8                         00008FFD
LAB_BHER                         00008C79  | LAB_FRE                          00009002
LAB_BHSS                         00008C4D  | LAB_1FB4                         00009009
LAB_BINS                         00009D65  | LAB_AYFC                         00009016
LAB_BITCLR                       00009D27  | LAB_POS                          00009021
LAB_BITSET                       00009D13  | LAB_1FD0                         00009023
LAB_BMSG                         0000A688  | LAB_CKRN                         00009027
LAB_BTST                         00009D3D  | LAB_1FD9                         0000902C
LAB_CALL                         00009525  | LAB_1FDB                         0000902E
LAB_CASC                         00008DDC  | LAB_DEF                          00009031
LAB_CBIN                         00009E2F  | LAB_200B                         00009061
LAB_CFAC                         00008C5E  | LAB_201E                         00009070
LAB_CHEX                         00009E01  | LAB_2043                         00009098
LAB_CHRS                         0000933C  | LAB_2074                         000090C9
LAB_CKRN                         00009027  | LAB_207A                         000090CF
LAB_CKTM                         00008A9E  | LAB_STRS                         000090E1
LAB_CLEAR                        00008395  | LAB_209C                         000090ED
LAB_COLD                         0000802B  | LAB_MSSP                         000090F5
LAB_CONT                         00008570  | LAB_20AE                         000090FF
LAB_COS                          00009C69  | LAB_20B4                         00009105
LAB_CRLF                         0000885F  | LAB_20BE                         0000910F
LAB_CTBL                         0000A0D8  | LAB_20CB                         0000911C
LAB_CTNM                         00008A9A  | LAB_20CF                         00009120
LAB_CTST                         00008A9D  | LAB_20D0                         00009121
LAB_DATA                         0000866E  | LAB_20DC                         0000912D
LAB_DEC                          0000875B  | LAB_MVST                         00009137
LAB_DEEK                         000094C5  | LAB_RTST                         00009142
LAB_DEF                          00009031  | LAB_20F5                         0000914A
LAB_DIM                          00008D1F  | LAB_20F8                         0000914D
LAB_DIVIDE                       000097AB  | LAB_2115                         00009169
LAB_DO                           00008596  | LAB_2117                         0000916B
LAB_DOKE                         000094D8  | LAB_2122                         00009176
LAB_DONOK                        000085FA  | LAB_212C                         00009180
LAB_EMSG                         0000A690  | LAB_2137                         0000918B
LAB_END                          0000850B  | LAB_GARB                         0000919B
LAB_EOR                          00008C7C  | LAB_214B                         0000919F
LAB_EQUAL                        00008BDD  | LAB_2161                         000091B3
LAB_ESGL                         00009427  | LAB_216A                         000091BC
LAB_EVBY                         00009440  | LAB_2176                         000091C6
LAB_EVEX                         00008AAC  | LAB_217E                         000091CE
LAB_EVEZ                         00008AB4  | LAB_2183                         000091D3
LAB_EVIN                         00008E5A  | LAB_218B                         000091DB
LAB_EVIR                         00008E64  | LAB_218F                         000091DF
LAB_EVNM                         00008A97  | LAB_219A                         000091E7
LAB_EVPI                         00008E60  | LAB_21C4                         0000920A
LAB_EVST                         000092F3  | LAB_21CC                         00009212
LAB_EXCH                         00009E38  | LAB_21D1                         00009217
LAB_EXIT                         00009FF3  | LAB_21D7                         0000921D
LAB_EXP                          00009B99  | LAB_21EC                         00009232
LAB_F2FU                         000094A5  | LAB_21F6                         0000923C
LAB_F2FX                         0000949F  | LAB_2206                         0000924C
LAB_FB95                         00009E67  | LAB_2207                         0000924D
LAB_FB96                         00009E6C  | LAB_2208                         0000924F
LAB_FBA0                         00009E50  | LAB_2211                         00009257

Portable 65xx Assembler [20.01]

LAB_FBA2                         00009E58  | LAB_2216                         0000925C
LAB_FCER                         00008EE6  | LAB_224D                         0000928E
LAB_FOR                          0000844D  | LAB_226D                         000092AC
LAB_FRE                          00009002  | LAB_228A                         000092C9
LAB_FTBL                         0000A16E  | LAB_2298                         000092D7
LAB_FTBM                         0000A16F  | LAB_229C                         000092DB
LAB_FTPL                         0000A128  | LAB_22A0                         000092E0
LAB_FTPM                         0000A129  | LAB_22A9                         000092E9
LAB_GADB                         00009486  | LAB_22B2                         000092F2
LAB_GARB                         0000919B  | LAB_EVST                         000092F3
LAB_GBYT                         00009FDE  | LAB_22B6                         000092F6
LAB_GET                          000087F6  | LAB_22BA                         000092FA
LAB_GETS                         0000880B  | LAB_22E5                         00009325
LAB_GFPN                         0000872B  | LAB_22E6                         00009326
LAB_GMEM                         0000803F  | LAB_22EB                         0000932B
LAB_GOSUB                        000085B0  | LAB_22FB                         0000933B
LAB_GOTO                         000085CD  | LAB_CHRS                         0000933C
LAB_GTBY                         0000943D  | LAB_LEFT                         0000934B
LAB_GTHAN                        00009B8E  | LAB_RIGHT                        00009354
LAB_GVAL                         00008B95  | LAB_2316                         0000935D
LAB_GVAR                         00008D6A  | LAB_231C                         00009363
LAB_HEXS                         00009DB4  | LAB_231D                         00009364
LAB_IF                           0000869D  | LAB_231E                         00009365
LAB_IGBY                         00009FD8  | LAB_2335                         0000937B
LAB_IMSG                         0000A6AB  | LAB_MIDS                         00009382
LAB_INC                          0000875F  | LAB_2358                         00009394
LAB_INLN                         00008231  | LAB_236F                         000093AB
LAB_INPUT                        00008915  | LAB_LCASE                        000093C5
LAB_INT                          00009922  | LC_loop                          000093D5
LAB_ISHN                         00009E10  | NoUcase                          000093DF
LAB_IsByte                       00008811  | LAB_UCASE                        000093E6
LAB_KEYT                         0000A3CB  | UC_loop                          000093F6
LAB_LCASE                        000093C5  | NoLcase                          00009400
LAB_LEFT                         0000934B  | NoString                         00009405
LAB_LENS                         00009421  | LAB_SADD                         00009408
LAB_LET                          00008789  | LAB_LENS                         00009421
LAB_LIST                         00008398  | LAB_ESGL                         00009427
LAB_LMSG                         0000A697  | LAB_ASC                          0000942C
LAB_LOG                          000096A4  | LAB_23A8                         00009437
LAB_LOOP                         000085FF  | LAB_SGBY                         0000943A
LAB_LRMS                         00008C35  | LAB_GTBY                         0000943D
LAB_LSHIFT                       00008D29  | LAB_EVBY                         00009440
LAB_LTHAN                        00008CB7  | LAB_VAL                          0000944C
LAB_MAX                          00009E73  | LAB_23C5                         00009454
LAB_MIDS                         00009382  | LAB_23F3                         0000947D
LAB_MIN                          00009E83  | LAB_GADB                         00009486
LAB_MLBT                         00009E29  | LAB_SCGB                         0000948C
LAB_MLTE                         00009DFB  | LAB_F2FX                         0000949F
LAB_MLTO                         00009E1B  | LAB_F2FU                         000094A5
LAB_MMEC                         00009E95  | LAB_PEEK                         000094B1
LAB_MMPP                         00009E6D  | LAB_POKE                         000094BC
LAB_MMSE                         00009E9E  | LAB_DEEK                         000094C5
LAB_MSSP                         000090F5  | Deekh                            000094D3
LAB_MULTIPLY                     000096E5  | LAB_DOKE                         000094D8

Portable 65xx Assembler [20.01]

LAB_MVST                         00009137  | Dokeh                            000094F6
LAB_NEW                          00008346  | LAB_SWAP                         000094FD
LAB_NEXT                         00008A2F  | SwapLp                           00009514
LAB_NHEX                         0000996A  | SwapErr                          00009522
LAB_NLTO                         00009DF7  | LAB_CALL                         00009525
LAB_NOSQ                         00009F28  | CallExit                         00009534
LAB_NOTT                         00009D62  | LAB_WAIT                         00009537
LAB_NSTT                         00009EEA  | LAB_2441                         00009546
LAB_NULL                         0000856A  | LAB_2445                         00009548
LAB_NXCH                         00009E1E  | LAB_244D                         00009550
LAB_NoSt                         0000881B  | LAB_2455                         00009551
LAB_OMER                         00008131  | LAB_SUBTRACT                     00009554
LAB_ON                           0000870B  | LAB_2467                         00009562
LAB_OPPT                         0000A1B4  | LAB_244E                         00009567
LAB_OR                           00008C89  | LAB_246C                         0000956B
LAB_PEEK                         000094B1  | LAB_ADD                          0000956E
LAB_PFAC                         00009849  | LAB_279B                         00009570
LAB_PHFA                         00009EA1  | LAB_279D                         00009572
LAB_PI                           00009FC7  | LAB_27A1                         00009576
LAB_POKE                         000094BC  | LAB_2474                         00009580
LAB_POS                          00009021  | LAB_247C                         00009588
LAB_POWER                        00009B55  | LAB_2498                         000095A2
LAB_PPBI                         00008C30  | LAB_249C                         000095A4
LAB_PPFN                         00008C2A  | LAB_24A8                         000095B0
LAB_PPFS                         00008C24  | LAB_24B4                         000095BC
LAB_PRINT                        00008826  | LAB_24D0                         000095D8
LAB_PRNA                         000088BB  | LAB_24D5                         000095DD
LAB_READ                         00008934  | LAB_24D9                         000095E1
LAB_REDO                         0000A6BC  | LAB_24F1                         000095F9
LAB_REM                          00008702  | LAB_24F3                         000095FB
LAB_RESTORE                      0000852C  | LAB_24F5                         000095FD
LAB_RESTOREn                     0000853D  | LAB_24F8                         00009600
LAB_RETURN                       00008659  | LAB_2511                         00009619
LAB_RIGHT                        00009354  | LAB_251B                         00009623
LAB_RMSG                         0000A6A1  | LAB_2528                         00009630
LAB_RND                          00009C35  | LAB_252A                         00009632
LAB_RSHIFT                       00008D41  | LAB_2536                         0000963E
LAB_RTST                         00009142  | LAB_2537                         0000963F
LAB_RUN                          0000858C  | LAB_253D                         00009645
LAB_SADD                         00009408  | LAB_2559                         00009661
LAB_SCCA                         00008BB9  | LAB_2563                         0000966B
LAB_SCGB                         0000948C  | LAB_2564                         0000966C
LAB_SGBY                         0000943A  | LAB_2569                         00009671
LAB_SGN                          0000989D  | LAB_256B                         00009673
LAB_SHLN                         00008320  | LAB_257B                         00009683
LAB_SIN                          00009C70  | LAB_2588                         00009690
LAB_SKFE                         000001FE  | LAB_258E                         00009696
LAB_SKFF                         000001FF  | LAB_2592                         0000969A
LAB_SMSG                         0000A020  | LAB_259A                         000096A2
LAB_SNBL                         00008683  | LAB_LOG                          000096A4
LAB_SNBLb                        00008685  | LAB_25C4                         000096AB
LAB_SNBS                         0000867F  | LAB_25C7                         000096AE
LAB_SNER                         00008BC8  | LAB_25FB                         000096E2
LAB_SQE1                         00009F4C  | LAB_MULTIPLY                     000096E5

Portable 65xx Assembler [20.01]

LAB_SQE2                         00009F5A  | LAB_2622                         00009707
LAB_SQNS                         00009FA7  | LAB_2627                         0000970C
LAB_SQR                          00009F2C  | LAB_262A                         0000970F
LAB_SSLN                         0000831C  | LAB_2640                         00009725
LAB_STAK                         00000100  | LAB_264C                         00009731
LAB_STFA                         000098AB  | LAB_264D                         00009732
LAB_STOP                         00008509  | LAB_2673                         00009758
LAB_STRS                         000090E1  | LAB_2675                         0000975A
LAB_SUBTRACT                     00009554  | LAB_2680                         00009766
LAB_SULP                         00009F15  | LAB_2680b                        00009768
LAB_SVTB                         00009F09  | LAB_268B                         00009771
LAB_SWAP                         000094FD  | LAB_268F                         00009775
LAB_TAN                          00009CB7  | LAB_2690                         00009776
LAB_TBSZ                         00009EF5  | LAB_2696                         0000977A
LAB_TWOPI                        00009FD1  | LAB_269E                         0000977F
LAB_UCASE                        000093E6  | LAB_269B                         00009795
LAB_UFAC                         00009823  | LAB_26B9                         00009798
LAB_USR                          00009CDE  | LAB_26C2                         000097A1
LAB_VAL                          0000944C  | LAB_26CA                         000097A8
LAB_VARPTR                       00009FB7  | LAB_DIVIDE                       000097AB
LAB_WAIT                         00009537  | LAB_26E4                         000097C2
LAB_WARM                         00000000  | LAB_26F4                         000097D2
LAB_WDLP                         00009F16  | LAB_2701                         000097E1
LAB_WDTH                         00009ED6  | LAB_2702                         000097E4
LAB_XERR                         00008133  | LAB_2704                         000097FB
LAB_go_search                    00008558  | LAB_272B                         00009807
LAB_line_found                   00008560  | LAB_2737                         0000980F
LAB_no_ELSE                      000086D5  | LAB_273C                         00009814
LAB_reset_search                 00008554  | LAB_UFAC                         00009823
LAB_uflow                        00008537  | LAB_276E                         00009843
LBB_ABS                          0000A247  | LAB_2770                         00009845
LBB_AND                          0000A24B  | LAB_PFAC                         00009849
LBB_ASC                          0000A24E  | LAB_2778                         0000984D
LBB_ATN                          0000A252  | LAB_27AB                         00009870
LBB_BINS                         0000A257  | LAB_27AE                         00009873
LBB_BITCLR                       0000A25C  | LAB_27B0                         00009875
LBB_BITSET                       0000A262  | LAB_27B9                         0000987E
LBB_BITTST                       0000A268  | LAB_27BA                         0000987F
LBB_CALL                         0000A270  | LAB_27C2                         00009887
LBB_CHRS                         0000A274  | LAB_27CA                         0000988F
LBB_CLEAR                        0000A279  | LAB_27CE                         00009893
LBB_CONT                         0000A27E  | LAB_27D0                         00009895
LBB_COS                          0000A282  | LAB_27D7                         0000989C
LBB_DATA                         0000A287  | LAB_SGN                          0000989D
LBB_DEC                          0000A28B  | LAB_27DB                         000098A0
LBB_DEEK                         0000A28E  | LAB_27E3                         000098A6
LBB_DEF                          0000A293  | LAB_STFA                         000098AB
LBB_DIM                          0000A296  | LAB_ABS                          000098B6
LBB_DO                           0000A29D  | LAB_27F8                         000098B9
LBB_DOKE                         0000A299  | LAB_27FA                         000098BB
LBB_ELSE                         0000A2A0  | LAB_2828                         000098E9
LBB_END                          0000A2A4  | LAB_282E                         000098EF
LBB_EOR                          0000A2A7  | LAB_2831                         000098F1
LBB_EXIT                         0000A2AE  | LAB_2845                         00009905

Portable 65xx Assembler [20.01]

LBB_EXP                          0000A2AA  | LAB_2850                         00009910
LBB_FN                           0000A2B3  | LAB_2851                         00009911
LBB_FOR                          0000A2B5  | LAB_INT                          00009922
LBB_FRE                          0000A2B8  | LAB_287F                         0000993F
LBB_GET                          0000A2BD  | LAB_2886                         00009946
LBB_GOSUB                        0000A2C0  | LAB_2887                         00009947
LBB_GOTO                         0000A2C5  | LAB_288B                         0000994B
LBB_HEXS                         0000A2CA  | LAB_289A                         0000995A
LBB_IF                           0000A2D0  | LAB_289C                         0000995E
LBB_INC                          0000A2D2  | LAB_289D                         00009963
LBB_INPUT                        0000A2D5  | LAB_NHEX                         0000996A
LBB_INT                          0000A2DA  | LAB_289E                         00009971
LBB_LCASES                       0000A2DF  | LAB_28A1                         00009974
LBB_LEFTS                        0000A2E6  | LAB_28A3                         00009976
LBB_LEN                          0000A2EC  | LAB_28C2                         00009995
LBB_LET                          0000A2F0  | LAB_28C4                         00009997
LBB_LIST                         0000A2F3  | LAB_28C7                         0000999A
LBB_LOAD                         0000A2F7  | LAB_28C9                         0000999C
LBB_LOG                          0000A2FB  | LAB_28D5                         000099A7
LBB_LOOP                         0000A2FF  | LAB_28DB                         000099AD
LBB_LSHIFT                       0000A23B  | LAB_28DD                         000099AF
LBB_MAX                          0000A304  | LAB_28E6                         000099B8
LBB_MIDS                         0000A308  | LAB_28EF                         000099C1
LBB_MIN                          0000A30D  | LAB_28F6                         000099C8
LBB_NEW                          0000A312  | LAB_28FB                         000099CD
LBB_NEXT                         0000A315  | LAB_28FE                         000099D0
LBB_NOT                          0000A319  | LAB_2905                         000099D7
LBB_NULL                         0000A31C  | LAB_2912                         000099E2
LBB_ON                           0000A321  | LAB_2925                         000099F5
LBB_OR                           0000A323  | LAB_2934                         00009A04
LBB_PEEK                         0000A326  | LAB_2942                         00009A0D
LBB_PI                           0000A32B  | LAB_2953                         00009A11
LBB_POKE                         0000A32D  | LAB_295E                         00009A1C
LBB_POS                          0000A331  | LAB_296E                         00009A2F
LBB_PRINT                        0000A335  | LAB_2978                         00009A39
LBB_READ                         0000A33B  | LAB_297B                         00009A3C
LBB_REM                          0000A33F  | LAB_2989                         00009A4A
LBB_RESTORE                      0000A342  | LAB_299A                         00009A59
LBB_RETURN                       0000A349  | LAB_299C                         00009A5B
LBB_RIGHTS                       0000A34F  | LAB_29A7                         00009A66
LBB_RND                          0000A356  | LAB_29B2                         00009A71
LBB_RSHIFT                       0000A241  | LAB_29B9                         00009A78
LBB_RUN                          0000A35A  | LAB_29C0                         00009A7F
LBB_SADD                         0000A35E  | LAB_29C3                         00009A82
LBB_SAVE                         0000A363  | LAB_29D8                         00009A97
LBB_SGN                          0000A367  | LAB_29D9                         00009A98
LBB_SIN                          0000A36B  | LAB_29E4                         00009AA3
LBB_SPC                          0000A36F  | LAB_29F5                         00009AB4
LBB_SQR                          0000A373  | LAB_29F7                         00009AB6
LBB_STEP                         0000A377  | LAB_29FB                         00009ABA
LBB_STOP                         0000A37B  | LAB_2A18                         00009AD7
LBB_STRS                         0000A37F  | LAB_2A1A                         00009AD9
LBB_SWAP                         0000A384  | LAB_2A21                         00009AE0
LBB_TAB                          0000A389  | LAB_2A3B                         00009AFA

Portable 65xx Assembler [20.01]

LBB_TAN                          0000A38D  | LAB_2A4B                         00009B0A
LBB_THEN                         0000A391  | LAB_2A58                         00009B17
LBB_TO                           0000A395  | LAB_2A68                         00009B27
LBB_TWOPI                        0000A397  | LAB_2A74                         00009B33
LBB_UCASES                       0000A39D  | LAB_2A89                         00009B48
LBB_UNTIL                        0000A3A4  | LAB_2A8C                         00009B4B
LBB_USR                          0000A3A9  | LAB_2A91                         00009B50
LBB_VAL                          0000A3AE  | LAB_POWER                        00009B55
LBB_VPTR                         0000A3B2  | LAB_2ABF                         00009B5E
LBB_WAIT                         0000A3BA  | LAB_2AD9                         00009B78
LBB_WHILE                        0000A3BE  | LAB_GTHAN                        00009B8E
LBB_WIDTH                        0000A3C3  | LAB_2AF9                         00009B98
LC_loop                          000093D5  | LAB_EXP                          00009B99
LoopAlways                       0000862E  | LAB_2B2B                         00009BA9
LoopDone                         00008648  | LAB_2B36                         00009BB4
LoopPRN                          00009C44  | LAB_2B39                         00009BB7
Ls_loop                          00008D36  | LAB_2B49                         00009BC7
Lvarph                           0000004A  | LAB_2B6E                         00009BE9
Lvarpl                           00000049  | LAB_2B84                         00009BFF
MEM_OK                           0000807C  | LAB_2B88                         00009C03
M_FLAG                           00000020  | LAB_2B97                         00009C14
N_FLAG                           00000080  | LAB_2B9B                         00009C18
Nbendh                           00000057  | LAB_2BA8                         00009C25
Nbendl                           00000056  | LAB_RND                          00009C35
NextB1                           00009D74  | NextPRN                          00009C40
NextB2                           00009D90  | LoopPRN                          00009C44
NextPRN                          00009C40  | Ninc1                            00009C53
Ninc1                            00009C53  | CopyPRNG                         00009C58
NoLcase                          00009400  | LAB_COS                          00009C69
NoShift                          00008D54  | LAB_SIN                          00009C70
NoString                         00009405  | LAB_2C35                         00009CA0
NoUcase                          000093DF  | LAB_2C38                         00009CA3
Nullct                           00000006  | LAB_2C45                         00009CB0
OSC_FREQ                         00384000  | LAB_TAN                          00009CB7
Obendh                           00000059  | LAB_2C74                         00009CDB
Obendl                           00000058  | LAB_USR                          00009CDE
Oquote                           00000012  | LAB_ATN                          00009CE4
Ostrth                           0000005D  | LAB_2CA1                         00009CEC
Ostrtl                           0000005C  | LAB_2CAF                         00009CFA
PCS7                             0000DF27  | LAB_2CC2                         00009D0D
PD0                              0000DF00  | LAB_BITSET                       00009D13
PD1                              0000DF01  | S_Bits                           00009D1D
PD2                              0000DF02  | LAB_2D04                         00009D26
PD3                              0000DF03  | LAB_BITCLR                       00009D27
PD4                              0000DF20  | S_Bitc                           00009D30
PD5                              0000DF21  | FCError                          00009D3A
PD6                              0000DF22  | LAB_BTST                         00009D3D
PD7                              0000DF23  | TST_OK                           00009D51
PDD0                             0000DF04  | T_Bits                           00009D57
PDD1                             0000DF05  | LAB_NOTT                         00009D62
PDD2                             0000DF06  | LAB_BINS                         00009D65
PDD3                             0000DF07  | NextB1                           00009D74
PDD4                             0000DF24  | EndBHS                           00009D8F
PDD5                             0000DF25  | NextB2                           00009D90

Portable 65xx Assembler [20.01]

PDD6                             0000DF26  | GoPr3                            00009D9C
PG2_TABE                         0000A014  | GoPr                             00009D9D
PG2_TABS                         0000A005  | GoPr1                            00009D9E
PIBER                            0000DF79  | GoPr2                            00009DA9
PIBFR                            0000DF78  | BinFErr                          00009DB1
PIR2                             0000DF7A  | LAB_HEXS                         00009DB4
PIR3                             0000DF7B  | LAB_A2HX                         00009DE0
PIR4                             0000DF7C  | LAB_AL2X                         00009DEB
PIR5                             0000DF7D  | LAB_AL20                         00009DF1
PIR6                             0000DF7E  | LAB_NLTO                         00009DF7
PIR7                             0000DF7F  | LAB_MLTE                         00009DFB
PLUS_0                           00000000  | LAB_CHEX                         00009E01
PLUS_1                           00000001  | LAB_ISHN                         00009E10
PLUS_2                           00000002  | LAB_MLTO                         00009E1B
PLUS_3                           00000003  | LAB_NXCH                         00009E1E
RDBYTE                           0000800B  | LAB_MLBT                         00009E29
RDBYTE.DONE                      00008017  | LAB_CBIN                         00009E2F
Ram_base                         00000800  | LAB_EXCH                         00009E38
Ram_top                          00008000  | CTRLC                            00009E3B
Rbyte1                           00000071  | LAB_FBA0                         00009E50
Rbyte2                           00000072  | LAB_FBA2                         00009E58
Rbyte3                           00000073  | INGET                            00009E59
Rbyte4                           00000070  | LAB_FB95                         00009E67
Rdptrh                           00000044  | LAB_FB96                         00009E6C
Rdptrl                           00000043  | LAB_MMPP                         00009E6D
Rs_loop                          00008D4E  | LAB_MAX                          00009E73
SSCR                             0000DF41  | LAB_MIN                          00009E83
STACK_RES                        00000020  | LAB_MMEC                         00009E95
SYSEXIT                          00008027  | LAB_MMSE                         00009E9E
SYSLOAD                          00008025  | LAB_PHFA                         00009EA1
SYSSAVE                          00008026  | LAB_WDTH                         00009ED6
S_Bitc                           00009D30  | LAB_NSTT                         00009EEA
S_Bits                           00009D1D  | LAB_TBSZ                         00009EF5
Sarryh                           00000030  | LAB_SVTB                         00009F09
Sarryl                           0000002F  | WExit                            00009F0B
Scnquo                           0000000E  | LAB_SULP                         00009F15
Sendh                            0000006D  | LAB_WDLP                         00009F16
Sendl                            0000006C  | LAB_NOSQ                         00009F28
Smemh                            0000002C  | TabErr                           00009F29
Smeml                            0000002B  | LAB_SQR                          00009F2C
Srchc                            0000000D  | LAB_SQE1                         00009F4C
Sstorh                           00000034  | LAB_SQE2                         00009F5A
Sstorl                           00000033  | LAB_SQNS                         00009FA7
StrTab                           0000A014  | LAB_VARPTR                       00009FB7
Sufnxf                           00000013  | LAB_PI                           00009FC7
Sutilh                           00000036  | LAB_TWOPI                        00009FD1
Sutill                           00000035  | LAB_IGBY                         00009FD8
Svarh                            0000002E  | LAB_GBYT                         00009FDE
Svarl                            0000002D  | LAB_2D05                         00009FF2
SwapErr                          00009522  | LAB_EXIT                         00009FF3
SwapLp                           00009514  | V_INPT                           00009FF6
T0CH                             0000DF61  | V_OUTP                           00009FF9
T0CL                             0000DF60  | V_LOAD                           00009FFC
T0LH                             0000DF51  | V_SAVE                           00009FFF

Portable 65xx Assembler [20.01]

T0LL                             0000DF50  | V_EXIT                           0000A002
T1CH                             0000DF63  | PG2_TABS                         0000A005
T1CL                             0000DF62  | PG2_TABE                         0000A014
T1LH                             0000DF53  | StrTab                           0000A014
T1LL                             0000DF52  | EndTab                           0000A020
T2CH                             0000DF65  | LAB_SMSG                         0000A020
T2CL                             0000DF64  | LAB_25A0                         0000A02D
T2LH                             0000DF55  | LAB_25AD                         0000A03A
T2LL                             0000DF54  | LAB_25B1                         0000A03E
T3CH                             0000DF67  | LAB_25B5                         0000A042
T3CL                             0000DF66  | LAB_25B9                         0000A046
T3LH                             0000DF57  | LAB_2947                         0000A04A
T3LL                             0000DF56  | LAB_294B                         0000A04E
T4CH                             0000DF69  | LAB_294F                         0000A052
T4CL                             0000DF68  | LAB_2AFA                         0000A056
T4LH                             0000DF59  | LAB_2AFE                         0000A05A
T4LL                             0000DF58  | LAB_2C78                         0000A077
T5CH                             0000DF6B  | LAB_2C84                         0000A07B
T5CL                             0000DF6A  | LAB_2C7C                         0000A08C
T5LH                             0000DF5B  | LAB_2CC9                         0000A090
T5LL                             0000DF5A  | LAB_259C                         0000A0B1
T6CH                             0000DF6D  | LAB_1D96                         0000A0B2
T6CL                             0000DF6C  | LAB_2AFD                         0000A0B5
T6LH                             0000DF5D  | LAB_1DF7                         0000A0B9
T6LL                             0000DF5C  | LAB_2A96                         0000A0BA
T7CH                             0000DF6F  | LAB_2C80                         0000A0BE
T7CL                             0000DF6E  | LAB_26B5                         0000A0C2
T7LH                             0000DF5F  | LAB_2A9A                         0000A0C6
T7LL                             0000DF5E  | LAB_2A9B                         0000A0C7
TAB_1STC                         0000A1DB  | LAB_2A9C                         0000A0C8
TAB_ASCA                         0000A247  | LAB_CTBL                         0000A0D8
TAB_ASCB                         0000A257  | LAB_FTPL                         0000A128
TAB_ASCC                         0000A270  | LAB_FTPM                         0000A129
TAB_ASCD                         0000A287  | LAB_FTBL                         0000A16E
TAB_ASCE                         0000A2A0  | LAB_FTBM                         0000A16F
TAB_ASCF                         0000A2B3  | LAB_OPPT                         0000A1B4
TAB_ASCG                         0000A2BD  | TAB_1STC                         0000A1DB
TAB_ASCH                         0000A2CA  | TAB_CHRT                         0000A1F9
TAB_ASCI                         0000A2D0  | TAB_STAR                         0000A233
TAB_ASCL                         0000A2DF  | TAB_PLUS                         0000A235
TAB_ASCM                         0000A304  | TAB_MNUS                         0000A237
TAB_ASCN                         0000A312  | TAB_SLAS                         0000A239
TAB_ASCO                         0000A321  | LBB_LSHIFT                       0000A23B
TAB_ASCP                         0000A326  | TAB_LESS                         0000A23B
TAB_ASCR                         0000A33B  | TAB_EQUL                         0000A23F
TAB_ASCS                         0000A35E  | LBB_RSHIFT                       0000A241
TAB_ASCT                         0000A389  | TAB_MORE                         0000A241
TAB_ASCU                         0000A39D  | TAB_QEST                         0000A245
TAB_ASCV                         0000A3AE  | LBB_ABS                          0000A247
TAB_ASCW                         0000A3BA  | TAB_ASCA                         0000A247
TAB_CHRT                         0000A1F9  | LBB_AND                          0000A24B
TAB_EQUL                         0000A23F  | LBB_ASC                          0000A24E
TAB_LESS                         0000A23B  | LBB_ATN                          0000A252
TAB_MNUS                         0000A237  | LBB_BINS                         0000A257

Portable 65xx Assembler [20.01]

TAB_MORE                         0000A241  | TAB_ASCB                         0000A257
TAB_PLUS                         0000A235  | LBB_BITCLR                       0000A25C
TAB_POWR                         0000A3C9  | LBB_BITSET                       0000A262
TAB_QEST                         0000A245  | LBB_BITTST                       0000A268
TAB_SLAS                         0000A239  | LBB_CALL                         0000A270
TAB_STAR                         0000A233  | TAB_ASCC                         0000A270
TCR                              0000DF42  | LBB_CHRS                         0000A274
TER                              0000DF43  | LBB_CLEAR                        0000A279
TIER                             0000DF46  | LBB_CONT                         0000A27E
TIFR                             0000DF44  | LBB_COS                          0000A282
TK_ABS                           000000C1  | LBB_DATA                         0000A287
TK_AND                           000000B7  | TAB_ASCD                         0000A287
TK_ASC                           000000D3  | LBB_DEC                          0000A28B
TK_ATN                           000000CC  | LBB_DEEK                         0000A28E
TK_BINS                          000000D8  | LBB_DEF                          0000A293
TK_BITCLR                        000000A6  | LBB_DIM                          0000A296
TK_BITSET                        000000A5  | LBB_DOKE                         0000A299
TK_BITTST                        000000D9  | LBB_DO                           0000A29D
TK_CALL                          0000009A  | LBB_ELSE                         0000A2A0
TK_CHRS                          000000D6  | TAB_ASCE                         0000A2A0
TK_CLEAR                         000000A0  | LBB_END                          0000A2A4
TK_CONT                          0000009E  | LBB_EOR                          0000A2A7
TK_COS                           000000C9  | LBB_EXP                          0000A2AA
TK_DATA                          00000083  | LBB_EXIT                         0000A2AE
TK_DEC                           00000088  | LBB_FN                           0000A2B3
TK_DEEK                          000000CE  | TAB_ASCF                         0000A2B3
TK_DEF                           00000097  | LBB_FOR                          0000A2B5
TK_DIM                           00000085  | LBB_FRE                          0000A2B8
TK_DIV                           000000B5  | LBB_GET                          0000A2BD
TK_DO                            0000009B  | TAB_ASCG                         0000A2BD
TK_DOKE                          00000099  | LBB_GOSUB                        0000A2C0
TK_ELSE                          000000A9  | LBB_GOTO                         0000A2C5
TK_END                           00000080  | LBB_HEXS                         0000A2CA
TK_EOR                           000000B8  | TAB_ASCH                         0000A2CA
TK_EQUAL                         000000BD  | LBB_IF                           0000A2D0
TK_EQUAL_PLUS                    0000000B  | TAB_ASCI                         0000A2D0
TK_EXIT                          000000A7  | LBB_INC                          0000A2D2
TK_EXP                           000000C8  | LBB_INPUT                        0000A2D5
TK_FN                            000000AB  | LBB_INT                          0000A2DA
TK_FOR                           00000081  | LBB_LCASES                       0000A2DF
TK_FRE                           000000C3  | TAB_ASCL                         0000A2DF
TK_GET                           000000A3  | LBB_LEFTS                        0000A2E6
TK_GOSUB                         0000008D  | LBB_LEN                          0000A2EC
TK_GOTO                          00000089  | LBB_LET                          0000A2F0
TK_GT                            000000BC  | LBB_LIST                         0000A2F3
TK_GT_PLUS                       0000000A  | LBB_LOAD                         0000A2F7
TK_HEXS                          000000D7  | LBB_LOG                          0000A2FB
TK_IF                            0000008B  | LBB_LOOP                         0000A2FF
TK_INC                           00000093  | LBB_MAX                          0000A304
TK_INPUT                         00000084  | TAB_ASCM                         0000A304
TK_INT                           000000C0  | LBB_MIDS                         0000A308
TK_LCASES                        000000D5  | LBB_MIN                          0000A30D
TK_LEFTS                         000000DF  | LBB_NEW                          0000A312
TK_LEN                           000000D0  | TAB_ASCN                         0000A312

Portable 65xx Assembler [20.01]

TK_LET                           00000087  | LBB_NEXT                         0000A315
TK_LIST                          0000009F  | LBB_NOT                          0000A319
TK_LOAD                          00000095  | LBB_NULL                         0000A31C
TK_LOG                           000000C7  | LBB_ON                           0000A321
TK_LOOP                          0000009C  | TAB_ASCO                         0000A321
TK_LSHIFT                        000000BB  | LBB_OR                           0000A323
TK_LT                            000000BE  | LBB_PEEK                         0000A326
TK_LT_PLUS                       0000000C  | TAB_ASCP                         0000A326
TK_MAX                           000000DA  | LBB_PI                           0000A32B
TK_MIDS                          000000E1  | LBB_POKE                         0000A32D
TK_MIN                           000000DB  | LBB_POS                          0000A331
TK_MINUS                         000000B3  | LBB_PRINT                        0000A335
TK_MUL                           000000B4  | LBB_READ                         0000A33B
TK_NEW                           000000A1  | TAB_ASCR                         0000A33B
TK_NEXT                          00000082  | LBB_REM                          0000A33F
TK_NOT                           000000AE  | LBB_RESTORE                      0000A342
TK_NULL                          00000092  | LBB_RETURN                       0000A349
TK_ON                            00000091  | LBB_RIGHTS                       0000A34F
TK_OR                            000000B9  | LBB_RND                          0000A356
TK_PEEK                          000000CD  | LBB_RUN                          0000A35A
TK_PI                            000000DC  | LBB_SADD                         0000A35E
TK_PLUS                          000000B2  | TAB_ASCS                         0000A35E
TK_POKE                          00000098  | LBB_SAVE                         0000A363
TK_POS                           000000C4  | LBB_SGN                          0000A367
TK_POWER                         000000B6  | LBB_SIN                          0000A36B
TK_PRINT                         0000009D  | LBB_SPC                          0000A36F
TK_READ                          00000086  | LBB_SQR                          0000A373
TK_REM                           0000008F  | LBB_STEP                         0000A377
TK_RESTORE                       0000008C  | LBB_STOP                         0000A37B
TK_RETURN                        0000008E  | LBB_STRS                         0000A37F
TK_RIGHTS                        000000E0  | LBB_SWAP                         0000A384
TK_RND                           000000C6  | LBB_TAB                          0000A389
TK_RSHIFT                        000000BA  | TAB_ASCT                         0000A389
TK_RUN                           0000008A  | LBB_TAN                          0000A38D
TK_SADD                          000000CF  | LBB_THEN                         0000A391
TK_SAVE                          00000096  | LBB_TO                           0000A395
TK_SGN                           000000BF  | LBB_TWOPI                        0000A397
TK_SIN                           000000CA  | LBB_UCASES                       0000A39D
TK_SPC                           000000AC  | TAB_ASCU                         0000A39D
TK_SQR                           000000C5  | LBB_UNTIL                        0000A3A4
TK_STEP                          000000AF  | LBB_USR                          0000A3A9
TK_STOP                          00000090  | LBB_VAL                          0000A3AE
TK_STRS                          000000D1  | TAB_ASCV                         0000A3AE
TK_SWAP                          000000A4  | LBB_VPTR                         0000A3B2
TK_TAB                           000000A8  | LBB_WAIT                         0000A3BA
TK_TAN                           000000CB  | TAB_ASCW                         0000A3BA
TK_THEN                          000000AD  | LBB_WHILE                        0000A3BE
TK_TO                            000000AA  | LBB_WIDTH                        0000A3C3
TK_TWOPI                         000000DD  | TAB_POWR                         0000A3C9
TK_UCASES                        000000D4  | LAB_KEYT                         0000A3CB
TK_UNTIL                         000000B0  | LAB_BAER                         0000A553
TK_USR                           000000C2  | ERR_NF                           0000A577
TK_VAL                           000000D2  | ERR_SN                           0000A588
TK_VPTR                          000000DE  | ERR_RG                           0000A58F

Portable 65xx Assembler [20.01]

TK_WAIT                          00000094  | ERR_OD                           0000A5A4
TK_WHILE                         000000B1  | ERR_FC                           0000A5B0
TK_WIDTH                         000000A2  | ERR_OV                           0000A5BE
TPos                             00000007  | ERR_OM                           0000A5C7
TST_OK                           00009D51  | ERR_US                           0000A5D5
TWidth                           00000008  | ERR_BS                           0000A5E9
T_Bits                           00009D57  | ERR_DD                           0000A5F6
TabErr                           00009F29  | ERR_D0                           0000A607
TabLoop                          00008041  | ERR_ID                           0000A616
TabSiz                           00000016  | ERR_TM                           0000A625
Temp3                            0000000D  | ERR_LS                           0000A633
TempB                            0000002A  | ERR_ST                           0000A643
Temp_2                           00000023  | ERR_CN                           0000A656
Tidx1                            00000049  | ERR_UF                           0000A665
Tindx                            0000000F  | ERR_LD                           0000A678
TooBig                           00008D59  | LAB_BMSG                         0000A688
UC_loop                          000093F6  | LAB_EMSG                         0000A690
UIER                             0000DF49  | LAB_LMSG                         0000A697
UIFR                             0000DF48  | LAB_RMSG                         0000A6A1
Usrjmp                           00000003  | LAB_IMSG                         0000A6AB
Usrjph                           00000005  | LAB_REDO                         0000A6BC
Usrjpl                           00000004  | AA_end_basic                     0000A6CF
VEC_CC                           00000482  | PD0                              0000DF00
VEC_EXIT                         0000048C  | PD1                              0000DF01
VEC_IN                           00000484  | PD2                              0000DF02
VEC_LD                           00000488  | PD3                              0000DF03
VEC_OUT                          00000486  | PDD0                             0000DF04
VEC_SV                           0000048A  | PDD1                             0000DF05
V_EXIT                           0000A002  | PDD2                             0000DF06
V_FLAG                           00000040  | PDD3                             0000DF07
V_INPT                           00009FF6  | PD4                              0000DF20
V_LOAD                           00009FFC  | PD5                              0000DF21
V_OUTP                           00009FF9  | PD6                              0000DF22
V_SAVE                           00009FFF  | PD7                              0000DF23
Varnm1                           00000045  | PDD4                             0000DF24
Varnm2                           00000046  | PDD5                             0000DF25
Vrschh                           0000005D  | PDD6                             0000DF26
Vrschl                           0000005C  | PCS7                             0000DF27
WExit                            00009F0B  | BCR                              0000DF40
WRBYTE                           00008018  | SSCR                             0000DF41
WRBYTE.WAIT                      00008019  | TCR                              0000DF42
Wrmjph                           00000002  | TER                              0000DF43
Wrmjpl                           00000001  | TIFR                             0000DF44
XOAw_h                           0000000E  | EIFR                             0000DF45
XOAw_l                           0000000D  | TIER                             0000DF46
X_FLAG                           00000010  | EIER                             0000DF47
ZPLastByte                       00000085  | UIFR                             0000DF48
ZPSTART                          00000000  | UIER                             0000DF49
Z_FLAG                           00000002  | T0LL                             0000DF50
__6501__                         00000000  | T0LH                             0000DF51
__6502__                         00000000  | T1LL                             0000DF52
__65816__                        00000000  | T1LH                             0000DF53
__65832__                        00000000  | T2LL                             0000DF54
__65C02__                        00000001  | T2LH                             0000DF55

Portable 65xx Assembler [20.01]

__65SC02__                       00000000  | T3LL                             0000DF56
ccbyte                           00000480  | T3LH                             0000DF57
ccflag                           0000047F  | T4LL                             0000DF58
ccnull                           00000481  | T4LH                             0000DF59
comp_f                           0000004D  | T5LL                             0000DF5A
csidx                            0000006C  | T5LH                             0000DF5B
des_2h                           00000051  | T6LL                             0000DF5C
des_2l                           00000050  | T6LH                             0000DF5D
des_ph                           00000061  | T7LL                             0000DF5E
des_pl                           00000060  | T7LH                             0000DF5F
des_sk                           0000001A  | T0CL                             0000DF60
dims_h                           00000029  | T0CH                             0000DF61
dims_l                           00000028  | T1CL                             0000DF62
expcnt                           0000005B  | T1CH                             0000DF63
expneg                           0000005D  | T2CL                             0000DF64
func_h                           0000004F  | T2CH                             0000DF65
func_l                           0000004E  | T3CL                             0000DF66
g_indx                           00000054  | T3CH                             0000DF67
g_step                           00000052  | T4CL                             0000DF68
garb_h                           0000004F  | T4CH                             0000DF69
garb_l                           0000004E  | T5CL                             0000DF6A
last_sh                          00000019  | T5CH                             0000DF6B
last_sl                          00000018  | T6CL                             0000DF6C
mids_l                           00000061  | T6CH                             0000DF6D
negnum                           00000063  | T7CL                             0000DF6E
next_s                           00000017  | T7CH                             0000DF6F
numbit                           0000005A  | ACSR0                            0000DF70
numcon                           00000063  | ARTD0                            0000DF71
numdpf                           0000005C  | ACSR1                            0000DF72
numexp                           0000005A  | ARTD1                            0000DF73
nums_1                           0000000A  | ACSR2                            0000DF74
nums_2                           0000000B  | ARTD2                            0000DF75
nums_3                           0000000C  | ACSR3                            0000DF76
prstk                            0000004B  | ARTD3                            0000DF77
sdescr                           0000006A  | PIBFR                            0000DF78
ssptr_h                          0000006B  | PIBER                            0000DF79
ssptr_l                          0000006A  | PIR2                             0000DF7A
str_ln                           0000005E  | PIR3                             0000DF7B
str_ph                           00000060  | PIR4                             0000DF7C
str_pl                           0000005F  | PIR5                             0000DF7D
ut1_ph                           00000024  | PIR6                             0000DF7E
ut1_pl                           00000023  | PIR7                             0000DF7F
ut2_ph                           00000026  | OSC_FREQ                         00384000
ut2_pl                           00000025  | BOOT_ENTRY                       00C00000
